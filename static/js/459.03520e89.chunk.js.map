{"version":3,"file":"static/js/459.03520e89.chunk.js","mappings":"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","sources":["workers/_utils.js","workers/_inputs.js","workers/mito.js","workers/_qc_metrics.js","workers/_qc_thresholds.js","workers/_qc_filter.js","workers/_normalization.js","workers/_model_gene_var.js","workers/_pca.js","workers/_neighbor_index.js","workers/_snn_neighbors.js","workers/_snn_graph.js","workers/_snn_cluster.js","workers/_choose_clustering.js","workers/_utils_viz_parent.js","workers/_tsne_monitor.js","workers/_umap_monitor.js","workers/_utils_markers.js","workers/_score_markers.js","workers/_custom_markers.js","workers/KanaDBHandler.js","workers/scran.worker.js","workers/_utils_serialize.js","../webpack/bootstrap","../webpack/runtime/chunk loaded","../webpack/runtime/compat get default export","../webpack/runtime/define property getters","../webpack/runtime/ensure chunk","../webpack/runtime/get javascript chunk filename","../webpack/runtime/get mini-css chunk filename","../webpack/runtime/global","../webpack/runtime/hasOwnProperty shorthand","../webpack/runtime/make namespace object","../webpack/runtime/publicPath","../webpack/runtime/importScripts chunk loading","../webpack/runtime/startup chunk dependencies","../webpack/startup"],"sourcesContent":["import * as scran from \"scran.js\";\n\nexport function freeCache(object) {\n    if (object !== undefined && object !== null) {\n        object.free();\n    }\n    return;\n}\n\nexport function freeReloaded(cache) {\n    if (\"reloaded\" in cache) {\n        for (const [k, v] of Object.entries(cache.reloaded)) {\n            if (v instanceof scran.WasmArray) {\n                v.free();\n            }\n        }\n        delete cache.reloaded;\n    }\n}\n\nexport function changedParameters(x, y) {\n    return JSON.stringify(x) != JSON.stringify(y);\n}\n\nexport function computeRange(arr) {\n    var max = -Infinity, min = Infinity;\n    arr.forEach(function (x) {\n        if (max < x) {\n            max = x;\n        }\n        if (min > x) {\n            min = x;\n        }\n    });\n    return [min, max];\n}\n\nexport function allocateCachedArray(size, type, cache, name = \"buffer\") {\n    var reallocate = true;\n    if (name in cache) {\n        var candidate = cache[name];\n        if (candidate.size != size || candidate.constructor.className != type) {\n            candidate.free();\n        } else {\n            reallocate = false;\n        }\n    }\n  \n    if (reallocate) {\n        switch (type) {\n            case \"Uint8Array\":\n                cache[name] = new scran.Uint8WasmArray(size);\n                break;\n            case \"Int32Array\":\n                cache[name] = new scran.Int32WasmArray(size);\n                break;\n            case \"Float64Array\":\n                cache[name] = new scran.Float64WasmArray(size);\n                break;\n            default:\n                // We only ever use one of the three above types in our \n                // internal data stores, so no need to go all-out here.\n                throw \"allocating '\" + type + \"' not yet supported\";\n        }\n    }\n\n    return cache[name];\n}\n\nexport function extractBuffers(object, store) {\n    if (Array.isArray(object)) {\n        for (const element of object) {\n            extractBuffers(element, store);\n        }\n    } else if (object.constructor == Object) {\n        for (const [key, element] of Object.entries(object)) {\n            extractBuffers(element, store);\n        }\n    } else if (ArrayBuffer.isView(object)) {\n        if (! (object.buffer instanceof ArrayBuffer)) {\n            throw \"only ArrayBuffers should be in the message payload\";\n        }\n        store.push(object.buffer);\n    }\n}\n","import * as scran from \"scran.js\";\nimport * as utils from \"./_utils.js\";\nimport * as hdf5 from \"h5wasm\";\nimport * as d3 from \"d3-dsv\";\nimport * as pako from \"pako\";\n\nvar cache = {};\nvar parameters = {};\nvar abbreviated = {};\n\nexport var changed = false;\n\nfunction permuteGenes(genes) {\n    var buf = new scran.Int32WasmArray(cache.matrix.numberOfRows());\n    try {\n        cache.matrix.permutation({ buffer: buf });\n\n        let perm = buf.array();\n        for (const [key, val] of Object.entries(genes)) {\n            let copy = val.slice();\n\n            for (var i = 0; i < perm.length; i++) {\n                copy[perm[i]] = val[i];\n            }\n            genes[key] = copy;\n        }\n    } finally {\n        buf.free();\n    }\n}\n\nfunction dummyGenes(numberOfRowss) {\n    let genes = []\n    for (let i = 0; i < numberOfRowss; i++) {\n        genes.push(`Gene ${i + 1}`);\n    }\n    return { \"id\": genes };\n}\n\nfunction readDSVFromBuffer(content, fname, delim = \"\\t\") {\n\n    var ext = fname.name.split('.').pop();\n\n    if (ext == \"gz\") {\n        content = pako.ungzip(content);\n    }\n\n    const dec = new TextDecoder();\n    let decoded = dec.decode(content);\n    const tsv = d3.dsvFormat(delim);\n    let parsed = tsv.parseRows(decoded);\n\n    return parsed;\n}\n\n/** Matrix Market **/\nfunction loadMatrixMarketRaw(files) {\n    utils.freeCache(cache.matrix);\n\n    // In theory, this section may support multiple files (e.g., for multiple samples).\n    var mtx_files = files.filter(x => x.type == \"mtx\");\n    var first_mtx = mtx_files[0];\n    var contents = new Uint8Array(first_mtx.buffer);\n    var ext = first_mtx.name.split('.').pop();\n    var is_compressed = (ext == \"gz\");\n    cache.matrix = scran.initializeSparseMatrixFromMatrixMarketBuffer(contents, { \"compressed\": is_compressed });\n\n    var genes_file = files.filter(x => x.type == \"genes\");\n    if (genes_file.length == 1) {\n        var genes_file = genes_file[0]\n        var content = new Uint8Array(genes_file.buffer);\n\n        let parsed = readDSVFromBuffer(content, genes_file);\n\n        if (parsed.length != cache.matrix.numberOfRows()) {\n            throw \"number of matrix rows is not equal to the number of genes in '\" + genes_file.name + \"'\";\n        }\n\n        var ids = [], symb = [];\n        parsed.forEach(x => {\n            ids.push(x[0]);\n            symb.push(x[1]);\n        });\n\n        cache.genes = { \"id\": ids, \"symbol\": symb };\n    } else {\n        cache.genes = dummyGenes(cache.matrix.numberOfRows());\n    }\n\n    permuteGenes(cache.genes);\n\n    var annotations_file = files.filter(x => x.type == \"annotations\");\n    if (annotations_file.length == 1) {\n        var annotations_file = annotations_file[0]\n        var content = new Uint8Array(annotations_file.buffer);\n\n        let parsed = readDSVFromBuffer(content, annotations_file);\n\n        let diff = cache.matrix.numberOfColumns() - parsed.length;\n        // check if a header is present or not\n        let headerFlag = false;\n        if (diff === 0) {\n            headerFlag = false;\n        } else if (diff === -1) {\n            headerFlag = true;\n        } else {\n            throw \"number of annotations rows is not equal to the number of cells in '\" + annotations_file.name + \"'\";\n        }\n\n        let headers = [];\n        if (headerFlag) {\n            headers = parsed.shift();\n        } else {\n            parsed[0].forEach((x, i) => {\n                headers.push(`Column_${i + 1}`);\n            })\n        }\n\n        cache.annotations = {}\n        headers.forEach((x, i) => {\n            cache.annotations[x] = parsed.map(y => y[i]);\n        });\n\n    } else {\n        cache.annotations = null;\n    }\n\n    return;\n}\n\nfunction loadMatrixMarket(args) {\n    var reader = new FileReaderSync();\n\n    // First pass computes an abbreviated version to quickly check for changes.\n    // Second pass does the actual readArrayBuffer.\n    for (var it = 0; it < 2; it++) {\n        var formatted = { \"type\": \"MatrixMarket\", \"files\": [] };\n\n        var bufferFun;\n        if (it == 0) {\n            bufferFun = (f) => f.size;\n        } else {\n            bufferFun = (f) => reader.readAsArrayBuffer(f);\n        }\n\n        for (const f of args.mtx) {\n            formatted.files.push({ \"type\": \"mtx\", \"name\": f.name, \"buffer\": bufferFun(f) });\n        }\n\n        if (args.gene !== null) {\n            if (args.gene.length !== 1) {\n                throw \"expected no more than one gene file\";\n            }\n            var genes_file = args.gene[0];\n            formatted.files.push({ \"type\": \"genes\", \"name\": genes_file.name, \"buffer\": bufferFun(genes_file) });\n        }\n\n        if (args.barcode !== null) {\n            if (args.barcode.length !== 1) {\n                throw \"expected no more than one cell annotation file\";\n            }\n            var annotations_file = args.barcode[0];\n            formatted.files.push({ \"type\": \"annotations\", \"name\": annotations_file.name, \"buffer\": bufferFun(annotations_file) });\n        }\n\n        if (it == 0) {\n            if (!utils.changedParameters(abbreviated, formatted)) {\n                changed = false;\n                return;\n            } else {\n                abbreviated = formatted;\n                changed = true;\n            }\n        } else {\n            parameters = formatted;\n            loadMatrixMarketRaw(formatted.files);\n            delete cache.reloaded;\n        }\n    }\n\n    return;\n}\n\n/** HDF5 **/\n\nfunction guessPath(f) {\n    var fkeys = f.keys();\n    if (fkeys.indexOf(\"X\") != -1) {\n        return \"X\";\n    } else if (fkeys.indexOf(\"matrix\") != -1) {\n        return \"matrix\";\n    } else {\n        var sparse_opts = [];\n        var dense_opts = [];\n\n        // Try to pick out sparse formats.\n        for (const key of fkeys) {\n            var current = f.get(key);\n            if (current instanceof hdf5.Group) {\n                var cur_keys = current.keys();\n                if (cur_keys.indexOf(\"data\") != -1 && cur_keys.indexOf(\"indices\") && cur_keys.indexOf(\"indptr\")) {\n                    sparse_opts.push(key);\n                }\n            } else if (current instanceof hdf5.Dataset && current.shape.length == 2) {\n                dense_opts.push(key);\n            }\n        }\n\n        if (sparse_opts.length) {\n            return sparse_opts[0];\n        } else if (dense_opts.length) {\n            return dense_opts[0];\n        } else {\n            throw \"could not automatically find a suitable 'path' inside the HDF5 file\";\n        }\n    }\n\n    return null;\n}\n\nfunction guessGenesFromH5AD(f) {\n    var fkeys = f.keys();\n\n    // Does it have a 'var' group?\n    if (fkeys.indexOf(\"var\") == -1) {\n        return null;\n    }\n\n    var vars = f.get(\"var\");\n    if (!(vars instanceof hdf5.Group)) {\n        return null;\n    }\n\n    var vkeys = vars.keys();\n    if (vkeys.indexOf(\"_index\") == -1) {\n        return null;\n    }\n\n    let index = vars.get(\"_index\");\n    if (!(index instanceof hdf5.Dataset)) {\n        return null;\n    }\n\n    let output = { \"_index\": index.value };\n\n    // Also include anything else that might be a gene symbol.\n    for (const key of vkeys) {\n        if (key == \"_index\") {\n            continue;\n        }\n\n        if (key.match(/name/i) || key.match(/symbol/i)) {\n            let current = vars.get(key);\n            if (current instanceof hdf5.Dataset) {\n                output[field] = current.value;\n            }\n        }\n    }\n\n    return output;\n}\n\nfunction guessGenesFrom10x(f) {\n    var fkeys = f.keys();\n\n    // Does it have a 'matrix' group with a \"features\" subgroup?\n    if (fkeys.indexOf(\"matrix\") == -1) {\n        return null;\n    }\n\n    var mat = f.get(\"matrix\");\n    if (!(mat instanceof hdf5.Group)) {\n        return null;\n    }\n\n    var mkeys = mat.keys();\n    if (mkeys.indexOf(\"features\") == -1) {\n        return null;\n    }\n\n    var feats = mat.get(\"features\");\n    if (!(feats instanceof hdf5.Group)) {\n        return null;\n    }\n\n    var featkeys = feats.keys();\n    if (featkeys.indexOf(\"id\") == -1) {\n        return null;\n    }\n\n    var featid = feats.get(\"id\");\n    if (!(featid instanceof hdf5.Dataset)) {\n        return null;\n    }\n\n    var output = { id: featid.value };\n\n    var name_index = featkeys.indexOf(\"name\");\n    if (name_index != -1) {\n        var featname = feats.get(\"name\");\n        if (featname instanceof hdf5.Dataset) {\n            output.name = featname.value;\n        }\n    }\n\n    return output;\n}\n\nfunction guessGenesFromHDF5(f) {\n    {\n        let output = guessGenesFromH5AD(f);\n        if (output !== null) {\n            return output;\n        }\n    }\n\n    {\n        let output = guessGenesFrom10x(f);\n        if (output !== null) {\n            return output;\n        }\n    }\n\n    return null;\n}\n\nfunction guessAnnotationsFromH5AD(f) {\n    var fkeys = f.keys();\n\n    if (fkeys.indexOf(\"obs\") == -1) {\n        return null;\n    }\n\n    var obs = f.get(\"obs\");\n    if (obs instanceof hdf5.Dataset) {\n        // this is the only place i found where it contains names\n        let colnames = obs.dtype?.compound?.members?.map(x => x.name);\n        let parsed = obs.value;\n\n        let annots = {}\n        colnames.forEach((x, i) => {\n            annots[x] = parsed.map(y => y[i]);\n        });\n\n        return annots;\n    }\n\n    return null;\n}\n\nfunction guessAnnotationsFromHDF5(f) {\n    {\n        let output = guessAnnotationsFromH5AD(f);\n        if (output !== null) {\n            return output;\n        }\n    }\n\n    return null;\n}\n\nfunction loadHDF5Raw(files) {\n    utils.freeCache(cache.matrix);\n\n    // In theory, we could support multiple HDF5 buffers.\n    var first_file = files[0];\n    var tmppath = \"rabbit-temp.h5\";\n    try {\n        hdf5.FS.writeFile(tmppath, new Uint8Array(first_file.buffer));\n        var f = new hdf5.File(tmppath, \"r\");\n        try {\n            var path = guessPath(f);\n            cache.matrix = scran.initializeSparseMatrixFromHDF5Buffer(f, path);\n            cache.genes = guessGenesFromHDF5(f);\n            cache.annotations = guessAnnotationsFromHDF5(f);\n        } finally {\n            f.close();\n        }\n    } finally {\n        hdf5.FS.unlink(tmppath);\n    }\n\n    if (cache.genes === null) {\n        cache.genes = dummyGenes(cache.matrix.numberOfRows());\n    }\n    permuteGenes(cache.genes);\n    return;\n}\n\nfunction loadHDF5(args) {\n    var reader = new FileReaderSync();\n\n    // First pass computes an abbreviated version to quickly check for changes.\n    // Second pass does the actual readArrayBuffer.\n    for (var it = 0; it < 2; it++) {\n        var formatted = { \"type\": \"HDF5\", \"files\": [] };\n\n        var bufferFun;\n        if (it == 0) {\n            bufferFun = (f) => f.size;\n        } else {\n            bufferFun = (f) => reader.readAsArrayBuffer(f);\n        }\n\n        for (const f of args.file) {\n            formatted.files.push({ \"type\": \"h5\", \"name\": f.name, \"buffer\": bufferFun(f) });\n        }\n\n        if (it == 0) {\n            if (!utils.changedParameters(abbreviated, formatted)) {\n                changed = false;\n                return;\n            } else {\n                abbreviated = formatted;\n                changed = true;\n            }\n        } else {\n            parameters = formatted;\n            loadHDF5Raw(formatted.files);\n            delete cache.reloaded;\n        }\n    }\n\n    return;\n}\n\n/** Public functions (standard) **/\nexport function compute(args) {\n    switch (args.format) {\n        case \"mtx\":\n            loadMatrixMarket(args.files);\n            break;\n        case \"hdf5\":\n        case \"tenx\":\n        case \"h5ad\":\n            loadHDF5(args.files);\n            break;\n        case \"kana\":\n            // do nothing, this is handled by unserialize.\n            break;\n        default:\n            throw \"unknown matrix file extension: '\" + args.format + \"'\";\n    }\n    return;\n}\n\nexport function results() {\n    var output = { \"dimensions\": fetchDimensions() }\n    if (\"reloaded\" in cache) {\n        output.genes = { ...cache.reloaded.genes };\n\n        if (cache.annotations) {\n            output.annotations = Object.keys(cache.reloaded.annotations);\n        }\n    } else {\n        output.genes = { ...cache.genes };\n        if (cache.annotations) {\n            output.annotations = Object.keys(cache.annotations);\n        }\n    }\n    return output;\n}\n\nexport function serialize() {\n    var contents = {};\n    if (\"reloaded\" in cache) {\n        contents.genes = { ...cache.reloaded.genes };\n        contents.num_cells = cache.reloaded.num_cells;\n        if (cache.reloaded.annotations) {\n            contents.annotations = cache.reloaded.annotations;\n        }\n    } else {\n        contents.genes = { ...cache.genes };\n        contents.num_cells = cache.matrix.numberOfColumns();\n        if (cache.annotations) {\n            contents.annotations = cache.annotations;\n        }\n    }\n\n    // Making a deep-ish clone of the parameters so that any fiddling with\n    // buffers during serialization does not compromise internal state.\n    var parameters2 = { ...parameters };\n    parameters2.files = parameters.files.map(x => { return { ...x }; });\n\n    return {\n        \"parameters\": parameters2,\n        \"contents\": contents\n    };\n}\n\nexport function unserialize(saved) {\n    parameters = saved.parameters;\n    cache.reloaded = saved.contents;\n    return;\n}\n\n/** Public functions (custom) **/\nexport function fetchCountMatrix() {\n    if (\"reloaded\" in cache) {\n        if (parameters.type == \"MatrixMarket\") {\n            loadMatrixMarketRaw(parameters.files);\n        } else if (parameters.type == \"HDF5\") {\n            loadHDF5Raw(parameters.files);\n        } else {\n            throw `unrecognized count matrix format, ${parameters.type}`;\n        }\n    }\n    return cache.matrix;\n}\n\nexport function fetchDimensions() {\n    if (\"reloaded\" in cache) {\n        return {\n            // This should contain at least one element,\n            // and all of them should have the same length,\n            // so indexing by the first element is safe.\n            \"num_genes\": Object.values(cache.reloaded.genes)[0].length,\n            \"num_cells\": cache.reloaded.num_cells\n        };\n    } else {\n        return {\n            \"num_genes\": cache.matrix.numberOfRows(),\n            \"num_cells\": cache.matrix.numberOfColumns()\n        };\n    }\n}\n\nexport function fetchGenes() {\n    if (\"reloaded\" in cache) {\n        return cache.reloaded.genes;\n    } else {\n        return cache.genes;\n    }\n}\n\nexport function fetchAnnotations(col) {\n    let annots, asize;\n    if (\"reloaded\" in cache) {\n        annots = cache.reloaded.annotations;\n        asize = cache.reloaded.matrix.numberOfColumns();\n    } else {\n        annots = cache.annotations;\n        asize = cache.matrix.numberOfColumns();\n    }\n\n    if (!(col in annots)) {\n        throw `column ${col} does not exist in col.tsv`;\n    }\n\n    let uvals = {};\n    let uTypedAray = new Uint8Array(asize);\n    annots[col].map((x, i) => {\n        if (!(x in uvals)) {\n            uvals[x] = Object.keys(uvals).length;\n        }\n\n        uTypedAray[i] = uvals[x];\n    });\n\n    return {\n        \"index\": Object.keys(uvals),\n        \"factor\": uTypedAray\n    }\n}\n","/* Derived from scran.js's blacklists.js.R. */\n\nexport var mito = {};\nmito.ensembl = new Set([\"ENSMUSG00000064336\",\"ENSMUSG00000064337\",\"ENSMUSG00000064338\",\"ENSMUSG00000064339\",\"ENSMUSG00000064340\",\"ENSMUSG00000064341\",\"ENSMUSG00000064342\",\"ENSMUSG00000064343\",\"ENSMUSG00000064344\",\"ENSMUSG00000064345\",\"ENSMUSG00000064346\",\"ENSMUSG00000064347\",\"ENSMUSG00000064348\",\"ENSMUSG00000064349\",\"ENSMUSG00000064350\",\"ENSMUSG00000064351\",\"ENSMUSG00000064352\",\"ENSMUSG00000064353\",\"ENSMUSG00000064354\",\"ENSMUSG00000064355\",\"ENSMUSG00000064356\",\"ENSMUSG00000064357\",\"ENSMUSG00000064358\",\"ENSMUSG00000064359\",\"ENSMUSG00000064360\",\"ENSMUSG00000064361\",\"ENSMUSG00000064363\",\"ENSMUSG00000064364\",\"ENSMUSG00000064365\",\"ENSMUSG00000064366\",\"ENSMUSG00000064367\",\"ENSMUSG00000064368\",\"ENSMUSG00000064369\",\"ENSMUSG00000064370\",\"ENSMUSG00000064371\",\"ENSMUSG00000064372\",\"ENSMUSG00000065947\",\"ENSG00000198695\",\"ENSG00000198712\",\"ENSG00000198727\",\"ENSG00000198763\",\"ENSG00000198786\",\"ENSG00000198804\",\"ENSG00000198840\",\"ENSG00000198886\",\"ENSG00000198888\",\"ENSG00000198899\",\"ENSG00000198938\",\"ENSG00000209082\",\"ENSG00000210049\",\"ENSG00000210077\",\"ENSG00000210082\",\"ENSG00000210100\",\"ENSG00000210107\",\"ENSG00000210112\",\"ENSG00000210117\",\"ENSG00000210127\",\"ENSG00000210135\",\"ENSG00000210140\",\"ENSG00000210144\",\"ENSG00000210151\",\"ENSG00000210154\",\"ENSG00000210156\",\"ENSG00000210164\",\"ENSG00000210174\",\"ENSG00000210176\",\"ENSG00000210184\",\"ENSG00000210191\",\"ENSG00000210194\",\"ENSG00000210195\",\"ENSG00000210196\",\"ENSG00000211459\",\"ENSG00000212907\",\"ENSG00000228253\"]);\nmito.symbol = new Set([\"mt-Tf\",\"mt-Rnr1\",\"mt-Tv\",\"mt-Rnr2\",\"mt-Tl1\",\"mt-Nd1\",\"mt-Ti\",\"mt-Tq\",\"mt-Tm\",\"mt-Nd2\",\"mt-Tw\",\"mt-Ta\",\"mt-Tn\",\"mt-Tc\",\"mt-Ty\",\"mt-Co1\",\"mt-Ts1\",\"mt-Td\",\"mt-Co2\",\"mt-Tk\",\"mt-Atp8\",\"mt-Atp6\",\"mt-Co3\",\"mt-Tg\",\"mt-Nd3\",\"mt-Tr\",\"mt-Nd4\",\"mt-Th\",\"mt-Ts2\",\"mt-Tl2\",\"mt-Nd5\",\"mt-Nd6\",\"mt-Te\",\"mt-Cytb\",\"mt-Tt\",\"mt-Tp\",\"mt-Nd4l\",\"MT-ND6\",\"MT-CO2\",\"MT-CYB\",\"MT-ND2\",\"MT-ND5\",\"MT-CO1\",\"MT-ND3\",\"MT-ND4\",\"MT-ND1\",\"MT-ATP6\",\"MT-CO3\",\"MT-TL1\",\"MT-TF\",\"MT-TV\",\"MT-RNR2\",\"MT-TI\",\"MT-TQ\",\"MT-TM\",\"MT-TW\",\"MT-TA\",\"MT-TN\",\"MT-TC\",\"MT-TY\",\"MT-TS1\",\"MT-TD\",\"MT-TK\",\"MT-TG\",\"MT-TR\",\"MT-TH\",\"MT-TS2\",\"MT-TL2\",\"MT-TE\",\"MT-TT\",\"MT-TP\",\"MT-RNR1\",\"MT-ND4L\",\"MT-ATP8\"]);\n","import * as scran from \"scran.js\"; \nimport * as utils from \"./_utils.js\";\nimport * as inputs from \"./_inputs.js\";\nimport { mito } from \"./mito.js\";\n\nvar cache = {};\nvar parameters = {};\n\nexport var changed = false;\n\nfunction rawCompute(args) {\n    utils.freeCache(cache.raw);\n    var mat = inputs.fetchCountMatrix();\n\n    // TODO: add more choices.\n    var nsubsets = 1;\n    var subsets = utils.allocateCachedArray(mat.numberOfRows() * nsubsets, \"Uint8Array\", cache);\n    subsets.fill(0);\n\n    var gene_info = inputs.fetchGenes();\n    var sub_arr = subsets.array();\n    for (const [key, val] of Object.entries(gene_info)) {\n        if (args.use_mito_default) {\n            val.forEach((x, i) => {\n                if (mito.symbol.has(x) || mito.ensembl.has(x)) {\n                    sub_arr[i] = 1;\n                }\n            });\n        } else {\n            var lower_mito = args.mito_prefix.toLowerCase();\n            val.forEach((x, i) => {\n                if(x.toLowerCase().startsWith(lower_mito)) {\n                    sub_arr[i] = 1;\n                }\n            });\n        }\n    }\n\n    var mat = inputs.fetchCountMatrix();\n\n    cache.raw = scran.computePerCellQCMetrics(mat, subsets);\n    delete cache.reloaded;\n    return;\n}\n\nfunction fetchResults() {\n    var data = {};\n    if (\"reloaded\" in cache) {\n        var qc_output = cache.reloaded;\n        data.sums = qc_output.sums.slice();\n        data.detected = qc_output.detected.slice();\n        data.proportion = qc_output.proportion.slice();\n    } else {\n        var qc_output = cache.raw;\n        data.sums = qc_output.sums();\n        data.detected = qc_output.detected();\n        data.proportion = qc_output.subsetProportions(0);\n    }\n    return data;\n}\n\nexport function compute(args) {\n    if (!inputs.changed && !utils.changedParameters(parameters, args)) {\n        changed = false;\n    } else {\n        rawCompute(args);\n        parameters = args;\n        changed = true;\n    }\n    return;\n}\n\nexport function results() {\n    var data = fetchResults();\n\n    var ranges = {};\n    ranges.sums = utils.computeRange(data.sums);\n    ranges.detected = utils.computeRange(data.detected);\n    ranges.proportion = utils.computeRange(data.proportion);\n\n    return { \n        \"data\": data, \n        \"ranges\": ranges \n    };\n}\n\nexport function serialize() {\n    return {\n      \"parameters\": parameters,\n      \"contents\": fetchResults()\n    };\n}\n\nexport function unserialize(saved) {\n    /* TODO: reconstutite a fully-formed QCMetrics object so that\n     * fetchQCMetrics() doesn't have to recompute it.\n     */\n    parameters = saved.parameters;\n    cache.reloaded = saved.contents;\n    return;\n}\n\nexport function fetchQCMetrics() {\n    if (\"reloaded\" in cache) {\n        rawCompute();\n    }\n    return cache.raw;\n}\n\nexport function fetchSums({ unsafe = true } = {}) {\n    if (\"reloaded\" in cache) {\n        return cache.reloaded.sums;\n    } else {\n        // Unsafe, because we're returning a raw view into the Wasm heap,\n        // which might be invalidated upon further allocations.\n        return cache.raw.sums({ copy: !unsafe });\n    }\n}\n","import * as scran from \"scran.js\"; \nimport * as utils from \"./_utils.js\";\nimport * as metrics from \"./_qc_metrics.js\";\n\nvar cache = {};\nvar parameters = {};\n\nexport var changed = false;\n\nexport function compute(args) {\n    if (!metrics.changed && !utils.changedParameters(parameters, args)) {\n        changed = false;\n    } else {\n        utils.freeCache(cache.raw);\n        var stats = metrics.fetchQCMetrics();\n\n        cache.raw = scran.computePerCellQCFilters(stats, { numberOfMADs: args.nmads });\n\n        utils.freeReloaded(cache);\n        changed = true;\n        parameters = args;\n    }\n    return;\n}\n\nexport function results() {\n    let data;\n    if (\"reloaded\" in cache) {\n        data = {\n            \"sums\": cache.reloaded.sums,\n            \"detected\": cache.reloaded.detected,\n            \"proportion\": cache.reloaded.proportion\n        };\n    } else {\n        var obj = cache.raw;\n        data = {\n            \"sums\": obj.thresholdsSums()[0],\n            \"detected\": obj.thresholdsDetected()[0],\n            \"proportion\": obj.thresholdsSubsetProportions(0)[0] // TODO: generalize...\n        };\n    }\n    return data;\n}\n\nexport function serialize() {\n    var contents = results();\n    contents.discards = fetchDiscards();\n    return {\n        \"parameters\": parameters,\n        \"contents\": contents\n    };\n}\n\nexport function unserialize(saved) {\n    parameters = saved.parameters;\n\n    utils.freeReloaded(cache);\n    cache.reloaded = saved.contents;\n\n    var tmp = new scran.Uint8WasmArray(cache.reloaded.discards.length);\n    tmp.set(cache.reloaded.discards);\n    cache.reloaded.discards = tmp;\n    \n    return;\n}\n\nexport function fetchDiscardsAsWasmArray() {\n    if (\"reloaded\" in cache) {\n        return cache.reloaded.discards;        \n    } else {\n        var tmp = cache.raw.discardOverall({ copy: false });\n        return new scran.Uint8WasmArray(tmp.length, tmp.byteOffset);\n    }\n}\n\nexport function fetchDiscards({ unsafe = false } = {}) {\n    var out;\n    if (\"reloaded\" in cache) {\n        out = cache.reloaded.discards.array();\n    } else {\n        out = cache.raw.discardOverall();\n    }\n\n    if (unsafe) {\n        // Unsafe, because we're returning a raw view into the Wasm heap,\n        // which might be invalidated upon further allocations.\n        return out;\n    } else {\n        return out.slice();\n    }\n}\n","import * as scran from \"scran.js\"; \nimport * as utils from \"./_utils.js\";\nimport * as inputs from \"./_inputs.js\";\nimport * as thresholds from \"./_qc_thresholds.js\";\n\nvar cache = {};\nvar parameters = {};\n\nexport var changed = false;\n\nfunction rawCompute() {\n    utils.freeCache(cache.matrix);\n    var mat = inputs.fetchCountMatrix();\n\n    var disc = thresholds.fetchDiscardsAsWasmArray();\n    cache.matrix = scran.filterCells(mat, disc);\n\n    delete cache.reloaded;\n    return;\n}\n\nexport function compute(args) {\n    if (!inputs.changed && !thresholds.changed && !utils.changedParameters(parameters, args)) {\n        changed = false;\n    } else {\n        rawCompute();\n        parameters = args;\n        changed = true;\n    }\n    return;\n}\n   \nexport function results() {\n    return {\n      \"retained\": fetchRetained()\n    };\n}\n\nexport function serialize() {\n    return {\n        \"parameters\": parameters,\n        \"contents\": results()\n    };\n}\n\nexport function unserialize(saved) {\n    parameters = saved.parameters;\n    cache.reloaded = saved.contents;\n\n    // Precomputing this for easier retrieval later.\n    var discards = thresholds.fetchDiscards({ unsafe: true });\n    var retained = 0;\n    for (const i of discards) {\n        if (i == 0) {\n            retained++;\n        }\n    }\n    cache.reloaded.retained = retained;\n    return;\n}\n\nexport function fetchFilteredMatrix() {\n    if (\"reloaded\" in cache) {\n        rawCompute();\n    }\n    return cache.matrix;    \n}\n\nexport function fetchRetained() {\n    if (\"reloaded\" in cache) {\n        return cache.reloaded.retained;\n    } else {\n        return cache.matrix.numberOfColumns();\n    }\n}\n","import * as scran from \"scran.js\"; \nimport * as utils from \"./_utils.js\";\nimport * as thresholds from \"./_qc_thresholds.js\";\nimport * as filter from \"./_qc_filter.js\";\nimport * as metrics from \"./_qc_metrics.js\";\n\nvar cache = {};\nvar parameters = {};\n\nexport var changed = false;\n\nfunction rawCompute() {\n    var mat = filter.fetchFilteredMatrix();\n    var buffer = utils.allocateCachedArray(mat.numberOfColumns(), \"Float64Array\", cache);\n\n    // Better not have any more allocations in between now and filling of size_factors!\n    var sums = metrics.fetchSums({ unsafe: true });\n    var discards = thresholds.fetchDiscards({ unsafe: true });\n\n    // Reusing the totals computed earlier.\n    var size_factors = buffer.array();\n    var j = 0;\n    for (var i = 0; i < discards.length; ++i) {\n        if (!discards[i]) {\n            size_factors[j] = sums[i];\n            j++;\n        }\n    }\n\n    if (j != mat.numberOfColumns()) {\n        throw \"normalization and filtering are not in sync\";\n    }\n\n    utils.freeCache(cache.matrix);\n    cache.matrix = scran.logNormCounts(mat, { sizeFactors: buffer });\n\n    delete cache.reloaded;\n    return;\n}\n\nexport function compute(args) {\n    if (!metrics.changed && !filter.changed && !utils.changedParameters(parameters, args)) {\n        changed = false;\n    } else {\n        rawCompute();\n        parameters = args;\n        changed = true;\n    }\n    return;\n}\n\nexport function results() {\n    return {};\n}\n\nexport function serialize() {\n    return {\n        \"parameters\": parameters,\n        \"contents\": results()\n    };\n}\n\nexport function unserialize(saved) {\n    parameters = saved.parameters;\n    cache.reloaded = saved.contents;\n    return;\n}\n\nexport function fetchNormalizedMatrix() {\n    if (\"reloaded\" in cache) {\n        rawCompute();\n    }\n    return cache.matrix;\n}\n\nexport function fetchExpression(index) {\n    var mat = fetchNormalizedMatrix();\n    var buffer = utils.allocateCachedArray(mat.numberOfColumns(), \"Float64Array\", cache); // re-using the buffer.\n    mat.row(index, { buffer: buffer });\n    return buffer.slice();\n}\n","import * as scran from \"scran.js\"; \nimport * as utils from \"./_utils.js\";\nimport * as normalization from \"./_normalization.js\";\n  \nvar cache = {};\nvar parameters = {};\n\nexport var changed = false;\n\nfunction spawnStats() {\n    var model_output = cache.raw;\n    return {\n        \"means\": model_output.means(),\n        \"vars\": model_output.variances(),\n        \"fitted\": model_output.fitted(),\n        \"resids\": model_output.residuals()\n    };\n}\n\nexport function compute(args) {\n    if (!normalization.changed && !utils.changedParameters(parameters, args)) {\n        changed = false;\n    } else {\n        var mat = normalization.fetchNormalizedMatrix();\n        cache.raw = scran.modelGeneVar(mat, { span: args.span });\n\n        cache.sorted_residuals = cache.raw.residuals().slice(); // a separate copy.\n        cache.sorted_residuals.sort();\n\n        parameters = args;\n        delete cache.reloaded;\n        changed = true;\n    }\n    return;\n}\n\nexport function results() {\n    if (\"reloaded\" in cache) {\n        return {\n            \"means\": cache.reloaded.means.slice(),\n            \"vars\": cache.reloaded.vars.slice(),\n            \"fitted\": cache.reloaded.fitted.slice(),\n            \"resids\": cache.reloaded.resids.slice()\n        };\n    } else {\n        return spawnStats();\n    }\n}\n\nexport function serialize() {\n    return { \n        \"parameters\": parameters,\n        \"contents\": results()\n    };\n}\n\nexport function unserialize(saved) {\n    parameters = saved.parameters;\n    cache.reloaded = saved.contents;\n    cache.sorted_residuals = cache.reloaded.resids.slice();\n    cache.sorted_residuals.sort();\n    return;\n}\n\nexport function fetchSortedResiduals() {\n    return cache.sorted_residuals;\n}\n\nexport function fetchResiduals({ unsafe = false } = {}) {\n    if (\"reloaded\" in cache) {\n        return cache.reloaded.resids;\n    } else {\n        return cache.raw.residuals({ copy: !unsafe });\n    }\n}\n","import * as scran from \"scran.js\";\nimport * as utils from \"./_utils.js\";\nimport * as normalization from \"./_normalization.js\";\nimport * as variance from \"./_model_gene_var.js\";\n\nvar cache = {};\nvar parameters = {};\n\nexport var changed = false;\n\nfunction fetchPCsAsWasmArray() {\n    if (\"reloaded\" in cache) {\n        return cache.reloaded.pcs;\n    } else {\n        let tmp = cache.raw.principalComponents({ copy: false });\n        return new scran.Float64WasmArray(tmp.length, tmp.byteOffset);\n    }\n}\n\nexport function compute(args) {\n    if (!normalization.changed && !variance.changed && !utils.changedParameters(parameters, args)) {\n        changed = false;\n    } else {\n        // Choosing the highly variable genes.\n        var sorted_resids = variance.fetchSortedResiduals();\n        var threshold_at = sorted_resids[sorted_resids.length - args.num_hvgs];\n\n        var mat = normalization.fetchNormalizedMatrix();\n        var sub = utils.allocateCachedArray(mat.numberOfRows(), \"Uint8Array\", cache);\n        var unsorted_resids = variance.fetchResiduals({ unsafe: true });\n        sub.array().forEach((element, index, array) => {\n            array[index] = unsorted_resids[index] >= threshold_at;\n        });\n\n        // Actually performing the PCA.\n        utils.freeCache(cache.raw);\n        cache.raw = scran.runPCA(mat, { features: sub, numberOfPCs: args.num_pcs });\n\n        utils.freeReloaded(cache);\n        changed = true;\n        parameters = args;\n    }\n    return;\n}\n\nexport function results() {\n    var var_exp;\n\n    if (\"reloaded\" in cache) {\n        var_exp = cache.reloaded.var_exp.slice();\n    } else {\n        var pca_output = cache.raw;\n        var_exp = pca_output.varianceExplained();\n        var total_var = pca_output.totalVariance();\n        var_exp.forEach((x, i) => {\n            var_exp[i] = x/total_var;\n        });\n    }\n\n    return { \"var_exp\": var_exp };\n}\n\nexport function serialize() {\n    var to_save = results();\n    to_save.pcs = fetchPCsAsWasmArray().slice();\n    return {\n      \"parameters\": parameters,\n      \"contents\": to_save\n    };\n}\n \nexport function unserialize(saved) {\n    parameters = saved.parameters;\n\n    utils.freeReloaded(cache);\n    cache.reloaded = saved.contents;\n\n    var tmp = new scran.Float64WasmArray(cache.reloaded.pcs.length);\n    tmp.set(cache.reloaded.pcs);\n    cache.reloaded.pcs = tmp;\n    return;\n}\n\nexport function fetchPCs() {\n    var pcs = fetchPCsAsWasmArray();\n    return {\n        \"pcs\": pcs,\n        \"num_pcs\": parameters.num_pcs,\n        \"num_obs\": pcs.length / parameters.num_pcs\n    };\n}\n","import * as scran from \"scran.js\";\nimport * as utils from \"./_utils.js\";\nimport * as pca from \"./_pca.js\";\n\nvar cache = {};\nvar parameters = {};\n\nexport var changed = false;\n\nexport function rawCompute(args) {\n    utils.freeCache(cache.raw);\n    var pcs = pca.fetchPCs();\n    cache.raw = scran.buildNeighborSearchIndex(pcs.pcs, { numberOfDims: pcs.num_pcs, numberOfCells: pcs.num_obs });\n    delete cache.reloaded;\n    return;\n}\n\nexport function compute(args) {\n    if (!pca.changed && !utils.changedParameters(parameters, args)) {\n        changed = false;\n    } else {\n        rawCompute(args);\n        parameters = args;\n        changed = true;\n    }\n    return;\n}\n\nexport function results() {\n    return {};\n}\n\nexport function serialize() {\n    return {\n      \"parameters\": parameters,\n      \"contents\": results()\n    };\n}\n\nexport function unserialize(saved) {\n    parameters = saved.parameters;\n    cache.reloaded = saved.contents;\n    return;\n}\n\nexport function fetchIndex() {\n    if (\"reloaded\" in cache) {\n        rawCompute(parameters);\n    }\n    return cache.raw;\n}\n","import * as scran from \"scran.js\";\nimport * as utils from \"./_utils.js\";\nimport * as index from \"./_neighbor_index.js\";\n\nvar cache = {};\nvar parameters = {};\n\nexport var changed = false;\n\nexport function rawCompute(args) {\n    utils.freeCache(cache.raw);\n    var nn_index = index.fetchIndex();\n    cache.raw = scran.findNearestNeighbors(nn_index, args.k);\n    delete cache.reloaded;\n    return;\n}\n\nexport function compute(args) {\n    if (!index.changed && !utils.changedParameters(parameters, args)) {\n        changed = false;\n    } else {\n        rawCompute(args);\n        parameters = args;\n        changed = true;\n    }\n    return;\n}\n\nexport function results() {\n    return {};\n}\n\nexport function serialize() {\n    return {\n        \"parameters\": parameters,\n        \"contents\": results()\n    };\n};\n\nexport function unserialize(saved) {\n    parameters = saved.parameters;\n    cache.reloaded = saved.contents;\n    return;\n}\n\nexport function fetchNeighbors() {\n    if (\"reloaded\" in cache) {\n        rawCompute(parameters);\n    }\n    return cache.raw;\n}\n","import * as scran from \"scran.js\";\nimport * as neighbors from \"./_snn_neighbors.js\";\nimport * as utils from \"./_utils.js\";\n\nvar cache = {};\nvar parameters = {};\n\nexport var changed = false;\n\nfunction rawCompute(args) {\n    utils.freeCache(cache.raw);\n    var res = neighbors.fetchNeighbors();\n    cache.raw = scran.buildSNNGraph(res, { scheme: args.scheme });\n    delete cache.reloaded;\n    return;\n}\n\nexport function compute(args) {\n    if (!neighbors.changed && !utils.changedParameters(parameters, args)) {\n        changed = false;\n    } else {\n        rawCompute(args);\n        parameters = args;\n        changed = true;\n    }\n    return;\n}\n\nexport function results() {\n    return {};\n}\n\nexport function serialize() {\n    return {\n        \"parameters\": parameters,\n        \"contents\": results()\n    };\n}\n\nexport function unserialize(saved) {\n    parameters = saved.parameters;\n    cache.reloaded = saved.contents;\n    return;\n}\n\nexport function fetchGraph() {\n    if (\"reloaded\" in cache) {\n        rawCompute(parameters);\n    }\n    return cache.raw;\n}\n","import * as scran from \"scran.js\"; \nimport * as utils from \"./_utils.js\";\nimport * as graph from \"./_snn_graph.js\";\n\nvar cache = {};\nvar parameters = {};\n\nexport var changed = false;\n\nexport function fetchClustersAsWasmArray() {\n    if (\"reloaded\" in cache) {\n        return cache.reloaded.clusters;\n    } else {\n        var tmp = cache.raw.membership({ copy: false });\n        return new scran.Int32WasmArray(tmp.length, tmp.byteOffset);\n    }\n}\n\nexport function compute(args) {\n    if (!graph.changed && !utils.changedParameters(parameters, args)) {\n        changed = false;\n    } else {\n        utils.freeCache(cache.raw);\n        var g = graph.fetchGraph();\n        cache.raw = scran.clusterSNNGraph(g, { resolution: args.resolution });\n\n        parameters = args;\n        changed = true;\n        utils.freeReloaded(cache);\n    }\n    return;\n}\n\nexport function results() {\n    var clusters = fetchClustersAsWasmArray();\n    return { \"clusters\": clusters.slice() };\n}\n\nexport function serialize() {\n    return {\n      \"parameters\": parameters,\n      \"contents\": results()\n    };\n}\n\nexport function unserialize(saved) {\n    parameters = saved.parameters;\n\n    utils.freeReloaded(cache);\n    cache.reloaded = saved.contents;\n\n    var out = new scran.Int32WasmArray(cache.reloaded.clusters.length);\n    out.set(cache.reloaded.clusters);\n    cache.reloaded.clusters = out;\n\n    return;\n}\n","import * as scran from \"scran.js\";\nimport * as utils from \"./_utils.js\";\nimport * as cluster from \"./_snn_cluster.js\";\n\nvar cache = {};\nvar parameters = {};\n\nexport var changed = false;\n\n/** Standard functions **/\nexport function compute(args) {\n    changed = true;\n    \n    if (!utils.changedParameters(parameters, args)) {\n        if (args.method == \"snn_graph\" && !cluster.changed) {\n            changed = false;\n        }\n    }\n\n    if (changed) {\n        delete cache.reloaded;\n        parameters = args;\n        changed = true;\n    }\n    \n    return;\n}\n\nexport function results() {\n    return {};\n}\n\nexport function serialize() {\n    return {\n        \"parameters\": parameters,\n        \"contents\": results()\n    };\n}\n\nexport function unserialize(saved) {\n    parameters = saved.parameters;\n    cache.reloaded = saved.contents;\n    return;\n}\n\n/** Non-standard functions **/\nexport function fetchClustersAsWasmArray() {\n//    if (parameters.method == \"snn_graph\") {\n    return cluster.fetchClustersAsWasmArray(); // really the only option right now.\n//  }\n}\n","import * as scran from \"scran.js\";\nimport * as index from \"./_neighbor_index.js\";\nimport * as utils from \"./_utils.js\";\n\nexport function computeNeighbors(k) {\n    var nn_index = index.fetchIndex();\n\n    var output = { \"num_obs\": nn_index.numberOfCells() };\n    var results = null, rbuf = null, ibuf = null, dbuf = null;\n    try {\n        results = scran.findNearestNeighbors(nn_index, k);\n\n        rbuf = new scran.Int32WasmArray(results.numberOfCells());\n        ibuf = new scran.Int32WasmArray(results.size());\n        dbuf = new scran.Float64WasmArray(results.size());\n\n        results.serialize({ runs: rbuf, indices: ibuf, distances: dbuf });\n        output[\"size\"] = results.size();\n        output[\"runs\"] = rbuf.array().slice();\n        output[\"indices\"] = ibuf.array().slice();\n        output[\"distances\"] = dbuf.array().slice();\n\n    } finally {\n        if (results !== null) {\n            results.free();\n        }\n        if (rbuf !== null) {\n            rbuf.free();\n        }\n        if (ibuf !== null) {\n            ibuf.free();\n        }\n        if (dbuf !== null) {\n            dbuf.free();\n        }\n    }\n\n    return output;\n}\n\nexport function sendTask(worker, payload, cache, transferrable = []) {\n    var i = cache.counter;\n    var p = new Promise((resolve, reject) => {\n        cache.promises[i] = { \"resolve\": resolve, \"reject\": reject };\n    });\n    cache.counter++;\n    payload.id = i;\n    worker.postMessage(payload, transferrable);\n    return p;\n}\n\nexport function initializeWorker(worker, cache) {\n    worker.onmessage = function (msg) {\n        var type = msg.data.type;\n        if (type.endsWith(\"_iter\")) {\n            postMessage({\n                \"type\": type,\n                \"resp\": {\n                    \"x\": msg.data.x,\n                    \"y\": msg.data.y,\n                    \"iteration\": msg.data.iteration\n                },\n            }, [msg.data.x.buffer, msg.data.y.buffer]);\n            return;\n        }\n  \n        var id = msg.data.id;\n        var fun = cache.promises[id];\n        if (type == \"error\") {\n            fun.reject(msg.data.error);\n        } else {\n            fun.resolve(msg.data.data);\n        }\n        delete cache.promises[id];\n    };\n    return sendTask(worker, { \"cmd\": \"INIT\" }, cache);\n}\n\nexport function runWithNeighbors(worker, args, nn_out, cache) {\n    var run_msg = {\n        \"cmd\": \"RUN\",\n        \"params\": args \n    };\n\n    var transferrable = [];\n    if (nn_out !== null) {\n        run_msg.neighbors = nn_out;\n        utils.extractBuffers(nn_out, transferrable);\n    }\n\n    return sendTask(worker, run_msg, cache, transferrable);\n}\n\nexport function retrieveCoordinates(worker, cache) {\n    if (\"reloaded\" in cache) {\n        // Buffers are transferred to the main thread, so we need to make sure we\n        // clone it so that we don't lose our master copy.\n        var copy = { ...cache.reloaded };\n        copy.x = copy.x.slice();\n        copy.y = copy.y.slice();\n        return new Promise(resolve => resolve(copy));\n    } else {\n        return cache.run.then(x => sendTask(worker, { \"cmd\": \"FETCH\" }, cache));\n    }\n}\n","import * as scran from \"scran.js\";\nimport * as vizutils from \"./_utils_viz_parent.js\";\nimport * as index from \"./_neighbor_index.js\";\nimport * as utils from \"./_utils.js\";\n\nvar cache = { \"counter\": 0, \"promises\": {} };\nvar parameters = {};\nvar worker = null;\n\nexport function initialize() {\n    worker = new Worker(new URL(\"./tsne.worker.js\", import.meta.url), { type: \"module\" });\n    return vizutils.initializeWorker(worker, cache);\n}\n\nexport var changed = false;\n\nfunction core(args, reneighbor) {\n    var nn_out = null;\n    if (reneighbor) {\n        var k = scran.perplexityToNeighbors(args.perplexity);\n        nn_out = vizutils.computeNeighbors(k);\n    }\n\n    // This returns a promise but the message itself is sent synchronously,\n    // which is important to ensure that the t-SNE runs in its worker in\n    // parallel with other analysis steps. Do NOT put the runWithNeighbors\n    // call in a .then() as this may defer the message sending until \n    // the current thread is completely done processing.\n    cache.run = vizutils.runWithNeighbors(worker, args, nn_out, cache);\n    return;\n}\n\nexport function compute(args) {\n    if (!index.changed && !utils.changedParameters(parameters, args)) {\n        changed = false;\n        return;\n    }\n\n    var reneighbor = index.changed || utils.changedParameters(parameters.perplexity, args.perplexity);\n    core(args, reneighbor);\n\n    parameters = args;\n    delete cache.reloaded;\n    changed = true;\n}\n\n\nexport function results() {\n    return vizutils.retrieveCoordinates(worker, cache);\n}\n\nexport async function serialize() {\n    var contents = await vizutils.retrieveCoordinates(worker, cache);\n    return {\n        \"parameters\": parameters,\n        \"contents\": contents\n    };\n}\n\nexport function unserialize(saved) {\n    parameters = saved.parameters;\n    cache.reloaded = saved.contents;\n    return;\n}\n\nexport function animate() {\n    if (\"reloaded\" in cache) {\n        var param_copy = { ...parameters };\n        param_copy.animate = true;\n        core(param_copy, true);\n        delete cache.reloaded;\n\n        // Mimicking the response from the re-run.\n        return cache.run\n            .then(contents => {\n                return {\n                    \"type\": \"tsne_rerun\",\n                    \"data\": { \"status\": \"SUCCESS\" }\n                };\n            });\n    } else {\n        return vizutils.sendTask(worker, { \"cmd\": \"RERUN\" }, cache);\n    }\n}\n","import * as vizutils from \"./_utils_viz_parent.js\";\nimport * as index from \"./_neighbor_index.js\";\nimport * as utils from \"./_utils.js\";\n\nvar cache = { \"counter\": 0, \"promises\": {} };\nvar parameters = {};\nvar worker = null;\n\nexport function initialize() {\n    worker = new Worker(new URL(\"./umap.worker.js\", import.meta.url), { type: \"module\" });\n    cache.initialized = vizutils.initializeWorker(worker, cache);\n}\n\nexport var changed = false;\n\nfunction core(args, reneighbor) {\n    var nn_out = null;\n    if (reneighbor) {\n        nn_out = vizutils.computeNeighbors(args.num_neighbors);\n    }\n\n    // This returns a promise but the message itself is sent synchronously,\n    // which is important to ensure that the UMAP runs in its worker in\n    // parallel with other analysis steps. Do NOT put the runWithNeighbors\n    // call in a .then() as this may defer the message sending until \n    // the current thread is completely done processing.\n    cache.run = vizutils.runWithNeighbors(worker, args, nn_out, cache);\n    return;\n}\n\nexport function compute(args) {\n    if (!index.changed && !utils.changedParameters(parameters, args)) {\n        changed = false;\n        return;\n    }\n\n    var reneighbor = index.changed || utils.changedParameters(parameters.num_neighbors, args.num_neighbors);\n    core(args, reneighbor);\n\n    parameters = args;\n    delete cache.reloaded;\n    changed = true;\n}\n\nexport function results() {\n    return vizutils.retrieveCoordinates(worker, cache);\n}\n\nexport async function serialize() {\n    var contents = await vizutils.retrieveCoordinates(worker, cache);\n    return {\n        \"parameters\": parameters,\n        \"contents\": contents\n    };\n}\n\nexport function unserialize(saved) {\n    parameters = saved.parameters;\n    cache.reloaded = saved.contents;\n    return;\n}\n\nexport function animate() {\n    if (\"reloaded\" in cache) {\n        var param_copy = { ...parameters };\n        param_copy.animate = true;\n        core(param_copy, true);\n        delete cache.reloaded;\n  \n        // Mimicking the response from the re-run.\n        return cache.run\n            .then(contents => { \n                return {\n                    \"type\": \"umap_rerun\",\n                    \"data\": { \"status\": \"SUCCESS\" }\n                };\n            });\n    } else {\n        return vizutils.sendTask(worker, { \"cmd\": \"RERUN\" }, cache);\n    }\n}\n","export function serializeGroupStats(obj, group) {\n    return {\n        \"means\": obj.means(group),\n        \"detected\": obj.detected(group),\n        \"lfc\": {\n            \"min\": obj.lfc(group, { summary: 0 }),\n            \"mean\": obj.lfc(group, { summary: 1 }),\n            \"min-rank\": obj.lfc(group, { summary: 4 })\n        },\n        \"delta_detected\": {\n            \"min\": obj.deltaDetected(group, { summary: 0 }),\n            \"mean\": obj.deltaDetected(group, { summary: 1 }),\n            \"min-rank\": obj.deltaDetected(group, { summary: 4 })\n        },\n        \"cohen\": {\n            \"min\": obj.cohen(group, { summary: 0 }),\n            \"mean\": obj.cohen(group, { summary: 1 }),\n            \"min-rank\": obj.cohen(group, { summary: 4 })\n        },\n        \"auc\": {\n            \"min\": obj.auc(group, { summary: 0 }),\n            \"mean\": obj.auc(group, { summary: 1 }),\n            \"min-rank\": obj.auc(group, { summary: 4 })\n        }\n    };\n}\n\n/*\n * Helper function to retrieve marker statistics for plotting.\n * This is used both for cluster-specific markers as well as the\n * DE genes that are computed for a custom selection vs the rest.\n */\nexport function fetchGroupResults(results, reloaded, rank_type, group) {\n    if (!rank_type || rank_type === undefined) {\n        rank_type = \"cohen-min-rank\";\n    }\n    var use_reloaded = (reloaded !== undefined);\n\n    var ordering;\n    {\n        // Choosing the ranking statistic. Do NOT do any Wasm allocations\n        // until 'ranking' is fully consumed!\n        let ranking;\n        let increasing = false;\n      \n        if (use_reloaded) {\n            let summary = \"mean\";\n            if (rank_type.match(/-min$/)) {\n                summary = \"min\";\n            } else if (rank_type.match(/-min-rank$/)) {\n                increasing = true;\n                summary = \"min-rank\";\n            }\n      \n            let effect;\n            if (rank_type.match(/^cohen-/)) {\n                effect = \"cohen\";\n            } else if (rank_type.match(/^auc-/)) {\n                effect = \"auc\";\n            } else if (rank_type.match(/^lfc-/)) {\n                effect = \"lfc\";\n            } else if (rank_type.match(/^delta-d-/)) {\n                effect = \"delta_detected\";\n            } else {\n                throw \"unknown rank type '\" + rank_type + \"'\";\n            }\n      \n            ranking = reloaded[group][effect][summary];\n        } else {\n            let index = 1;\n            if (rank_type.match(/-min$/)) {\n                index = 0;\n            } else if (rank_type.match(/-min-rank$/)) {\n                increasing = true;\n                index = 4;\n            }\n\n            if (rank_type.match(/^cohen-/)) {\n                ranking = results.cohen(group, { summary: index, copy: false });\n            } else if (rank_type.match(/^auc-/)) {\n                ranking = results.auc(group, { summary: index, copy: false });\n            } else if (rank_type.match(/^lfc-/)) {\n                ranking = results.lfc(group, { summary: index, copy: false });\n            } else if (rank_type.match(/^delta-d-/)) {\n                ranking = results.deltaDetected(group, { summary: index, copy: false });\n            } else {\n                throw \"unknown rank type '\" + rank_type + \"'\";\n            }\n        }\n      \n        // Computing the ordering based on the ranking statistic.\n        ordering = new Int32Array(ranking.length);\n        for (var i = 0; i < ordering.length; i++) {\n            ordering[i] = i;\n        }\n        if (increasing) {\n            ordering.sort((f, s) => (ranking[f] - ranking[s]));\n        } else {\n            ordering.sort((f, s) => (ranking[s] - ranking[f]));\n        }\n    }\n  \n    // Apply that ordering to each statistic of interest.\n    var reorder = function(stats) {\n        var thing = new Float64Array(stats.length);\n        for (var i = 0; i < ordering.length; i++) {\n            thing[i] = stats[ordering[i]];\n        }\n        return thing;\n    };\n  \n    var stat_detected, stat_mean, stat_lfc, stat_delta_d;\n    if (use_reloaded) {\n        var current = reloaded[group];\n        stat_mean = reorder(current.means);\n        stat_detected = reorder(current.detected);\n        stat_lfc = reorder(current.lfc[\"mean\"]);\n        stat_delta_d = reorder(current.delta_detected[\"mean\"]);\n    } else {\n        stat_detected = reorder(results.detected(group, { copy: false }));\n        stat_mean = reorder(results.means(group, { copy: false }));\n        stat_lfc = reorder(results.lfc(group, { summary: 1, copy: false }));\n        stat_delta_d = reorder(results.deltaDetected(group, { summary: 1, copy: false }));\n    }\n  \n    return {\n        \"ordering\": ordering,\n        \"means\": stat_mean,\n        \"detected\": stat_detected,\n        \"lfc\": stat_lfc,\n        \"delta_detected\": stat_delta_d\n    };\n}\n","import * as scran from \"scran.js\"; \nimport * as utils from \"./_utils.js\";\nimport * as normalization from \"./_normalization.js\";\nimport * as choice from \"./_choose_clustering.js\";\nimport * as markers from \"./_utils_markers.js\";\n\nvar cache = {};\nvar parameters = {};\n\nexport var changed = false;\n\nexport function compute(args) {\n    if (!normalization.changed && !choice.changed && !utils.changedParameters(parameters, args)) {\n        changed = false;\n    } else {\n        utils.freeCache(cache.raw);\n        var mat = normalization.fetchNormalizedMatrix();\n        var clusters = choice.fetchClustersAsWasmArray();\n\n        cache.raw = scran.scoreMarkers(mat, clusters);\n\n        parameters = args;\n        delete cache.reloaded;\n        changed = true;\n    }\n    return;\n}\n\nexport function results() {\n    return {};\n}\n\nexport function serialize() {\n    var contents;\n    if (\"reloaded\" in cache) {\n        contents = cache.reloaded;\n    } else {\n        var contents = [];\n        var num = cache.raw.numberOfGroups();\n        for (var i = 0; i < num; i++) {\n            contents.push(markers.serializeGroupStats(cache.raw, i));\n        }\n    }\n    return {\n        \"parameters\": parameters,\n        \"contents\": contents\n    };\n}\n\nexport function unserialize(saved) {\n    parameters = saved.parameters;\n    cache.reloaded = saved.contents;\n    return;\n}\n\nexport function fetchGroupResults(rank_type, group) {\n    return markers.fetchGroupResults(cache.raw, cache.reloaded, rank_type, group); \n}\n","import * as scran from \"scran.js\";\nimport * as utils from \"./_utils.js\";\nimport * as filter from \"./_qc_filter.js\";\nimport * as normalization from \"./_normalization.js\";\nimport * as markers from \"./_utils_markers.js\";\n\nvar cache = { \"results\": {} };\nvar parameters = { \"selections\": {} };\n\nexport var changed = false;\n\nexport function compute(args) {\n    /* If the QC filter was re-run, all of the selections are invalidated as\n     * the identity of the indices may have changed.\n     */\n    if (filter.changed) {\n        parameters.selections = {};\n        for (const [key, val] of Object.entries(cache.results)) {\n            utils.freeCache(val.raw);                    \n        }\n        cache.results = {};\n    }\n\n    /*\n     * Technically we would need to re-run detection on the existing selections\n     * if the normalization changed but the QC was the same. In practice, this\n     * never happens, so we'll deal with it later.\n     */\n    \n    changed = true;\n    return;\n}\n\nexport function results() {\n    return {};\n}\n\nexport function serialize() {\n    var results = {};\n    \n    for (const [key, val] of Object.entries(cache.results)) {\n        if (\"reloaded\" in val) {\n            results[key] = val.reloaded;\n        } else {\n            results[key] = markers.serializeGroupStats(val.raw, 1);\n        }\n    }\n    \n    return {\n        \"parameters\": parameters,\n        \"contents\": { \"results\": results }\n    };\n}\n\nexport function unserialize(saved) {\n    parameters = saved.parameters;\n    for (const [key, val] of Object.entries(saved.contents)) {\n        cache.results[key] = { \"reloaded\": val };\n    }\n    return;\n}\n\nexport function addSelection(id, selection) {\n    var mat = normalization.fetchNormalizedMatrix();\n\n    var buffer = utils.allocateCachedArray(mat.numberOfColumns(), \"Int32Array\", cache);\n    buffer.fill(0);\n    var tmp = buffer.array();\n    selection.forEach(element => { tmp[element] = 1; });\n\n    // Assumes that we have at least one cell in and outside the selection!\n    var res = scran.scoreMarkers(mat, buffer); \n  \n    // Removing previous results, if there were any.\n    if (id in cache.results) {\n        utils.freeCache(cache.results[id].raw);\n        delete cache.results[id];\n    }\n  \n    cache.results[id] = { \"raw\": res };\n    parameters.selections[id] = selection;\n}\n\nexport function removeSelection(id) {\n    utils.freeCache(cache.results[id].raw);\n    delete cache.results[id];\n    delete parameters.selections[id];\n}\n\nexport function fetchResults(id, rank_type) {\n    var current = cache.results[id];\n    return markers.fetchGroupResults(current.raw, current.reloaded, rank_type, 1); \n};\n","var kanaDB;\nvar init = null;\n\nexport function initialize() {\n    init = new Promise(resolve => {\n        // initialize database on worker creation\n        kanaDB = indexedDB.open(\"KanaDB\", 2);\n\n        kanaDB.onupgradeneeded = (e) => {\n            var kanaDBClient = e.target.result;\n\n            // Currently purging all existing stores when the version is updated.\n            // At some point we may add a more sophisticated upgrade mechanism.\n            try {\n                kanaDBClient.deleteObjectStore(\"analysis\");\n            } catch (e) {}\n            try {\n                kanaDBClient.deleteObjectStore(\"analysis_meta\");\n            } catch (e) {}\n            try {\n                kanaDBClient.deleteObjectStore(\"file\");\n            } catch (e) {}\n            try {\n                kanaDBClient.deleteObjectStore(\"file_meta\");\n            } catch (e) {}\n\n            kanaDBClient.createObjectStore(\"analysis\", { keyPath: 'id' });\n            kanaDBClient.createObjectStore(\"analysis_meta\", { keyPath: 'id' });\n            kanaDBClient.createObjectStore(\"file\", { keyPath: 'id' });\n            kanaDBClient.createObjectStore(\"file_meta\", { keyPath: 'id' });\n        };\n\n        // Send existing stored analyses, if available.\n        kanaDB.onsuccess = () => {\n            getRecordsResolver(resolve);\n        };\n\n        kanaDB.onerror = () => {\n            resolve(null);\n        };\n    });\n\n    return init;\n}\n\nfunction getRecordsResolver(resolve, store = null) {\n    if (store === null) {\n        store = kanaDB.result\n            .transaction([\"analysis_meta\"], \"readonly\")\n            .objectStore(\"analysis_meta\")\n    }\n\n    var allAnalysis = store.getAll();\n\n    allAnalysis.onsuccess = function () {\n        let vals = allAnalysis.result;\n        vals.forEach(x => { delete x.files }); // no need to transfer that.\n        resolve(vals);\n    };\n    allAnalysis.onerror = function () {\n        resolve(null);\n    };\n}\n\n/** Helper functions **/\nasync function loadContent(id, store) {\n    return new Promise(resolve => {\n        let request = store.get(id);\n        request.onsuccess = function () {\n            if (request.result !== undefined) {\n                resolve(request.result);\n            } else {\n                resolve(null);\n            }\n        };\n        request.onerror = function () {\n            resolve(null);\n        };\n    });\n}\n\nfunction allOK(promises) {\n    return Promise.allSettled(promises)\n        .then(vals => {\n            for (const x of vals) {\n                if (!x) {\n                    return false;\n                }\n            }\n            return true;\n        });\n}\n\nexport async function getRecords() {\n    await init;\n    return new Promise(resolve => {\n        getRecordsResolver(resolve);\n    });\n}\n\n/** Functions to save content **/\nexport async function saveFile(id, buffer) {\n    await init;\n    let trans = kanaDB.result.transaction([\"file\", \"file_meta\"], \"readwrite\");\n    let file_store = trans.objectStore(\"file\");\n    let meta_store = trans.objectStore(\"file_meta\");\n\n    var meta = await loadContent(id, meta_store);\n    var refcount;\n    if (meta === null) {\n        refcount = 0;\n    } else {\n        refcount = meta[\"count\"];\n    }\n    refcount++;\n\n    var data_saving = new Promise(resolve => {\n        var putrequest = file_store.put({ \"id\": id, \"payload\": buffer });\n        putrequest.onsuccess = function (event) {\n            resolve(true);\n        };\n        putrequest.onerror = function (event) {\n            resolve(false);\n        };\n    });\n\n    var ref_saving = new Promise(resolve => {\n        meta.count = refcount;\n        var putrequest = meta_store.put(meta);\n        putrequest.onsuccess = function (event) {\n            resolve(true);\n        };\n        putrequest.onerror = function (event) {\n            resolve(false);\n        };\n    });\n\n    return allOK([data_saving, ref_saving])\n};\n\nexport async function saveAnalysis(id, state, files, title) { \n    await init;\n    let trans = kanaDB.result.transaction([\"analysis\", \"analysis_meta\"], \"readwrite\")\n    let analysis_store = trans.objectStore(\"analysis\");\n    let meta_store = trans.objectStore(\"analysis_meta\");\n\n    if (id == null) {\n        let already = await new Promise(resolve => getRecordsResolver(resolve, meta_store));\n        id = String(already.length);\n    }\n\n    var data_saving = new Promise(resolve => {\n        var putrequest = analysis_store.put({ \"id\": id, \"payload\": state });\n        putrequest.onsuccess = function (event) {\n            resolve(true);\n        };\n        putrequest.onerror = function (event) {\n            resolve(false);\n        };\n    });\n\n    var id_saving = new Promise(resolve => {\n        var putrequest = meta_store.put({ \"id\": id, \"files\": files, \"time\": Number(new Date()), \"title\": title });\n        putrequest.onsuccess = function (event) {\n            resolve(true);\n        };\n        putrequest.onerror = function (event) {\n            resolve(false);\n        };\n    });\n\n    if (await allOK([data_saving, id_saving])) {\n        return id;\n    } else {\n        return null;\n    }\n};\n\n/** Functions to load content **/\nexport async function loadFile(id) {\n    await init;\n    let file_store = kanaDB.result\n        .transaction([\"file\"], \"readonly\")\n        .objectStore(\"file\");\n\n    var meta = await loadContent(id, file_store);\n    return meta[\"payload\"];\n}\n\nexport async function loadAnalysis(id) {\n    await init;\n    let analysis_store = kanaDB.result\n        .transaction([\"analysis\"], \"readonly\")\n        .objectStore(\"analysis\");\n    var meta = await loadContent(id, analysis_store);\n    return meta[\"payload\"];\n}\n\n/** Functions to load content **/\nexport async function removeFile(id) {\n    await init;\n    let trans = kanaDB.result.transaction([\"file\", \"file_meta\"], \"readwrite\");\n    let file_store = trans.objectStore(\"file\");\n    let meta_store = trans.objectStore(\"file_meta\");\n\n    var meta = await loadContent(id, meta_store);\n    var refcount = meta[\"count\"];\n    refcount--;\n    var promises = [];\n\n    if (refcount == 0) {\n        promises.push(new Promise(resolve => {\n            let request = file_store.remove(id);\n            request.onerror = function (event) {\n                resolve(false);\n            };\n            request.onsuccess = function (event) {\n                resolve(true);\n            };\n        }));\n        promises.push(new Promise(resolve => {\n            let request = meta_store.delete(id);\n            request.onerror = function (event) {\n                resolve(false);\n            };\n            request.onsuccess = function (event) {\n                resolve(true);\n            };\n        }))\n    } else {\n        promises.push(new Promise(resolve => {\n            meta.count = refcount;\n            let request = meta_store.put(meta);\n            request.onsuccess = function (event) {\n                resolve(true);\n            };\n            request.onerror = function (event) {\n                resolve(false);\n            };\n        }));\n    }\n\n    return allOK(promises);\n}\n\nexport async function removeAnalysis(id) {\n    await init;\n    let trans = kanaDB.result.transaction([\"analysis\", \"analysis_meta\"], \"readwrite\")\n    let analysis_store = trans.objectStore(\"analysis\");\n    let meta_store = trans.objectStore(\"analysis_meta\");\n\n    var promises = [];\n\n    promises.push(new Promise(resolve => {\n        let request = analysis_store.delete(id);\n        request.onsuccess = function (event) {\n            resolve(true);\n        };\n        request.onerror = function (event) {\n            resolve(false);\n        };\n    }));\n\n    // Removing all files as well.\n    var meta = await loadContent(id, meta_store);\n    for (const f of meta[\"files\"]) {\n        promises.push(removeFile(f));\n    }\n\n    promises.push(new Promise(resolve => {\n        let request = meta_store.delete(id);\n        request.onsuccess = function (event) {\n            resolve(true);\n        };\n        request.onerror = function (event) {\n            resolve(false);\n        };\n    }));\n\n    return allOK(promises);\n}\n","import * as scran from \"scran.js\";\nimport * as inputs from \"./_inputs.js\";\nimport * as metrics from \"./_qc_metrics.js\";\nimport * as thresholds from \"./_qc_thresholds.js\";\nimport * as filter from \"./_qc_filter.js\";\nimport * as normalization from \"./_normalization.js\";\nimport * as variance from \"./_model_gene_var.js\";\nimport * as pca from \"./_pca.js\";\nimport * as index from \"./_neighbor_index.js\";\nimport * as cluster_choice from \"./_choose_clustering.js\";\nimport * as snn_cluster from \"./_snn_cluster.js\";\nimport * as snn_graph from \"./_snn_graph.js\";\nimport * as snn_neighbors from \"./_snn_neighbors.js\";\nimport * as tsne from \"./_tsne_monitor.js\";\nimport * as umap from \"./_umap_monitor.js\";\nimport * as cluster_markers from \"./_score_markers.js\";\nimport * as custom_markers from \"./_custom_markers.js\";\nimport * as kana_db from \"./KanaDBHandler.js\";\nimport * as utils from \"./_utils.js\";\nimport * as serialize_utils from \"./_utils_serialize.js\";\n\n/***************************************/\n\nfunction postSuccess_(info, step, message) {\n    var transferable = [];\n    utils.extractBuffers(info, transferable);\n    postMessage({\n        type: `${step}_DATA`,\n        resp: info,\n        msg: \"Success: \" + message\n    }, transferable);\n}\n\nfunction runAllSteps(mode = \"run\", state = null) {\n    var response;\n    if (mode === \"serialize\") {\n        response = {};\n    } else {\n        if (state == null) {\n            throw \"'state' must be supplied if 'mode' is not 'serialize'\";\n        }\n        if (mode === \"unserialize\") {\n            response = { \"params\": {} };\n        }\n    }\n  \n    // Creating helper functions.\n    var postSuccess = function (namespace, step, message) {\n        if (namespace.changed || mode == \"unserialize\") {\n            postSuccess_(namespace.results(), step, message);\n        }\n    }\n  \n    var postSuccessAsync = function (namespace, step, message) {\n        if (namespace.changed || mode == \"unserialize\") {\n            namespace.results()\n                .then(res => {\n                    postSuccess_(res, step, message);\n                });\n        }\n    }\n  \n    var addToObject = function (object, property, value) {\n        if (property in object) {\n            object[property] = { ...object[property], ...value };\n        } else {\n            object[property] = value;\n        }\n    }\n  \n    // Running through all steps.\n    {\n        let step = \"inputs\";\n        if (mode === \"serialize\") {\n            response[step] = inputs.serialize()\n        } else {\n            if (mode == \"run\") {\n                inputs.compute({\n                    \"format\": state.files.format,\n                    \"files\": state.files.files\n                });\n            } else {\n                inputs.unserialize(state[step]);\n                response[\"files\"] = {\n                    \"format\": \"kana\",\n                    \"files\": []\n                };\n            }\n            postSuccess(inputs, step, \"Count matrix loaded\");\n        }\n    }\n  \n    {\n        let step = \"quality_control_metrics\";\n        if (mode === \"serialize\") {\n            response[step] = metrics.serialize();\n        } else {\n            if (mode == \"run\") {\n                metrics.compute({\n                    \"use_mito_default\": state.params.qc[\"qc-usemitodefault\"],\n                    \"mito_prefix\": state.params.qc[\"qc-mito\"]\n                });\n            } else {\n                metrics.unserialize(state[step]);\n                addToObject(response[\"params\"], \"qc\", {\n                    \"qc-usemitodefault\": state[step].parameters.use_mito_default,\n                    \"qc-mito\": state[step].parameters.mito_prefix\n                });\n            }\n            postSuccess(metrics, step, \"QC metrics computed\");\n        }\n    }\n  \n    {\n        let step = \"quality_control_thresholds\";\n        if (mode === \"serialize\") {\n            response[step] = thresholds.serialize();\n        } else {\n            if (mode == \"run\") {\n                thresholds.compute({\n                    \"nmads\": state.params.qc[\"qc-nmads\"]\n                });\n            } else {\n                thresholds.unserialize(state[step]);\n                addToObject(response[\"params\"], \"qc\", {\n                    \"qc-nmads\": state[step].parameters.nmads\n                });\n            }\n            postSuccess(thresholds, step, \"QC thresholds computed\");\n        }\n    }\n  \n    {\n        let step = \"quality_control_filtered\";\n        if (mode == \"serialize\") {\n            response[step] = filter.serialize();\n        } else {\n            if (mode == \"run\") {\n                filter.compute({});\n            } else {\n                filter.unserialize(state[step]);\n            }\n            postSuccess(filter, step, \"QC filtering completed\");\n        }\n    }\n  \n    {\n        let step = \"normalization\";\n        if (mode == \"serialize\") {\n            response[step] = normalization.serialize();\n        } else {\n            if (mode == \"run\") {\n                normalization.compute({});\n            } else {\n                normalization.unserialize(state[step]);\n            }\n            postSuccess(normalization, step, \"Log-normalization completed\");\n        }\n    }\n  \n    {\n        let step = \"feature_selection\";\n        if (mode == \"serialize\") {\n            response[step] = variance.serialize();\n        } else {\n            if (mode == \"run\") {\n                variance.compute({\n                    \"span\": state.params.fSelection[\"fsel-span\"]\n                });\n            } else {\n                variance.unserialize(state[step]);\n                addToObject(response[\"params\"], \"fSelection\", {\n                    \"fsel-span\": state[step].parameters.span\n                });\n            }\n            postSuccess(variance, step, \"Variance modelling completed\");\n        }\n    }\n  \n    {\n        let step = \"pca\";\n        if (mode == \"serialize\") {\n            response[step] = pca.serialize();\n        } else {\n            if (mode == \"run\") {\n                pca.compute({\n                    \"num_hvgs\": state.params.pca[\"pca-hvg\"],\n                    \"num_pcs\": state.params.pca[\"pca-npc\"]\n                });\n            } else {\n                pca.unserialize(state[step]);\n                addToObject(response[\"params\"], \"pca\", {\n                    \"pca-hvg\": state[step].parameters.num_hvgs,\n                    \"pca-npc\": state[step].parameters.num_pcs\n                });\n            }\n            postSuccess(pca, step, \"Principal components analysis completed\");\n        }\n    }\n  \n    {\n        let step = \"neighbor_index\";\n        if (mode == \"serialize\") {\n            response[step] = index.serialize();\n        } else {\n            if (mode == \"run\") {\n                index.compute({\n                    \"approximate\": state.params.cluster[\"clus-approx\"]\n                });\n            } else {\n                index.unserialize(state[step]);\n                addToObject(response[\"params\"], \"cluster\", {\n                    \"clus-approx\": state[step].parameters.approximate\n                });\n            }\n            postSuccess(index, step, \"Neighbor search index constructed\");\n        }\n    }\n\n    // Need to handle promises in serialize(), results() output,\n    // as these are coming from other workers and are inherently async.\n    var tsne_res;\n    {\n        let step = \"tsne\";\n        if (mode == \"serialize\") {\n            tsne_res = tsne.serialize();\n        } else {\n            if (mode == \"run\") {\n                tsne.compute({\n                    \"perplexity\": state.params.tsne[\"tsne-perp\"],\n                    \"iterations\": state.params.tsne[\"tsne-iter\"],\n                    \"animate\": state.params.tsne[\"animate\"]\n                });\n            } else {\n                tsne.unserialize(state[step]);\n                addToObject(response[\"params\"], \"tsne\", {\n                  \"tsne-perp\": state[step].parameters.perplexity,\n                  \"tsne-iter\": state[step].parameters.iterations,\n                  \"animate\": state[step].parameters.animate\n                });\n            }\n            postSuccessAsync(tsne, step, \"t-SNE completed\");\n        }\n    }\n\n    var umap_res;\n    {\n        let step = \"umap\";\n        if (mode == \"serialize\") {\n            umap_res = umap.serialize();\n        } else {\n            if (mode == \"run\") {\n                umap.compute({\n                    \"num_epochs\": state.params.umap[\"umap-epochs\"],\n                    \"num_neighbors\": state.params.umap[\"umap-nn\"],\n                    \"min_dist\": state.params.umap[\"umap-min_dist\"],\n                    \"animate\": state.params.umap[\"animate\"]\n                });\n            } else {\n                umap.unserialize(state[step]);\n                addToObject(response[\"params\"], \"umap\", {\n                    \"num_epochs\": state[step].parameters.num_epochs,\n                    \"num_neighbors\": state[step].parameters.num_neighbors,\n                    \"min_dist\": state[step].parameters.min_dist,\n                    \"animate\": state[step].parameters.animate\n                });\n            }\n            postSuccessAsync(umap, step, \"UMAP completed\");\n        }\n    }\n  \n    // Back to normal programming.\n    {\n        let step = \"snn_find_neighbors\";\n        if (mode == \"serialize\") {\n            response[step] = snn_neighbors.serialize();\n        } else {\n            if (mode == \"run\") {\n                snn_neighbors.compute({\n                    \"k\": state.params.cluster[\"clus-k\"]\n                });\n            } else {\n                snn_neighbors.unserialize(state[step]);\n                addToObject(response[\"params\"], \"cluster\", {\n                    \"clus-k\": state[step].parameters.k\n                });\n            }\n            postSuccess(snn_neighbors, step, \"Shared nearest neighbor search completed\");\n        }\n    }\n  \n    {\n        let step = \"snn_build_graph\";\n        if (mode == \"serialize\") {\n            response[step] = snn_graph.serialize();\n        } else {\n            if (mode == \"run\") {\n                snn_graph.compute({\n                    \"scheme\": state.params.cluster[\"clus-scheme\"]\n                });\n            } else {\n                snn_graph.unserialize(state[step]);\n                addToObject(response[\"params\"], \"cluster\", {\n                    \"clus-scheme\": state[step].parameters.scheme\n                });\n            }\n            postSuccess(snn_graph, step, \"Shared nearest neighbor graph constructed\");\n        }\n    }\n  \n    {\n        let step = \"snn_cluster_graph\";\n        if (mode == \"serialize\") {\n            response[step] = snn_cluster.serialize();\n        } else {\n            if (mode == \"run\") {\n                snn_cluster.compute({\n                    \"resolution\": state.params.cluster[\"clus-res\"]\n                });\n            } else {\n                snn_cluster.unserialize(state[step]);\n                addToObject(response[\"params\"], \"cluster\", {\n                    \"clus-res\": state[step].parameters.resolution\n                });\n            }\n            postSuccess(snn_cluster, step, \"Community detection from SNN graph complete\");\n        }\n    }\n\n    {\n        let step = \"choose_clustering\";\n        if (mode == \"serialize\") {\n            response[step] = cluster_choice.serialize();\n        } else {\n            if (mode == \"run\") {\n                cluster_choice.compute({\n                    \"method\": state.params.cluster[\"clus-method\"]\n                });\n            } else {\n                cluster_choice.unserialize(state[step]);\n                addToObject(response[\"params\"], \"cluster\", {\n                    \"clus-method\": state[step].parameters.method\n                });\n            }\n            postSuccess(cluster_choice, step, \"Clustering of interest chosen\");\n        }\n    }\n\n    {\n        let step = \"marker_detection\";\n        if (mode == \"serialize\") {\n            response[step] = cluster_markers.serialize();\n        } else {\n            if (mode == \"run\") {\n                cluster_markers.compute({});\n            } else {\n                cluster_markers.unserialize(state[step]);\n            }\n            postSuccess(cluster_markers, step, \"Marker detection complete\");\n        }\n    }\n\n    {\n        let step = \"custom_marker_management\";\n        if (mode == \"serialize\") {\n            response[step] = custom_markers.serialize();\n        } else {\n            if (mode == \"run\") {\n                custom_markers.compute({});\n            } else {\n                custom_markers.unserialize(state[step]);\n            }\n            postSuccess(custom_markers, step, \"Pruning of custom markers finished\");\n        }\n    }\n  \n    if (mode == \"serialize\") {\n        return Promise.all([tsne_res, umap_res])\n            .then(done => {\n                response.tsne = done[0];\n                response.umap = done[1];\n                return response;\n            });\n    } else {\n        return response;\n    }\n}\n\n/***************************************/\n\nvar loaded;\nonmessage = function (msg) {\n    const payload = msg.data;\n    if (payload.type == \"INIT\") {\n        let nthreads = Math.round(navigator.hardwareConcurrency * 2 / 3);\n        let scran_init = scran.initialize({ numberOfThreads: nthreads });\n        scran_init \n            .then(x => {\n                postMessage({\n                    type: payload.type,\n                    msg: `Success: ScranJS/WASM initialized`\n                });\n            });\n\n        let kana_init = kana_db.initialize();\n        kana_init\n            .then(result => {\n                if (result !== null) {\n                    postMessage({\n                        type: \"KanaDB_store\",\n                        resp: result,\n                        msg: \"Success\"\n                    });\n                } else {\n                    console.log(error);\n                    postMessage({\n                        type: \"KanaDB_ERROR\",\n                        msg: `Fail: Cannot initialize DB`\n                    });\n                }\n            });\n\n        let tsne_init = tsne.initialize();\n        let umap_init = umap.initialize();\n\n        loaded = Promise.all([\n            scran_init,\n            kana_init,\n            tsne_init,\n            umap_init\n        ]);\n\n    } else if (payload.type == \"RUN\") {\n        loaded\n            .then(x => {\n                runAllSteps(\"run\", payload.payload)\n            })\n            .catch(error => {\n                console.log(error);\n                postMessage({\n                    type: \"run_ERROR\",\n                    msg: error.toString()\n                });\n            });\n\n    /**************** LOADING EXISTING ANALYSES *******************/\n    } else if (payload.type == \"LOAD\") {\n        if (payload.payload.files.format == \"kana\") {\n            const reader = new FileReaderSync();\n            var f = payload.payload.files.files.file[0];\n            loaded\n                .then(async (x) => {\n                    var contents = await serialize_utils.load(reader.readAsArrayBuffer(f));\n                    var response = runAllSteps(\"unserialize\", contents);\n                    postMessage({\n                        type: \"loadedParameters\",\n                        resp: response\n                    });\n                })\n                .catch(error => {\n                    console.log(error);\n                    postMessage({\n                        type: \"load_ERROR\",\n                        msg: error.toString()\n                    });\n                });\n\n        } else if (payload.payload.files.format == \"kanadb\") {\n            var id = payload.payload.files.files.file;\n            kana_db.loadAnalysis(id)\n                .then(async (res) => {\n                    if (res == null) {\n                        postMessage({\n                            type: \"KanaDB_ERROR\",\n                            msg: `Fail: cannot load analysis ID '${id}'`\n                        });\n                    } else {\n                        var contents = await serialize_utils.load(res);\n                        var response = await runAllSteps(\"unserialize\", contents);\n                        postMessage({\n                            type: \"loadedParameters\",\n                            resp: response\n                        });\n                    }\n                })\n                .catch(error => {\n                    console.log(error);\n                    postMessage({\n                        type: \"load_ERROR\",\n                        msg: error.toString()\n                    });\n                });\n        }\n  \n    } else if (payload.type == \"EXPORT\") { // exporting an analysis\n        loaded\n            .then(async (x) => {\n                var state = await runAllSteps(\"serialize\");\n                var output = await serialize_utils.save(state, \"full\");\n                postMessage({\n                    type: \"exportState\",\n                    resp: output,\n                    msg: \"Success: application state exported\"\n                }, [output]);\n            })\n            .catch(error => {\n                console.log(error);\n                postMessage({\n                    type: \"export_ERROR\",\n                    msg: error.toString()\n                });\n            });\n  \n    } else if (payload.type == \"SAVEKDB\") { // save analysis to inbrowser indexedDB \n        var title = payload.payload.title;\n        loaded\n            .then(async (x) => {\n                var state = await runAllSteps(\"serialize\");\n                var output = await serialize_utils.save(state, \"KanaDB\");\n                var id = await kana_db.saveAnalysis(null, output.state, output.file_ids, title);\n                if (id !== null) {\n                    let recs = await kana_db.getRecords();\n                    postMessage({\n                        type: \"KanaDB_store\",\n                        resp: recs,\n                        msg: `Success: Saved analysis to cache (${id})`\n                    });\n                } else {\n                    console.log(error);\n                    postMessage({\n                        type: \"KanaDB_ERROR\",\n                        msg: `Fail: Cannot save analysis to cache (${id})`\n                    });\n                }\n            })\n            .catch(error => {\n                console.log(error);\n                postMessage({\n                    type: \"export_ERROR\",\n                    msg: error.toString()\n                });\n            });\n  \n    } else if (payload.type == \"REMOVEKDB\") { // remove a saved analysis\n        var id = payload.payload.id;\n        kana_db.removeAnalysis(id)\n            .then(async (result) => {\n                if (result) {\n                    let recs = await kana_db.getRecords();\n                    postMessage({\n                        type: \"KanaDB_store\",\n                        resp: recs,\n                        msg: `Success: Removed file from cache (${id})`\n                    });\n                } else {\n                    console.log(error);\n                    postMessage({\n                        type: \"KanaDB_ERROR\",\n                        msg: `fail: cannot remove file from cache (${id})`\n                    });\n                }\n            });\n  \n    /**************** OTHER EVENTS FROM UI *******************/\n    } else if (payload.type == \"getMarkersForCluster\") {\n        loaded.then(x => {\n            let cluster = payload.payload.cluster;\n            let rank_type = payload.payload.rank_type;\n            var resp = cluster_markers.fetchGroupResults(rank_type, cluster);\n      \n            var transferrable = [];\n            utils.extractBuffers(resp, transferrable);\n            postMessage({\n                type: \"setMarkersForCluster\",\n                resp: resp,\n                msg: \"Success: GET_MARKER_GENE done\"\n            }, transferrable);\n        });\n  \n    } else if (payload.type == \"getGeneExpression\") {\n        loaded.then(x => {\n            let row_idx = payload.payload.gene;\n            var vec = normalization.fetchExpression(row_idx);\n            postMessage({\n                type: \"setGeneExpression\",\n                resp: {\n                    gene: row_idx,\n                    expr: vec\n                },\n                msg: \"Success: GET_GENE_EXPRESSION done\"\n            }, [vec.buffer]);\n        });\n  \n    } else if (payload.type == \"computeCustomMarkers\") {\n        loaded.then(x => {\n            custom_markers.addSelection(payload.payload.id, payload.payload.selection);\n            postMessage({\n                type: \"computeCustomMarkers\",\n                msg: \"Success: COMPUTE_CUSTOM_MARKERS done\"\n            });\n        });\n  \n    } else if (payload.type == \"getMarkersForSelection\") {\n        loaded.then(x => {\n            var resp = custom_markers.fetchResults(payload.payload.cluster, payload.payload.rank_type);\n            var transferrable = [];\n            utils.extractBuffers(resp, transferrable);\n            postMessage({\n                type: \"setMarkersForCustomSelection\",\n                resp: resp,\n                msg: \"Success: GET_MARKER_GENE done\"\n            }, transferrable);\n        });\n  \n    } else if (payload.type == \"removeCustomMarkers\") {\n        loaded.then(x => {\n            custom_markers.removeSelection(payload.payload.id);\n        });\n  \n    } else if (payload.type == \"animateTSNE\") {\n        loaded.then(async (x) => {\n            await tsne.animate();\n            var res = await tsne.results();\n            postSuccess_(res, \"tsne\", \"Resending t-SNE coordinates\");\n        });\n  \n    } else if (payload.type == \"animateUMAP\") {\n        loaded.then(async (x) => {\n            await umap.animate();\n            var res = await umap.results();\n            postSuccess_(res, \"umap\", \"Resending UMAP coordinates\");\n        });\n\n    } else if (payload.type == \"getAnnotation\") {\n        loaded.then(x => {\n            let annot = payload.payload.annotation;\n            var vec = inputs.fetchAnnotations(annot);\n            postMessage({\n                type: \"setAnnotation\",\n                resp: {\n                    annotation: annot,\n                    values: {\n                        \"index\": vec.index,\n                        \"factor\": vec.factor\n                    }\n                },\n                msg: \"Success: GET_ANNOTATION done\"\n            }, [vec.factor.buffer]);\n        });\n  \n    } else {\n        console.log(\"MIM:::msg type incorrect\")\n    }\n}\n","import * as pako from \"pako\";\nimport * as hashwasm from \"hash-wasm\";\nimport * as kana_db from \"./KanaDBHandler.js\";\n\n// Must be integers!\nconst FORMAT_EMBEDDED_FILES = 0;\nconst FORMAT_EXTERNAL_KANADB = 1;\nconst FORMAT_VERSION = 0;\n\nfunction normalizeTypedArrays(object) {\n    if (Array.isArray(object)) {\n        for (var i = 0; i < object.length; i++) {\n            object[i] = normalizeTypedArrays(object[i]);\n        }\n    } else if (ArrayBuffer.isView(object)) {\n        object = { \n            \"_TypedArray_class\": object.constructor.name, \n            \"_TypedArray_values\": Array.from(object) \n        };\n    } else if (object instanceof Object) {\n        // This MUST be after the previous clause, as otherwise\n        // a TypedArray is an object and is incorrectly handled. \n        for (const [key, element] of Object.entries(object)) {\n            object[key] = normalizeTypedArrays(element);\n        }\n    }\n    return object;\n}\n\nfunction recoverTypedArrays(object) {\n    if (Array.isArray(object)) {\n        for (var i = 0; i < object.length; i++) {\n            object[i] = recoverTypedArrays(object[i]);\n        }\n    } else if (object instanceof Object) {\n        if (\"_TypedArray_class\" in object) {\n            var cls = object[[\"_TypedArray_class\"]];\n            var vals = object[[\"_TypedArray_values\"]];\n            switch (cls) {\n                case \"Uint8Array\":\n                    object = new Uint8Array(vals.length);\n                    break;\n                case \"Int8Array\":\n                    object = new Int8Array(vals.length);\n                    break;\n                case \"Uint8Array\":\n                    object = new Uint8Array(vals.length);\n                    break;\n                case \"Uint16Array\":\n                    object = new Uint16Array(vals.length);\n                    break;\n                case \"Int16Array\":\n                    object = new Int16Array(vals.length);\n                    break;\n                case \"Uint32Array\":\n                    object = new Uint32Array(vals.length);\n                    break;\n                case \"Int32Array\":\n                    object = new Int32Array(vals.length);\n                    break;\n                case \"Uint64Array\":\n                    object = new Uint64Array(vals.length);\n                    break;\n                case \"Int64Array\":\n                    object = new Int64Array(vals.length);\n                    break;\n                case \"Float32Array\":\n                    object = new Float32Array(vals.length);\n                    break;\n                case \"Float64Array\":\n                    object = new Float64Array(vals.length);\n                    break;\n                default:\n                    throw \"unrecognized TypedArray class '\" + cls;\n            }\n            object.set(vals);\n        } else {\n            for (const [key, element] of Object.entries(object)) {\n                object[key] = recoverTypedArrays(element);\n            }\n        }\n    } \n    return object;\n}\n\nfunction numberToBuffer(number) {\n    // Store as little-endian. Probably safer\n    // than trying to cast it from a Uint64Array;\n    // not sure that endianness is strictly defined.\n    var output = new Uint8Array(8);\n\n    var i = 0;\n    while (number > 0) {\n        output[i] = number % 256;\n        number = Math.floor(number / 256);\n        i++;\n    }\n\n    return output;\n}\n\nfunction bufferToNumber(buffer) {\n    var output = 0;\n    var multiplier = 1;\n    for (const x of buffer) {\n        output += multiplier * x;\n        multiplier *= 256;\n    }\n    return output;\n}\n\nexport async function save(contents, mode = \"full\") {\n    // Extract out the file buffers.\n    var buffered = contents.inputs.parameters.files;\n    var all_buffers = [];\n    var total_len = 0;\n    var format_type;\n\n    if (mode == \"full\") {\n        format_type = FORMAT_EMBEDDED_FILES;\n        buffered.forEach((x, i) => {\n            var val = x.buffer;\n            all_buffers.push(val);\n            buffered[i].buffer = { \"offset\": total_len, \"size\": val.byteLength };\n            total_len += val.byteLength;\n        });\n\n    } else if (mode == \"KanaDB\") {\n        // Saving the files to IndexedDB instead. 'all_buffers' now holds a promise\n        // indicating whether all of these things were saved properly.\n        format_type = FORMAT_EXTERNAL_KANADB;\n        for (const x of buffered) {\n            var md5 = await hashwasm.md5(new Uint8Array(x.buffer));\n            var id = x.type + \"_\" + x.name + \"_\" + x.buffer.byteLength + \"_\" + md5;\n            var ok = await kana_db.saveFile(id, x.buffer);\n            if (!ok) {\n                throw \"failed to save file '\" + id + \"' to KanaDB\";\n            }\n            x.buffer = id;\n            all_buffers.push(id);\n        }\n\n    } else {\n        throw \"unsupported mode \" + mode;\n    }\n\n    // Converting all other TypedArrays to normal arrays.\n    contents = normalizeTypedArrays(contents);\n\n    // Converting the JSON to a string and gzipping it into a Uint8Array.\n    var json_str = JSON.stringify(contents);\n    const json_view = pako.gzip(json_str);\n\n    // Allocating a huge arrayBuffer.\n    var combined = new ArrayBuffer(24 + json_view.length + total_len);\n    var combined_arr = new Uint8Array(combined);\n    var offset = 0;\n\n    let format = numberToBuffer(format_type);\n    combined_arr.set(format, offset); \n    offset += format.length;\n\n    let version = numberToBuffer(FORMAT_VERSION);\n    combined_arr.set(version, offset); \n    offset += version.length;\n\n    let json_len = numberToBuffer(json_view.length);\n    combined_arr.set(json_len, offset); \n    offset += json_len.length;\n\n    if (offset != 24) {\n        throw \"oops - accounting error in the serialization code!\";\n    }\n\n    combined_arr.set(json_view, offset);\n    offset += json_view.length;\n\n    if (mode == \"full\") {\n        for (const buf of all_buffers) {\n            const tmp = new Uint8Array(buf);\n            combined_arr.set(tmp, offset);\n            offset += tmp.length;\n        }\n        return combined;\n\n    } else if (mode == \"KanaDB\") {\n        return { \"file_ids\": all_buffers, \"state\": combined };\n\n    } else {\n        throw \"unsupported mode \" + mode;\n    }\n}\n\nexport async function load(buffer) {\n    var offset = 0;\n    var format = bufferToNumber(new Uint8Array(buffer, offset, 8));\n    offset += 8;\n\n    var version = bufferToNumber(new Uint8Array(buffer, offset, 8));\n    offset += 8;\n\n    var json_len = bufferToNumber(new Uint8Array(buffer, offset, 8));\n    offset += 8;\n\n    var contents = pako.ungzip(new Uint8Array(buffer, offset, json_len), { \"to\": \"string\" });\n    contents = JSON.parse(contents);\n    contents = recoverTypedArrays(contents);\n    offset += json_len;\n\n    var buffered = contents.inputs.parameters.files;\n    if (format == FORMAT_EMBEDDED_FILES) {\n        buffered.forEach((x, i) => {\n            var details = x.buffer;\n            var target = new Uint8Array(buffer, offset + details.offset, details.size);\n            var tmp = new ArrayBuffer(details.size);\n            (new Uint8Array(tmp)).set(target);\n            buffered[i].buffer = tmp;\n        });\n\n    } else if (format == FORMAT_EXTERNAL_KANADB) {\n        var collected = [];\n        buffered.forEach((x, i) => {\n            var id = x.buffer;\n            collected.push(kana_db.loadFile(id));\n        });\n  \n        var resolved = await Promise.all(collected);\n        buffered.forEach((x, i) => {\n            if (resolved[i] === null) {\n                throw \"KanaDB loading failed for file ID '\" + x.buffer + \"'\";\n            }\n            x.buffer = resolved[i];\n        });\n\n    } else {\n        throw \"unsupported format type\";\n    }\n \n    return contents;\n}\n","// The module cache\nvar __webpack_module_cache__ = {};\n\n// The require function\nfunction __webpack_require__(moduleId) {\n\t// Check if module is in cache\n\tvar cachedModule = __webpack_module_cache__[moduleId];\n\tif (cachedModule !== undefined) {\n\t\treturn cachedModule.exports;\n\t}\n\t// Create a new module (and put it into the cache)\n\tvar module = __webpack_module_cache__[moduleId] = {\n\t\t// no module.id needed\n\t\t// no module.loaded needed\n\t\texports: {}\n\t};\n\n\t// Execute the module function\n\t__webpack_modules__[moduleId](module, module.exports, __webpack_require__);\n\n\t// Return the exports of the module\n\treturn module.exports;\n}\n\n// expose the modules object (__webpack_modules__)\n__webpack_require__.m = __webpack_modules__;\n\n// the startup function\n__webpack_require__.x = function() {\n\t// Load entry module and return exports\n\t// This entry module depends on other loaded chunks and execution need to be delayed\n\tvar __webpack_exports__ = __webpack_require__.O(undefined, [537,555], function() { return __webpack_require__(2459); })\n\t__webpack_exports__ = __webpack_require__.O(__webpack_exports__);\n\treturn __webpack_exports__;\n};\n\n","var deferred = [];\n__webpack_require__.O = function(result, chunkIds, fn, priority) {\n\tif(chunkIds) {\n\t\tpriority = priority || 0;\n\t\tfor(var i = deferred.length; i > 0 && deferred[i - 1][2] > priority; i--) deferred[i] = deferred[i - 1];\n\t\tdeferred[i] = [chunkIds, fn, priority];\n\t\treturn;\n\t}\n\tvar notFulfilled = Infinity;\n\tfor (var i = 0; i < deferred.length; i++) {\n\t\tvar chunkIds = deferred[i][0];\n\t\tvar fn = deferred[i][1];\n\t\tvar priority = deferred[i][2];\n\t\tvar fulfilled = true;\n\t\tfor (var j = 0; j < chunkIds.length; j++) {\n\t\t\tif ((priority & 1 === 0 || notFulfilled >= priority) && Object.keys(__webpack_require__.O).every(function(key) { return __webpack_require__.O[key](chunkIds[j]); })) {\n\t\t\t\tchunkIds.splice(j--, 1);\n\t\t\t} else {\n\t\t\t\tfulfilled = false;\n\t\t\t\tif(priority < notFulfilled) notFulfilled = priority;\n\t\t\t}\n\t\t}\n\t\tif(fulfilled) {\n\t\t\tdeferred.splice(i--, 1)\n\t\t\tvar r = fn();\n\t\t\tif (r !== undefined) result = r;\n\t\t}\n\t}\n\treturn result;\n};","// getDefaultExport function for compatibility with non-harmony modules\n__webpack_require__.n = function(module) {\n\tvar getter = module && module.__esModule ?\n\t\tfunction() { return module['default']; } :\n\t\tfunction() { return module; };\n\t__webpack_require__.d(getter, { a: getter });\n\treturn getter;\n};","// define getter functions for harmony exports\n__webpack_require__.d = function(exports, definition) {\n\tfor(var key in definition) {\n\t\tif(__webpack_require__.o(definition, key) && !__webpack_require__.o(exports, key)) {\n\t\t\tObject.defineProperty(exports, key, { enumerable: true, get: definition[key] });\n\t\t}\n\t}\n};","__webpack_require__.f = {};\n// This file contains only the entry chunk.\n// The chunk loading function for additional chunks\n__webpack_require__.e = function(chunkId) {\n\treturn Promise.all(Object.keys(__webpack_require__.f).reduce(function(promises, key) {\n\t\t__webpack_require__.f[key](chunkId, promises);\n\t\treturn promises;\n\t}, []));\n};","// This function allow to reference async chunks and sibling chunks for the entrypoint\n__webpack_require__.u = function(chunkId) {\n\t// return url for filenames based on template\n\treturn \"static/js/\" + chunkId + \".\" + {\"139\":\"dfff2a0d\",\"495\":\"5bc8be6f\",\"537\":\"2057833a\",\"555\":\"b79ae422\",\"653\":\"0a0c9a22\"}[chunkId] + \".chunk.js\";\n};","// This function allow to reference async chunks and sibling chunks for the entrypoint\n__webpack_require__.miniCssF = function(chunkId) {\n\t// return url for filenames based on template\n\treturn undefined;\n};","__webpack_require__.g = (function() {\n\tif (typeof globalThis === 'object') return globalThis;\n\ttry {\n\t\treturn this || new Function('return this')();\n\t} catch (e) {\n\t\tif (typeof window === 'object') return window;\n\t}\n})();","__webpack_require__.o = function(obj, prop) { return Object.prototype.hasOwnProperty.call(obj, prop); }","// define __esModule on exports\n__webpack_require__.r = function(exports) {\n\tif(typeof Symbol !== 'undefined' && Symbol.toStringTag) {\n\t\tObject.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });\n\t}\n\tObject.defineProperty(exports, '__esModule', { value: true });\n};","__webpack_require__.p = \"/kana/\";","__webpack_require__.b = self.location + \"/../../../\";\n\n// object to store loaded chunks\n// \"1\" means \"already loaded\"\nvar installedChunks = {\n\t459: 1\n};\n\n// importScripts chunk loading\nvar installChunk = function(data) {\n\tvar chunkIds = data[0];\n\tvar moreModules = data[1];\n\tvar runtime = data[2];\n\tfor(var moduleId in moreModules) {\n\t\tif(__webpack_require__.o(moreModules, moduleId)) {\n\t\t\t__webpack_require__.m[moduleId] = moreModules[moduleId];\n\t\t}\n\t}\n\tif(runtime) runtime(__webpack_require__);\n\twhile(chunkIds.length)\n\t\tinstalledChunks[chunkIds.pop()] = 1;\n\tparentChunkLoadingFunction(data);\n};\n__webpack_require__.f.i = function(chunkId, promises) {\n\t// \"1\" is the signal for \"already loaded\"\n\tif(!installedChunks[chunkId]) {\n\t\tif(true) { // all chunks have JS\n\t\t\timportScripts(__webpack_require__.p + __webpack_require__.u(chunkId));\n\t\t}\n\t}\n};\n\nvar chunkLoadingGlobal = self[\"webpackChunkkana\"] = self[\"webpackChunkkana\"] || [];\nvar parentChunkLoadingFunction = chunkLoadingGlobal.push.bind(chunkLoadingGlobal);\nchunkLoadingGlobal.push = installChunk;\n\n// no HMR\n\n// no HMR manifest","var next = __webpack_require__.x;\n__webpack_require__.x = function() {\n\treturn Promise.all([\n\t\t__webpack_require__.e(537),\n\t\t__webpack_require__.e(555)\n\t]).then(next);\n};","// run startup\nvar __webpack_exports__ = __webpack_require__.x();\n"],"names":["freeCache","object","undefined","free","freeReloaded","cache","Object","entries","reloaded","v","scran","changedParameters","x","y","JSON","stringify","computeRange","arr","max","Infinity","min","forEach","allocateCachedArray","size","type","name","reallocate","candidate","constructor","className","extractBuffers","store","Array","isArray","ArrayBuffer","isView","buffer","push","parameters","abbreviated","changed","permuteGenes","genes","buf","matrix","numberOfRows","permutation","perm","array","key","val","copy","slice","i","length","dummyGenes","numberOfRowss","readDSVFromBuffer","content","fname","delim","ext","split","pop","pako","dec","TextDecoder","decoded","decode","tsv","d3","parsed","parseRows","loadMatrixMarketRaw","files","utils","first_mtx","filter","contents","Uint8Array","is_compressed","genes_file","ids","symb","annotations_file","diff","numberOfColumns","headerFlag","headers","shift","annotations","map","guessGenesFromHDF5","f","output","keys","indexOf","vars","get","hdf5","vkeys","index","value","match","current","field","guessGenesFromH5AD","mat","feats","featkeys","featid","id","featname","guessGenesFrom10x","guessAnnotationsFromHDF5","obs","colnames","dtype","compound","members","annots","guessAnnotationsFromH5AD","loadHDF5Raw","first_file","tmppath","path","fkeys","sparse_opts","dense_opts","cur_keys","shape","guessPath","close","compute","args","format","reader","FileReaderSync","it","bufferFun","formatted","readAsArrayBuffer","mtx","gene","barcode","loadMatrixMarket","file","loadHDF5","results","fetchDimensions","serialize","num_cells","parameters2","unserialize","saved","fetchCountMatrix","values","fetchGenes","fetchAnnotations","col","asize","uvals","uTypedAray","mito","ensembl","Set","symbol","rawCompute","raw","subsets","inputs","fill","gene_info","sub_arr","use_mito_default","has","lower_mito","mito_prefix","toLowerCase","startsWith","fetchResults","data","qc_output","sums","detected","proportion","subsetProportions","ranges","fetchQCMetrics","fetchSums","unsafe","metrics","stats","numberOfMADs","nmads","obj","thresholdsSums","thresholdsDetected","thresholdsSubsetProportions","discards","fetchDiscards","tmp","set","fetchDiscardsAsWasmArray","discardOverall","byteOffset","out","disc","thresholds","fetchRetained","retained","fetchFilteredMatrix","size_factors","j","sizeFactors","fetchNormalizedMatrix","fetchExpression","row","normalization","span","sorted_residuals","residuals","sort","means","fitted","resids","model_output","variances","spawnStats","fetchSortedResiduals","fetchResiduals","fetchPCsAsWasmArray","pcs","principalComponents","variance","sorted_resids","threshold_at","num_hvgs","sub","unsorted_resids","element","features","numberOfPCs","num_pcs","var_exp","pca_output","varianceExplained","total_var","totalVariance","to_save","fetchPCs","pca","numberOfDims","numberOfCells","num_obs","fetchIndex","nn_index","k","fetchNeighbors","res","neighbors","scheme","fetchGraph","fetchClustersAsWasmArray","clusters","membership","graph","g","resolution","method","cluster","computeNeighbors","rbuf","ibuf","dbuf","runs","indices","distances","sendTask","worker","payload","transferrable","counter","p","Promise","resolve","reject","promises","postMessage","initializeWorker","onmessage","msg","endsWith","iteration","fun","error","runWithNeighbors","nn_out","run_msg","retrieveCoordinates","run","then","initialize","vizutils","Worker","URL","core","reneighbor","perplexity","animate","param_copy","initialized","num_neighbors","serializeGroupStats","group","lfc","summary","deltaDetected","cohen","auc","fetchGroupResults","rank_type","ordering","ranking","use_reloaded","increasing","effect","Int32Array","s","stat_detected","stat_mean","stat_lfc","stat_delta_d","reorder","thing","Float64Array","delta_detected","choice","num","numberOfGroups","markers","kanaDB","selections","addSelection","selection","removeSelection","init","getRecordsResolver","result","transaction","objectStore","allAnalysis","getAll","onsuccess","vals","onerror","loadContent","request","allOK","allSettled","getRecords","saveFile","trans","file_store","meta_store","meta","refcount","data_saving","putrequest","put","event","ref_saving","count","saveAnalysis","state","title","analysis_store","already","String","id_saving","Number","Date","loadFile","removeFile","remove","delete","loaded","normalizeTypedArrays","from","recoverTypedArrays","cls","Int8Array","Uint16Array","Int16Array","Uint32Array","Uint64Array","Int64Array","Float32Array","numberToBuffer","number","Math","floor","bufferToNumber","multiplier","save","mode","buffered","all_buffers","total_len","format_type","byteLength","hashwasm","md5","kana_db","json_str","json_view","combined","combined_arr","offset","version","json_len","load","parse","details","target","collected","all","resolved","postSuccess_","info","step","message","transferable","resp","runAllSteps","response","postSuccess","namespace","postSuccessAsync","addToObject","property","params","qc","fSelection","tsne_res","approximate","umap_res","tsne","iterations","umap","num_epochs","min_dist","snn_neighbors","snn_graph","snn_cluster","cluster_choice","cluster_markers","custom_markers","done","nthreads","round","navigator","hardwareConcurrency","scran_init","numberOfThreads","kana_init","indexedDB","open","onupgradeneeded","e","kanaDBClient","deleteObjectStore","createObjectStore","keyPath","console","log","tsne_init","umap_init","catch","toString","serialize_utils","file_ids","recs","row_idx","vec","expr","annot","annotation","factor","__webpack_module_cache__","__webpack_require__","moduleId","cachedModule","exports","module","__webpack_modules__","m","__webpack_exports__","O","deferred","chunkIds","fn","priority","notFulfilled","fulfilled","every","splice","r","n","getter","__esModule","d","a","definition","o","defineProperty","enumerable","chunkId","reduce","u","miniCssF","globalThis","this","Function","window","prop","prototype","hasOwnProperty","call","Symbol","toStringTag","b","self","location","installedChunks","importScripts","chunkLoadingGlobal","parentChunkLoadingFunction","bind","moreModules","runtime","next"],"sourceRoot":""}