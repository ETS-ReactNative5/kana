{"version":3,"file":"static/js/450.3afdb060.chunk.js","mappings":"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","sources":["../node_modules/scran.js/module/findNearestNeighbors.js","../node_modules/scran.js/module/utils.js"],"sourcesContent":["import * as utils from \"./utils.js\";\nimport * as wasm from \"./wasm.js\";\nimport { Int32WasmArray, Float64WasmArray } from \"./WasmArray.js\";\nimport { PCAResults } from \"./runPCA.js\";\n\n/** \n * Wrapper for the neighbor search index on the Wasm heap.\n */\nexport class NeighborSearchIndex {\n    /**\n     * @param {Object} raw Search index on the Wasm heap.\n     *\n     * Not to be called directly by developers;\n     * use `buildNeighborSearchIndex()` instead.\n     */\n    constructor(raw) {\n        this.index = raw;\n        return;\n    }\n\n    /**\n     * @return Number of cells in the index.\n     */\n    numberOfCells() {\n        return this.index.num_obs();\n    }\n\n    /**\n     * @return Frees the memory allocated on the Wasm heap for this object.\n     * This invalidates this object and all references to it.\n     */\n    free() {\n        this.index.delete();\n        this.index = null;\n        return;\n    }\n}\n\n/**\n * Build the nearest neighbor search index.\n *\n * @param {(PCAResults|Float64WasmArray|Array|TypedArray)} x - Numeric coordinates of each cell in the dataset.\n * For array inputs, this is expected to be in column-major format where the rows are the variables and the columns are the cells.\n * For a `PCAResults` input, we extract the principal components.\n * @param {Object} [options] - Optional parameters.\n * @param {number} [options.numberOfDims] - Number of variables/dimensions per cell.\n * Only used (and required) for array-like `x`.\n * @param {number} [options.numberOfCells] - Number of cells.\n * Only used (and required) for array-like `x`.\n * @param {boolean} [options.approximate] - Whether to build an index for an approximate neighbor search.\n *\n * @return A `NeighborSearchIndex` object to use for neighbor searches.\n */\nexport function buildNeighborSearchIndex(x, { numberOfDims = null, numberOfCells = null, approximate = true } = {}) {\n    var buffer;\n    var raw;\n    var output;\n\n    try {\n        let pptr;\n\n        if (x instanceof PCAResults) {\n            numberOfDims = x.numberOfPCs();\n            numberOfCells = x.numberOfCells();\n            let pcs = x.principalComponents({ copy: false });\n            pptr = pcs.byteOffset;\n\n        } else {\n            if (numberOfDims === null || numberOfCells === null) {\n                throw \"'numberOfDims' and 'numberOfCells' must be specified when 'x' is an Array\";\n            }\n\n            buffer = utils.wasmifyArray(x, \"Float64WasmArray\");\n            if (buffer.length != numberOfDims * numberOfCells) {\n                throw \"length of 'x' must be the product of 'numberOfDims' and 'numberOfCells'\";\n            }\n\n            pptr = buffer.offset;\n        }\n\n        raw = wasm.call(module => module.build_neighbor_index(pptr, numberOfDims, numberOfCells, approximate)); \n        output = new NeighborSearchIndex(raw);\n\n    } catch (e) {\n        utils.free(raw);\n        throw e;\n\n    } finally {\n        utils.free(buffer);\n    }\n\n    return output;\n}\n\n/** \n * Wrapper for the neighbor search results on the Wasm heap.\n */\nexport class NeighborSearchResults {\n    /**\n     * @param {Object} raw Search results on the Wasm heap.\n     *\n     * Not to be called directly by developers;\n     * use `findNearestNeighbors()` or `unserialize()` instead.\n     */\n    constructor(raw) {\n        this.results = raw;\n        return;\n    }\n\n    /**\n     * @return The total number of neighbors across all cells.\n     * This is usually the product of the number of neighbors and the number of cells.\n     */\n    size() {\n        return this.results.size();\n    }\n\n    /**\n     * @return The number of cells used in the search.\n     */\n    numberOfCells() {\n        return this.results.num_obs();\n    }\n\n    /**\n     * @param {Object} [options] - Optional parameters.\n     * @param {?Int32WasmArray} [options.runs] - A Wasm-allocated array of length equal to `numberOfCells()`,\n     * to be used to store the number of neighbors per cell.\n     * @param {?Int32WasmArray} [options.indices] - A Wasm-allocated array of length equal to `size()`,\n     * to be used to store the indices of the neighbors of each cell.\n     * @param {?Float64WasmArray} [options.distances] - A Wasm-allocated array of length equal to `size()`,\n     * to be used to store the distances to the neighbors of each cell.\n     *\n     * @return \n     * If all of the arguments are non-`null`, the buffers in `runs`, `indices` and `distances` are filled with their respective contents, and nothing is returned.\n     * If all of the arguments are `null`, a object is returned with `TypedArray` entries for each component.\n     * Otherwise, an error is raised.\n     */\n    serialize({ runs = null, indices = null, distances = null } = {}) {\n        var copy = (runs === null) + (indices === null) + (distances === null);\n        if (copy != 3 && copy != 0) {\n            throw \"either all or none of 'runs', 'indices' and 'distances' can be 'null'\";\n        }\n\n        if (copy === 3) {\n            var run_data;\n            var ind_data;\n            var dist_data;\n            var output;\n            \n            try {\n                run_data = new Int32WasmArray(this.numberOfCells());\n                let s = this.size();\n                ind_data = new Int32WasmArray(s);\n                dist_data = new Float64WasmArray(s);\n                this.results.serialize(run_data.offset, ind_data.offset, dist_data.offset);\n\n                output = { \n                    \"runs\": run_data.slice(), \n                    \"indices\": ind_data.slice(), \n                    \"distances\": dist_data.slice() \n                };\n            } finally {\n                utils.free(run_data);\n                utils.free(ind_data);\n                utils.free(dist_data);\n            }\n\n            return output;\n        } else {\n            this.results.serialize(runs.offset, indices.offset, distances.offset);\n        }\n    }\n\n    /**\n     * @param {Int32WasmArray|Array|TypedArray} runs An array of length equal to `numberOfCells()`,\n     * containing the number of neighbors per cell.\n     * @param {Int32WasmArray|Array|TypedArray} indices An array of length equal to `size()`,\n     * containing the indices of the neighbors of each cell.\n     * @param {Float64WasmArray|Array|TypedArray} indices An array of length equal to `size()`,\n     * containing the distances to the neighbors of each cell.\n     *\n     * @return A new `NeighborSearchResults` object containing the unserialized search results.\n     */\n    static unserialize(runs, indices, distances) {\n        var raw;\n        var output;\n        var run_data;\n        var ind_data;\n        var dist_data;\n\n        try {\n            run_data = utils.wasmifyArray(runs, \"Int32WasmArray\");\n            ind_data = utils.wasmifyArray(indices, \"Int32WasmArray\");\n            dist_data = utils.wasmifyArray(distances, \"Float64WasmArray\");\n            raw = wasm.call(module => new module.NeighborResults(runs.length, run_data.offset, ind_data.offset, dist_data.offset));\n            output = new NeighborSearchResults(raw);\n        } catch (e) {\n            utils.free(raw);\n            throw e;\n        } finally { \n            utils.free(run_data);\n            utils.free(ind_data);\n            utils.free(dist_data);\n        }\n\n        return output;\n    }\n\n    /**\n     * @return Frees the memory allocated on the Wasm heap for this object.\n     * This invalidates this object and all references to it.\n     */\n    free() {\n        this.results.delete();\n        this.results = null;\n        return;\n    }\n}\n\n/**\n * Find the nearest neighbors for each cell.\n *\n * @param {NeighborSearchIndex} x The pre-build neighbor search index from `buildNeighborSearchIndex()`.\n * @param {number} k Number of neighbors to find.\n *\n * @return A `NeighborSearchResults` object containing the search results.\n */\nexport function findNearestNeighbors(x, k) {\n    var raw;\n    var output;\n\n    try {\n        raw = wasm.call(module => module.find_nearest_neighbors(x.index, k));\n        output = new NeighborSearchResults(raw);\n    } catch (e) {\n        utils.free(raw);\n        throw e;\n    }\n\n    return output;\n}\n","import { WasmArray, \n         Int8WasmArray,  Uint8WasmArray, \n         Int16WasmArray, Uint16WasmArray,\n         Int32WasmArray, Uint32WasmArray,\n         Float32WasmArray, Float64WasmArray } from \"./WasmArray.js\";\n\nexport function wasmifyArray(x, expected) {\n    if (x instanceof WasmArray) {\n        if (expected !== null && expected != x.constructor.className) {\n            throw \"expected '\" + expected + \"', got '\" + x.constructor.className + \"'\";\n        }\n        if (x.owner) {\n            return new x.constructor(x.length, x.offset); // when offset is supplied, this is a view.\n        } else {\n            return x; // it's already a view, so we just pass it along.\n        }\n    }\n\n    if (expected === null) {\n        if (ArrayBuffer.isView(x)) {\n            expected = x.constructor.name.replace(\"Array\", \"WasmArray\");\n        } else {\n            expected = \"Float64WasmArray\";\n        }\n    }\n\n    let y = null;\n    try {\n        switch (expected) {\n            case \"Uint8WasmArray\":\n                y = new Uint8WasmArray(x.length);\n                break;\n            case \"Int8WasmArray\":\n                y = new Int8WasmArray(x.length);\n                break;\n            case \"Uint16WasmArray\":\n                y = new Uint16WasmArray(x.length);\n                break;\n            case \"Int16WasmArray\":\n                y = new Int16WasmArray(x.length);\n                break;\n            case \"Uint32WasmArray\":\n                y = new Uint32WasmArray(x.length);\n                break;\n            case \"Int32WasmArray\":\n                y = new Int32WasmArray(x.length);\n                break;\n            case \"Float32WasmArray\":\n                y = new Float32WasmArray(x.length);\n                break;\n            case \"BigInt64WasmArray\":\n            case \"BigUint64WasmArray\":\n            case \"Float64WasmArray\":\n                y = new Float64WasmArray(x.length); // no HEAP64 as of time of writing.\n                break;\n            default:\n                throw \"unknown expected type '\" + expected + \"'\";\n        }\n\n        if (expected.startsWith(\"BigInt\") || expected.startsWith(\"BigUint\")) {\n            // Needs an explicit cast.\n            var v = y.array();\n            expected.forEach((x, i) => { v[i] = Number(x) });\n        } else {\n            y.set(x);\n        }\n    } catch(e) {\n        if (y !== null) {\n            y.free();\n        }\n        throw e;\n    }\n\n    return y;\n}\n\nexport function free(x) {\n    if (x !== null && x !== undefined) {\n        if (\"free\" in x) {\n            x.free();\n        } else if (\"delete\" in x) {\n            x.delete(); // i.e., one of the raw C++ classes.\n        }\n    }\n}\n\nexport function extractXY(ncells, coordinates) {\n    let x = new Float64Array(ncells);\n    let y = new Float64Array(ncells);\n\n    for (var i = 0; i < ncells; i++) {\n        x[i] = coordinates[2 * i];\n        y[i] = coordinates[2 * i + 1];\n    }\n\n    return { \"x\": x, \"y\": y };\n}\n\nexport function possibleCopy(x, copy) {\n    if (copy) {\n        return x.slice();\n    } else {\n        return x;\n    }\n}\n"],"names":["NeighborSearchIndex","raw","this","index","num_obs","delete","NeighborSearchResults","results","size","runs","indices","distances","copy","run_data","ind_data","dist_data","output","Int32WasmArray","numberOfCells","s","Float64WasmArray","serialize","offset","slice","utils","wasm","module","NeighborResults","length","e","findNearestNeighbors","x","k","find_nearest_neighbors","wasmifyArray","expected","WasmArray","constructor","className","owner","ArrayBuffer","isView","name","replace","y","Uint8WasmArray","Int8WasmArray","Uint16WasmArray","Int16WasmArray","Uint32WasmArray","Float32WasmArray","startsWith","v","array","forEach","i","Number","set","free","undefined","extractXY","ncells","coordinates","Float64Array"],"sourceRoot":""}