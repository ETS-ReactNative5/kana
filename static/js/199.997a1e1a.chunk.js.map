{"version":3,"file":"static/js/199.997a1e1a.chunk.js","mappings":"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","sources":["../node_modules/@babel/runtime/regenerator/index.js","../node_modules/h5wasm/dist/esm/hdf5_hl.js","../node_modules/scran.js/module/findNearestNeighbors.js","../node_modules/scran.js/module/utils.js"],"sourcesContent":["module.exports = require(\"regenerator-runtime\");\n","import { default as ModuleFactory } from './hdf5_util.js';\nexport var Module; //: H5WasmModule = null;\nexport default Module;\nexport var FS = null;\nconst ready = ModuleFactory({ noInitialRun: true }).then(result => { Module = result; FS = Module.FS; });\nexport { ready };\nexport const ACCESS_MODES = {\n    \"r\": \"H5F_ACC_RDONLY\",\n    \"a\": \"H5F_ACC_RDWR\",\n    \"w\": \"H5F_ACC_TRUNC\",\n    \"x\": \"H5F_ACC_EXCL\",\n    \"c\": \"H5F_ACC_CREAT\",\n    \"Sw\": \"H5F_ACC_SWMR_WRITE\",\n    \"Sr\": \"H5F_ACC_SWMR_READ\"\n};\nfunction normalizePath(path) {\n    if (path == \"/\") {\n        return path;\n    }\n    // replace multiple path separators with single\n    path = path.replace(/\\/(\\/)+/g, '/');\n    // strip end slashes\n    path = path.replace(/(\\/)+$/, '');\n    return path;\n}\nclass Attribute {\n    constructor(file_id, path, name) {\n        this._file_id = file_id;\n        this._path = path;\n        this._name = name;\n    }\n    get value() {\n        return get_attr(this._file_id, this._path, this._name);\n    }\n}\nfunction get_attr(file_id, obj_name, attr_name) {\n    let metadata = Module.get_attribute_metadata(file_id, obj_name, attr_name);\n    let nbytes = metadata.size * metadata.total_size;\n    let data_ptr = Module._malloc(nbytes);\n    var processed;\n    try {\n        Module.get_attribute_data(file_id, obj_name, attr_name, BigInt(data_ptr));\n        let data = Module.HEAPU8.slice(data_ptr, data_ptr + nbytes);\n        processed = process_data(data, metadata);\n    }\n    finally {\n        if (metadata.vlen) {\n            Module.reclaim_vlen_memory(file_id, obj_name, attr_name, BigInt(data_ptr));\n        }\n        Module._free(data_ptr);\n    }\n    return processed;\n}\nfunction process_data(data, metadata) {\n    // (for data coming out of Module)\n    // If an appropriate TypedArray container can be constructed, it will\n    // but otherwise returns Uint8Array raw bytes as loaded.\n    if (metadata.type == Module.H5T_class_t.H5T_STRING.value) {\n        if (metadata.vlen) {\n            let output = [];\n            let reader = (metadata.cset == 1) ? Module.UTF8ToString : Module.AsciiToString;\n            let ptrs = new Uint32Array(data.buffer);\n            for (let ptr of ptrs) {\n                output.push(reader(ptr));\n            }\n            data = output;\n        }\n        else {\n            let encoding = (metadata.cset == 1) ? 'utf-8' : 'ascii';\n            let decoder = new TextDecoder(encoding);\n            let size = metadata.size;\n            let n = Math.floor(data.byteLength / size);\n            let output = [];\n            for (let i = 0; i < n; i++) {\n                let s = data.slice(i * size, (i + 1) * size);\n                output.push(decoder.decode(s).replace(/\\u0000+$/, ''));\n            }\n            data = output;\n        }\n    }\n    else if (metadata.type == Module.H5T_class_t.H5T_INTEGER.value) {\n        let accessor_name = (metadata.size > 4) ? \"Big\" : \"\";\n        accessor_name += (metadata.signed) ? \"Int\" : \"Uint\";\n        accessor_name += ((metadata.size) * 8).toFixed() + \"Array\";\n        if (accessor_name in globalThis) {\n            data = new globalThis[accessor_name](data.buffer);\n        }\n    }\n    else if (metadata.type == Module.H5T_class_t.H5T_FLOAT.value) {\n        let accessor_name = \"Float\" + ((metadata.size) * 8).toFixed() + \"Array\";\n        if (accessor_name in globalThis) {\n            data = new globalThis[accessor_name](data.buffer);\n        }\n    }\n    else if (metadata.type == Module.H5T_class_t.H5T_COMPOUND.value) {\n        let n = Math.floor(data.byteLength / metadata.size);\n        let size = metadata.size;\n        let output = [];\n        for (let i = 0; i < n; i++) {\n            let row = [];\n            let row_data = data.slice(i * size, (i + 1) * size);\n            for (let member of metadata.compound_type.members) {\n                let member_data = row_data.slice(member.offset, member.offset + member.size);\n                row.push(process_data(member_data, member));\n            }\n            output.push(row);\n        }\n        data = output;\n    }\n    else if (metadata.type == Module.H5T_class_t.H5T_ARRAY.value) {\n        data = process_data(data, metadata.array_type);\n    }\n    return ((!metadata.shape || metadata.shape.length == 0) && data.length == 1) ? data[0] : data;\n}\nfunction prepare_data(data, metadata, shape = null) {\n    // for data being sent to Module\n    // set shape to size of array if it is not specified:\n    if (shape == null) {\n        if (data != null && data.length != null && !(typeof data === 'string')) {\n            shape = [data.length];\n        }\n        else {\n            shape = [];\n        }\n    }\n    data = (Array.isArray(data) || ArrayBuffer.isView(data)) ? data : [data];\n    let total_size = shape.reduce((previous, current) => current * previous, 1);\n    if (data.length != total_size) {\n        throw `Error: shape ${shape} does not match number of elements in data`;\n    }\n    //assert(data.length == total_size)\n    var output;\n    if (metadata.type == Module.H5T_class_t.H5T_STRING.value) {\n        if (!metadata.vlen) {\n            output = new Uint8Array(total_size * metadata.size);\n            let encoder = new TextEncoder();\n            output.fill(0);\n            let offset = 0;\n            for (let s of data) {\n                let encoded = encoder.encode(s);\n                output.set(encoded.slice(0, metadata.size), offset);\n                offset += metadata.size;\n            }\n        }\n        else {\n            output = data;\n        }\n    }\n    else if (metadata.type == Module.H5T_class_t.H5T_INTEGER.value) {\n        let accessor_name = (metadata.size > 4) ? \"Big\" : \"\";\n        accessor_name += (metadata.signed) ? \"Int\" : \"Uint\";\n        accessor_name += ((metadata.size) * 8).toFixed() + \"Array\";\n        // check to see if data is already in the right form:\n        let accessor = globalThis[accessor_name];\n        let typed_array;\n        if (data instanceof accessor) {\n            typed_array = data;\n        }\n        else {\n            // convert...\n            if (metadata.size > 4) {\n                data = data.map(BigInt);\n            }\n            typed_array = new accessor(data);\n        }\n        output = new Uint8Array(typed_array.buffer);\n    }\n    else if (metadata.type == Module.H5T_class_t.H5T_FLOAT.value) {\n        let accessor_name = \"Float\" + ((metadata.size) * 8).toFixed() + \"Array\";\n        // check to see if data is already in the right form:\n        let accessor = globalThis[accessor_name];\n        let typed_array = (data instanceof accessor) ? data : new accessor(data);\n        output = new Uint8Array(typed_array.buffer);\n    }\n    return [output, shape];\n}\nfunction map_reverse(map) {\n    return new Map(Array.from(map.entries()).map(([k, v]) => [v, k]));\n}\nconst int_fmts = new Map([[1, 'b'], [2, 'h'], [4, 'i'], [8, 'q']]);\nconst float_fmts = new Map([[2, 'e'], [4, 'f'], [8, 'd']]);\nconst fmts_float = map_reverse(float_fmts);\nconst fmts_int = map_reverse(int_fmts);\nfunction metadata_to_dtype(metadata) {\n    if (metadata.type == Module.H5T_class_t.H5T_STRING.value) {\n        let length_str = metadata.vlen ? \"\" : String(metadata.size);\n        return `S${length_str}`;\n    }\n    else if (metadata.type == Module.H5T_class_t.H5T_INTEGER.value) {\n        let fmt = int_fmts.get(metadata.size);\n        if (!metadata.signed) {\n            fmt = fmt.toUpperCase();\n        }\n        return ((metadata.littleEndian) ? \"<\" : \">\") + fmt;\n    }\n    else if (metadata.type == Module.H5T_class_t.H5T_FLOAT.value) {\n        let fmt = float_fmts.get(metadata.size);\n        return ((metadata.littleEndian) ? \"<\" : \">\") + fmt;\n    }\n    else if (metadata.type == Module.H5T_class_t.H5T_COMPOUND.value) {\n        return { compound: metadata.compound_type };\n    }\n    else {\n        return \"unknown\";\n    }\n}\nfunction dtype_to_metadata(dtype_str) {\n    let match = dtype_str.match(/^([<>|]?)([bhiqefdsBHIQS])([0-9]*)$/);\n    if (match == null) {\n        throw dtype_str + \" is not a recognized dtype\";\n    }\n    let [full, endianness, typestr, length] = match;\n    let metadata = { vlen: false, signed: false };\n    metadata.littleEndian = (endianness != '>');\n    if (fmts_int.has(typestr.toLowerCase())) {\n        metadata.type = Module.H5T_class_t.H5T_INTEGER.value;\n        metadata.size = fmts_int.get(typestr.toLowerCase());\n        metadata.signed = (typestr.toLowerCase() == typestr);\n    }\n    else if (fmts_float.has(typestr)) {\n        metadata.type = Module.H5T_class_t.H5T_FLOAT.value;\n        metadata.size = fmts_float.get(typestr);\n    }\n    else if (typestr.toUpperCase() == 'S') {\n        metadata.type = Module.H5T_class_t.H5T_STRING.value;\n        metadata.size = (length == \"\") ? 4 : parseInt(length, 10);\n        metadata.vlen = (length == \"\");\n    }\n    else {\n        throw \"should never happen\";\n    }\n    return metadata;\n}\nconst TypedArray_to_dtype = new Map([\n    ['Uint8Array', '<B'],\n    ['Uint16Array', '<H'],\n    ['Uint32Array', '<I'],\n    ['BigUint64Array', '<Q'],\n    ['Int8Array', '<b'],\n    ['Int16Array', '<h'],\n    ['Int32Array', '<i'],\n    ['BigInt64Array', '<q'],\n    ['Float32Array', '<f'],\n    ['Float64Array', '<d']\n]);\nfunction guess_dtype(data) {\n    if (ArrayBuffer.isView(data) && !(data instanceof DataView)) {\n        return TypedArray_to_dtype.get(data.constructor.name);\n    }\n    data = ((Array.isArray(data)) ? data : [data]);\n    if (data.every(Number.isInteger)) {\n        return '<i'; // default integer type: Int32\n    }\n    else if (data.every((d) => (typeof d == 'number'))) {\n        return '<d'; // default float type: Float64\n    }\n    else if (data.every((d) => (typeof d == 'string'))) {\n        return 'S';\n    }\n    else {\n        throw \"unguessable type for data\";\n    }\n}\nvar OBJECT_TYPE;\n(function (OBJECT_TYPE) {\n    OBJECT_TYPE[\"DATASET\"] = \"Dataset\";\n    OBJECT_TYPE[\"GROUP\"] = \"Group\";\n})(OBJECT_TYPE || (OBJECT_TYPE = {}));\nclass HasAttrs {\n    get attrs() {\n        let attr_names = Module.get_attribute_names(this.file_id, this.path);\n        let attrs = {};\n        for (let name of attr_names) {\n            let metadata = Module.get_attribute_metadata(this.file_id, this.path, name);\n            Object.defineProperty(attrs, name, {\n                get: () => ({\n                    value: get_attr(this.file_id, this.path, name),\n                    shape: metadata.shape,\n                    dtype: metadata_to_dtype(metadata)\n                }),\n                enumerable: true\n            });\n            //attrs[name] = get_attr(this.file_id, this.path, name);\n        }\n        return attrs;\n    }\n    get_attribute(name) {\n        get_attr(this.file_id, this.path, name);\n    }\n    create_attribute(name, data, shape = null, dtype = null) {\n        var dtype = dtype ?? guess_dtype(data);\n        let metadata = dtype_to_metadata(dtype);\n        let [prepared_data, guessed_shape] = prepare_data(data, metadata, shape);\n        var shape = shape ?? guessed_shape;\n        if (metadata.vlen) {\n            Module.create_vlen_str_attribute(this.file_id, this.path, name, prepared_data, shape.map(BigInt), metadata.type, metadata.size, metadata.signed, metadata.vlen);\n        }\n        else {\n            let data_ptr = Module._malloc(prepared_data.byteLength);\n            try {\n                Module.HEAPU8.set(prepared_data, data_ptr);\n                Module.create_attribute(this.file_id, this.path, name, BigInt(data_ptr), shape.map(BigInt), metadata.type, metadata.size, metadata.signed, metadata.vlen);\n            }\n            finally {\n                Module._free(data_ptr);\n            }\n        }\n    }\n}\nexport class Group extends HasAttrs {\n    constructor(file_id, path) {\n        super();\n        this.path = path;\n        this.file_id = file_id;\n        this.type = OBJECT_TYPE.GROUP;\n    }\n    keys() {\n        return Module.get_names(this.file_id, this.path);\n    }\n    *values() {\n        for (let name of this.keys()) {\n            yield this.get(name);\n        }\n        return;\n    }\n    *items() {\n        for (let name of this.keys()) {\n            yield [name, this.get(name)];\n        }\n        return;\n    }\n    get_type(obj_path) {\n        return Module.get_type(this.file_id, obj_path);\n    }\n    get(obj_name) {\n        let fullpath = (/^\\//.test(obj_name)) ? obj_name : this.path + \"/\" + obj_name;\n        fullpath = normalizePath(fullpath);\n        let type = this.get_type(fullpath);\n        if (type == Module.H5O_TYPE_GROUP) {\n            return new Group(this.file_id, fullpath);\n        }\n        else if (type == Module.H5O_TYPE_DATASET) {\n            return new Dataset(this.file_id, fullpath);\n        }\n    }\n    create_group(name) {\n        Module.create_group(this.file_id, this.path + \"/\" + name);\n        return this.get(name);\n    }\n    create_dataset(name, data, shape = null, dtype = null) {\n        var dtype = dtype ?? guess_dtype(data);\n        let metadata = dtype_to_metadata(dtype);\n        let [prepared_data, guessed_shape] = prepare_data(data, metadata, shape);\n        shape = shape ?? guessed_shape;\n        if (metadata.vlen) {\n            Module.create_vlen_str_dataset(this.file_id, this.path + \"/\" + name, prepared_data, shape.map(BigInt), metadata.type, metadata.size, metadata.signed, metadata.vlen);\n        }\n        else {\n            let data_ptr = Module._malloc(prepared_data.byteLength);\n            try {\n                Module.HEAPU8.set(prepared_data, data_ptr);\n                Module.create_dataset(this.file_id, this.path + \"/\" + name, BigInt(data_ptr), shape.map(BigInt), metadata.type, metadata.size, metadata.signed, metadata.vlen);\n            }\n            finally {\n                Module._free(data_ptr);\n            }\n        }\n        return this.get(name);\n    }\n    toString() {\n        return `Group(file_id=${this.file_id}, path=${this.path})`;\n    }\n}\nexport class File extends Group {\n    constructor(filename, mode = \"r\") {\n        super(null, \"/\");\n        let access_mode = ACCESS_MODES[mode];\n        let h5_mode = Module[access_mode];\n        if (['H5F_ACC_RDWR', 'H5F_ACC_RDONLY'].includes(access_mode)) {\n            // then it's an existing file...\n            this.file_id = Module.ccall(\"H5Fopen\", \"bigint\", [\"string\", \"number\", \"bigint\"], [filename, h5_mode, 0n]);\n        }\n        else {\n            this.file_id = Module.ccall(\"H5Fcreate\", \"bigint\", [\"string\", \"number\", \"bigint\", \"bigint\"], [filename, h5_mode, 0n, 0n]);\n        }\n        this.filename = filename;\n        this.mode = mode;\n    }\n    flush() {\n        Module.flush(this.file_id);\n    }\n    close() {\n        return Module.ccall(\"H5Fclose\", \"number\", [\"bigint\"], [this.file_id]);\n    }\n}\nexport class Dataset extends HasAttrs {\n    constructor(file_id, path) {\n        super();\n        this.path = path;\n        this.file_id = file_id;\n        this.type = OBJECT_TYPE.DATASET;\n    }\n    get metadata() {\n        return Module.get_dataset_metadata(this.file_id, this.path);\n    }\n    get dtype() {\n        return metadata_to_dtype(this.metadata);\n    }\n    get shape() {\n        return this.metadata.shape;\n    }\n    get value() {\n        let metadata = this.metadata;\n        let nbytes = metadata.size * metadata.total_size;\n        let data_ptr = Module._malloc(nbytes);\n        var processed;\n        try {\n            Module.get_dataset_data(this.file_id, this.path, null, null, BigInt(data_ptr));\n            let data = Module.HEAPU8.slice(data_ptr, data_ptr + nbytes);\n            processed = process_data(data, metadata);\n        }\n        finally {\n            if (metadata.vlen) {\n                Module.reclaim_vlen_memory(this.file_id, this.path, \"\", BigInt(data_ptr));\n            }\n            Module._free(data_ptr);\n        }\n        return processed;\n    }\n    slice(ranges) {\n        // interpret ranges as [start, stop], with one per dim.\n        let metadata = this.metadata;\n        let shape = metadata.shape;\n        let ndims = shape.length;\n        let count = shape.map((s, i) => BigInt(Math.min(s, ranges?.[i]?.[1] ?? s) - Math.max(0, ranges?.[i]?.[0] ?? 0)));\n        let offset = shape.map((s, i) => BigInt(Math.min(s, Math.max(0, ranges?.[i]?.[0] ?? 0))));\n        // console.log(count, offset);\n        let total_size = count.reduce((previous, current) => current * previous, 1n);\n        let nbytes = metadata.size * Number(total_size);\n        let data_ptr = Module._malloc(nbytes);\n        var processed;\n        try {\n            Module.get_dataset_data(this.file_id, this.path, count, offset, BigInt(data_ptr));\n            let data = Module.HEAPU8.slice(data_ptr, data_ptr + nbytes);\n            processed = process_data(data, metadata);\n        }\n        finally {\n            if (metadata.vlen) {\n                Module.reclaim_vlen_memory(this.file_id, this.path, \"\", BigInt(data_ptr));\n            }\n            Module._free(data_ptr);\n        }\n        return processed;\n    }\n}\n","import * as utils from \"./utils.js\";\nimport * as wasm from \"./wasm.js\";\nimport { Int32WasmArray, Float64WasmArray } from \"./WasmArray.js\";\nimport { PCAResults } from \"./runPCA.js\";\n\n/** \n * Wrapper for the neighbor search index on the Wasm heap.\n */\nexport class NeighborSearchIndex {\n    /**\n     * @param {Object} raw Search index on the Wasm heap.\n     *\n     * Not to be called directly by developers;\n     * use `buildNeighborSearchIndex()` instead.\n     */\n    constructor(raw) {\n        this.index = raw;\n        return;\n    }\n\n    /**\n     * @return Number of cells in the index.\n     */\n    numberOfCells() {\n        return this.index.num_obs();\n    }\n\n    /**\n     * @return Frees the memory allocated on the Wasm heap for this object.\n     * This invalidates this object and all references to it.\n     */\n    free() {\n        this.index.delete();\n        this.index = null;\n        return;\n    }\n}\n\n/**\n * Build the nearest neighbor search index.\n *\n * @param {(PCAResults|Float64WasmArray|Array|TypedArray)} x - Numeric coordinates of each cell in the dataset.\n * For array inputs, this is expected to be in column-major format where the rows are the variables and the columns are the cells.\n * For a `PCAResults` input, we extract the principal components.\n * @param {Object} [options] - Optional parameters.\n * @param {number} [options.numberOfDims] - Number of variables/dimensions per cell.\n * Only used (and required) for array-like `x`.\n * @param {number} [options.numberOfCells] - Number of cells.\n * Only used (and required) for array-like `x`.\n * @param {boolean} [options.approximate] - Whether to build an index for an approximate neighbor search.\n *\n * @return A `NeighborSearchIndex` object to use for neighbor searches.\n */\nexport function buildNeighborSearchIndex(x, { numberOfDims = null, numberOfCells = null, approximate = true } = {}) {\n    var buffer;\n    var raw;\n    var output;\n\n    try {\n        let pptr;\n\n        if (x instanceof PCAResults) {\n            numberOfDims = x.numberOfPCs();\n            numberOfCells = x.numberOfCells();\n            let pcs = x.principalComponents({ copy: false });\n            pptr = pcs.byteOffset;\n\n        } else {\n            if (numberOfDims === null || numberOfCells === null) {\n                throw \"'numberOfDims' and 'numberOfCells' must be specified when 'x' is an Array\";\n            }\n\n            buffer = utils.wasmifyArray(x, \"Float64WasmArray\");\n            if (buffer.length != numberOfDims * numberOfCells) {\n                throw \"length of 'x' must be the product of 'numberOfDims' and 'numberOfCells'\";\n            }\n\n            pptr = buffer.offset;\n        }\n\n        raw = wasm.call(module => module.build_neighbor_index(pptr, numberOfDims, numberOfCells, approximate)); \n        output = new NeighborSearchIndex(raw);\n\n    } catch (e) {\n        utils.free(raw);\n        throw e;\n\n    } finally {\n        utils.free(buffer);\n    }\n\n    return output;\n}\n\n/** \n * Wrapper for the neighbor search results on the Wasm heap.\n */\nexport class NeighborSearchResults {\n    /**\n     * @param {Object} raw Search results on the Wasm heap.\n     *\n     * Not to be called directly by developers;\n     * use `findNearestNeighbors()` or `unserialize()` instead.\n     */\n    constructor(raw) {\n        this.results = raw;\n        return;\n    }\n\n    /**\n     * @return The total number of neighbors across all cells.\n     * This is usually the product of the number of neighbors and the number of cells.\n     */\n    size() {\n        return this.results.size();\n    }\n\n    /**\n     * @return The number of cells used in the search.\n     */\n    numberOfCells() {\n        return this.results.num_obs();\n    }\n\n    /**\n     * @param {Object} [options] - Optional parameters.\n     * @param {?Int32WasmArray} [options.runs] - A Wasm-allocated array of length equal to `numberOfCells()`,\n     * to be used to store the number of neighbors per cell.\n     * @param {?Int32WasmArray} [options.indices] - A Wasm-allocated array of length equal to `size()`,\n     * to be used to store the indices of the neighbors of each cell.\n     * @param {?Float64WasmArray} [options.distances] - A Wasm-allocated array of length equal to `size()`,\n     * to be used to store the distances to the neighbors of each cell.\n     *\n     * @return \n     * If all of the arguments are non-`null`, the buffers in `runs`, `indices` and `distances` are filled with their respective contents, and nothing is returned.\n     * If all of the arguments are `null`, a object is returned with `TypedArray` entries for each component.\n     * Otherwise, an error is raised.\n     */\n    serialize({ runs = null, indices = null, distances = null } = {}) {\n        var copy = (runs === null) + (indices === null) + (distances === null);\n        if (copy != 3 && copy != 0) {\n            throw \"either all or none of 'runs', 'indices' and 'distances' can be 'null'\";\n        }\n\n        if (copy === 3) {\n            var run_data;\n            var ind_data;\n            var dist_data;\n            var output;\n            \n            try {\n                run_data = new Int32WasmArray(this.numberOfCells());\n                let s = this.size();\n                ind_data = new Int32WasmArray(s);\n                dist_data = new Float64WasmArray(s);\n                this.results.serialize(run_data.offset, ind_data.offset, dist_data.offset);\n\n                output = { \n                    \"runs\": run_data.slice(), \n                    \"indices\": ind_data.slice(), \n                    \"distances\": dist_data.slice() \n                };\n            } finally {\n                utils.free(run_data);\n                utils.free(ind_data);\n                utils.free(dist_data);\n            }\n\n            return output;\n        } else {\n            this.results.serialize(runs.offset, indices.offset, distances.offset);\n        }\n    }\n\n    /**\n     * @param {Int32WasmArray|Array|TypedArray} runs An array of length equal to `numberOfCells()`,\n     * containing the number of neighbors per cell.\n     * @param {Int32WasmArray|Array|TypedArray} indices An array of length equal to `size()`,\n     * containing the indices of the neighbors of each cell.\n     * @param {Float64WasmArray|Array|TypedArray} indices An array of length equal to `size()`,\n     * containing the distances to the neighbors of each cell.\n     *\n     * @return A new `NeighborSearchResults` object containing the unserialized search results.\n     */\n    static unserialize(runs, indices, distances) {\n        var raw;\n        var output;\n        var run_data;\n        var ind_data;\n        var dist_data;\n\n        try {\n            run_data = utils.wasmifyArray(runs, \"Int32WasmArray\");\n            ind_data = utils.wasmifyArray(indices, \"Int32WasmArray\");\n            dist_data = utils.wasmifyArray(distances, \"Float64WasmArray\");\n            raw = wasm.call(module => new module.NeighborResults(runs.length, run_data.offset, ind_data.offset, dist_data.offset));\n            output = new NeighborSearchResults(raw);\n        } catch (e) {\n            utils.free(raw);\n            throw e;\n        } finally { \n            utils.free(run_data);\n            utils.free(ind_data);\n            utils.free(dist_data);\n        }\n\n        return output;\n    }\n\n    /**\n     * @return Frees the memory allocated on the Wasm heap for this object.\n     * This invalidates this object and all references to it.\n     */\n    free() {\n        this.results.delete();\n        this.results = null;\n        return;\n    }\n}\n\n/**\n * Find the nearest neighbors for each cell.\n *\n * @param {NeighborSearchIndex} x The pre-build neighbor search index from `buildNeighborSearchIndex()`.\n * @param {number} k Number of neighbors to find.\n *\n * @return A `NeighborSearchResults` object containing the search results.\n */\nexport function findNearestNeighbors(x, k) {\n    var raw;\n    var output;\n\n    try {\n        raw = wasm.call(module => module.find_nearest_neighbors(x.index, k));\n        output = new NeighborSearchResults(raw);\n    } catch (e) {\n        utils.free(raw);\n        throw e;\n    }\n\n    return output;\n}\n","import { WasmArray, \n         Int8WasmArray,  Uint8WasmArray, \n         Int16WasmArray, Uint16WasmArray,\n         Int32WasmArray, Uint32WasmArray,\n         Float32WasmArray, Float64WasmArray } from \"./WasmArray.js\";\nimport { buffer } from \"./wasm.js\";\n\nexport function wasmifyArray(x, expected) {\n    if (x instanceof WasmArray) {\n        if (expected !== null && expected != x.constructor.className) {\n            throw \"expected '\" + expected + \"', got '\" + x.constructor.className + \"'\";\n        }\n        if (x.owner) {\n            return new x.constructor(x.length, x.offset); // when offset is supplied, this is a view.\n        } else {\n            return x; // it's already a view, so we just pass it along.\n        }\n    }\n\n    if (expected === null) {\n        if (ArrayBuffer.isView(x)) {\n            expected = x.constructor.name.replace(\"Array\", \"WasmArray\");\n        } else {\n            expected = \"Float64WasmArray\";\n        }\n    }\n\n    let y = null;\n    try {\n        switch (expected) {\n            case \"Uint8WasmArray\":\n                y = new Uint8WasmArray(x.length);\n                break;\n            case \"Int8WasmArray\":\n                y = new Int8WasmArray(x.length);\n                break;\n            case \"Uint16WasmArray\":\n                y = new Uint16WasmArray(x.length);\n                break;\n            case \"Int16WasmArray\":\n                y = new Int16WasmArray(x.length);\n                break;\n            case \"Uint32WasmArray\":\n                y = new Uint32WasmArray(x.length);\n                break;\n            case \"Int32WasmArray\":\n                y = new Int32WasmArray(x.length);\n                break;\n            case \"Float32WasmArray\":\n                y = new Float32WasmArray(x.length);\n                break;\n            case \"BigInt64WasmArray\":\n            case \"BigUint64WasmArray\":\n            case \"Float64WasmArray\":\n                y = new Float64WasmArray(x.length); // no HEAP64 as of time of writing.\n                break;\n            default:\n                throw \"unknown expected type '\" + expected + \"'\";\n        }\n\n        if (ArrayBuffer.isView(x) && (x.constructor.name.startsWith(\"BigInt\") || x.constructor.name.startsWith(\"BigUint\"))) {\n            // Needs an explicit cast.\n            var v = y.array();\n            x.forEach((n, i) => { v[i] = Number(n); });\n        } else {\n            y.set(x);\n        }\n    } catch(e) {\n        if (y !== null) {\n            y.free();\n        }\n        throw e;\n    }\n\n    return y;\n}\n\nexport function free(x) {\n    if (x !== null && x !== undefined) {\n        if (\"free\" in x) {\n            x.free();\n        } else if (\"delete\" in x) {\n            x.delete(); // i.e., one of the raw C++ classes.\n        }\n    }\n}\n\nexport function extractXY(ncells, coordinates) {\n    let x = new Float64Array(ncells);\n    let y = new Float64Array(ncells);\n\n    for (var i = 0; i < ncells; i++) {\n        x[i] = coordinates[2 * i];\n        y[i] = coordinates[2 * i + 1];\n    }\n\n    return { \"x\": x, \"y\": y };\n}\n\nexport function possibleCopy(x, copy) {\n    if (copy === \"view\") {\n        if (x.buffer !== buffer()) {\n            throw \"cannot use copy = \\\"WasmArray\\\" for non-Wasm TypedArrays\";\n        }\n\n        let y;\n        switch (x.constructor.name) {\n            case \"Uint8Array\":\n                y = new Uint8WasmArray(x.length, x.byteOffset);\n                break;\n            case \"Int8Array\":\n                y = new Int8WasmArray(x.length, x.byteOffset);\n                break;\n            case \"Uint16Array\":\n                y = new Uint16WasmArray(x.length, x.byteOffset);\n                break;\n            case \"Int16Array\":\n                y = new Int16WasmArray(x.length, x.byteOffset);\n                break;\n            case \"Uint32Array\":\n                y = new Uint32WasmArray(x.length, x.byteOffset);\n                break;\n            case \"Int32Array\":\n                y = new Int32WasmArray(x.length, x.byteOffset);\n                break;\n            case \"Float32Array\":\n                y = new Float32WasmArray(x.length, x.byteOffset);\n                break;\n            case \"Float64Array\":\n                y = new Float64WasmArray(x.length, x.byteOffset); \n                break;\n            default:\n                throw \"unknown expected type '\" + x.constructor.name + \"'\";\n        }\n        y.set(x);\n        return y;\n\n    } else if (copy) {\n        return x.slice();\n\n    } else {\n        return x;\n    }\n}\n"],"names":["module","exports","ready","ModuleFactory","noInitialRun","then","result","FS","map_reverse","map","Map","Array","from","entries","k","int_fmts","float_fmts","OBJECT_TYPE","NeighborSearchIndex","raw","this","index","num_obs","delete","NeighborSearchResults","results","size","runs","indices","distances","copy","run_data","ind_data","dist_data","output","Int32WasmArray","numberOfCells","s","Float64WasmArray","serialize","offset","slice","utils","wasm","NeighborResults","length","e","findNearestNeighbors","x","find_nearest_neighbors","wasmifyArray","expected","WasmArray","constructor","className","owner","ArrayBuffer","isView","name","replace","y","Uint8WasmArray","Int8WasmArray","Uint16WasmArray","Int16WasmArray","Uint32WasmArray","Float32WasmArray","startsWith","v","array","forEach","n","i","Number","set","free","undefined","extractXY","ncells","coordinates","Float64Array"],"sourceRoot":""}