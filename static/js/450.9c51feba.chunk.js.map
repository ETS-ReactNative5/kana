{"version":3,"file":"static/js/450.9c51feba.chunk.js","mappings":"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GACA,GACA,GACA,GACA,GACA,GACA,GACA,GACA,GACA,GACA,GACA,GACA,IACA,IACA,IACA,IACA,IACA,IACA,EACA,IAEEuH,GAAO,IAAI3c,WAAW,CACxB,GACA,GACA,GACA,GACA,GACA,GACA,GACA,GACA,GACA,GACA,GACA,GACA,GACA,GACA,GACA,GACA,GACA,GACA,GACA,GACA,GACA,GACA,GACA,GACA,GACA,GACA,GACA,GACA,GACA,GACA,KAEE4c,GAAQ,IAAIxH,YAAY,CAC1B,EACA,EACA,EACA,EACA,EACA,EACA,EACA,GACA,GACA,GACA,GACA,GACA,GACA,GACA,IACA,IACA,IACA,IACA,IACA,IACA,KACA,KACA,KACA,KACA,KACA,KACA,KACA,MACA,MACA,MACA,EACA,IAEEyH,GAAO,IAAI7c,WAAW,CACxB,GACA,GACA,GACA,GACA,GACA,GACA,GACA,GACA,GACA,GACA,GACA,GACA,GACA,GACA,GACA,GACA,GACA,GACA,GACA,GACA,GACA,GACA,GACA,GACA,GACA,GACA,GACA,GACA,GACA,GACA,GACA,KAsKE8c,GApKgB,SAACC,EAAMC,EAAMC,EAAYC,EAAOzQ,EAAO0Q,EAAaC,EAAMC,GAC5E,IAUIC,EACAC,EACA7a,EACA8a,EACApG,EAGAtK,EAKA2Q,EAAWC,EAASC,EAtBlBnX,EAAO6W,EAAK7W,KACdhD,EAAM,EACNoa,EAAM,EACNC,EAAM,EAAG1E,EAAM,EACf2E,EAAO,EACPC,EAAO,EACPC,EAAO,EACP3b,EAAO,EACP4b,EAAO,EACPC,EAAO,EAMPpV,EAAO,KACPqV,EAAa,EAEX9U,EAAQ,IAAI+L,YAAYqH,IACxB2B,EAAO,IAAIhJ,YAAYqH,IACzBtU,EAAQ,KACRkW,EAAc,EAElB,IAAK7a,EAAM,EAAGA,GAAOiZ,GAASjZ,IAC5B6F,EAAM7F,GAAO,EAEf,IAAKoa,EAAM,EAAGA,EAAMV,EAAOU,IACzBvU,EAAM2T,EAAKC,EAAaW,MAG1B,IADAE,EAAOtX,EACF2S,EAAMsD,GAAStD,GAAO,GACN,IAAf9P,EAAM8P,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","sources":["../node_modules/@babel/runtime/regenerator/index.js","../node_modules/jsfive/dist/index.js","../node_modules/scran.js/module/findNearestNeighbors.js","../node_modules/scran.js/module/utils.js"],"sourcesContent":["module.exports = require(\"regenerator-runtime\");\n","// esm/core.js\nfunction _unpack_struct_from(structure, buf, offset = 0) {\n  var output = /* @__PURE__ */ new Map();\n  for (let [key, fmt] of structure.entries()) {\n    let value = struct.unpack_from(\"<\" + fmt, buf, offset);\n    offset += struct.calcsize(fmt);\n    if (value.length == 1) {\n      value = value[0];\n    }\n    ;\n    output.set(key, value);\n  }\n  return output;\n}\nfunction assert(thing) {\n  if (!thing) {\n    thing();\n  }\n}\nfunction _structure_size(structure) {\n  var fmt = \"<\" + Array.from(structure.values()).join(\"\");\n  return struct.calcsize(fmt);\n}\nfunction _padded_size(size, padding_multiple = 8) {\n  return Math.ceil(size / padding_multiple) * padding_multiple;\n}\nvar dtype_to_format = {\n  \"u\": \"Uint\",\n  \"i\": \"Int\",\n  \"f\": \"Float\"\n};\nfunction dtype_getter(dtype_str) {\n  var big_endian = struct._is_big_endian(dtype_str);\n  var getter, nbytes;\n  if (/S/.test(dtype_str)) {\n    getter = \"getString\";\n    nbytes = ((dtype_str.match(/S(\\d*)/) || [])[1] || 1) | 0;\n  } else {\n    let [_, fstr, bytestr] = dtype_str.match(/[<>=!@]?(i|u|f)(\\d*)/);\n    nbytes = parseInt(bytestr || 4, 10);\n    let nbits = nbytes * 8;\n    getter = \"get\" + dtype_to_format[fstr] + nbits.toFixed();\n  }\n  return [getter, big_endian, nbytes];\n}\nvar Struct = class {\n  constructor() {\n    this.big_endian = isBigEndian();\n    this.getters = {\n      \"s\": \"getUint8\",\n      \"b\": \"getInt8\",\n      \"B\": \"getUint8\",\n      \"h\": \"getInt16\",\n      \"H\": \"getUint16\",\n      \"i\": \"getInt32\",\n      \"I\": \"getUint32\",\n      \"l\": \"getInt32\",\n      \"L\": \"getUint32\",\n      \"q\": \"getInt64\",\n      \"Q\": \"getUint64\",\n      \"f\": \"getFloat32\",\n      \"d\": \"getFloat64\"\n    };\n    this.byte_lengths = {\n      \"s\": 1,\n      \"b\": 1,\n      \"B\": 1,\n      \"h\": 2,\n      \"H\": 2,\n      \"i\": 4,\n      \"I\": 4,\n      \"l\": 4,\n      \"L\": 4,\n      \"q\": 8,\n      \"Q\": 8,\n      \"f\": 4,\n      \"d\": 8\n    };\n    let all_formats = Object.keys(this.byte_lengths).join(\"\");\n    this.fmt_size_regex = \"(\\\\d*)([\" + all_formats + \"])\";\n  }\n  calcsize(fmt) {\n    var size = 0;\n    var match;\n    var regex = new RegExp(this.fmt_size_regex, \"g\");\n    while ((match = regex.exec(fmt)) !== null) {\n      let n = parseInt(match[1] || 1, 10);\n      let f = match[2];\n      let subsize = this.byte_lengths[f];\n      size += n * subsize;\n    }\n    return size;\n  }\n  _is_big_endian(fmt) {\n    var big_endian;\n    if (/^</.test(fmt)) {\n      big_endian = false;\n    } else if (/^(!|>)/.test(fmt)) {\n      big_endian = true;\n    } else {\n      big_endian = this.big_endian;\n    }\n    return big_endian;\n  }\n  unpack_from(fmt, buffer, offset) {\n    var offset = Number(offset || 0);\n    var view = new DataView64(buffer, 0);\n    var output = [];\n    var big_endian = this._is_big_endian(fmt);\n    var match;\n    var regex = new RegExp(this.fmt_size_regex, \"g\");\n    while ((match = regex.exec(fmt)) !== null) {\n      let n = parseInt(match[1] || 1, 10);\n      let f = match[2];\n      let getter = this.getters[f];\n      let size = this.byte_lengths[f];\n      var append_target;\n      if (f == \"s\") {\n        var sarray = new Array();\n        append_target = sarray;\n      } else {\n        append_target = output;\n      }\n      for (var i = 0; i < n; i++) {\n        append_target.push(view[getter](offset, !big_endian));\n        offset += size;\n      }\n      if (f == \"s\") {\n        output.push(sarray.reduce(function(a, b) {\n          return a + String.fromCharCode(b);\n        }, \"\"));\n      }\n    }\n    return output;\n  }\n};\nvar struct = new Struct();\nfunction isBigEndian() {\n  const array = new Uint8Array(4);\n  const view = new Uint32Array(array.buffer);\n  return !((view[0] = 1) & array[0]);\n}\nvar WARN_OVERFLOW = false;\nvar MAX_INT64 = 1n << 63n - 1n;\nvar MIN_INT64 = -1n << 63n;\nvar MAX_UINT64 = 1n << 64n;\nvar MIN_UINT64 = 0n;\nvar DataView64 = class extends DataView {\n  getUint64(byteOffset, littleEndian) {\n    const left = BigInt(this.getUint32(byteOffset, littleEndian));\n    const right = BigInt(this.getUint32(byteOffset + 4, littleEndian));\n    let combined = littleEndian ? left + (right << 32n) : (left << 32n) + right;\n    if (WARN_OVERFLOW && (combined < MIN_UINT64 || combined > MAX_UINT64)) {\n      console.warn(combined, \"exceeds range of 64-bit unsigned int\");\n    }\n    return Number(combined);\n  }\n  getInt64(byteOffset, littleEndian) {\n    var low, high;\n    if (littleEndian) {\n      low = this.getUint32(byteOffset, true);\n      high = this.getInt32(byteOffset + 4, true);\n    } else {\n      high = this.getInt32(byteOffset, false);\n      low = this.getUint32(byteOffset + 4, false);\n    }\n    let combined = BigInt(low) + (BigInt(high) << 32n);\n    if (WARN_OVERFLOW && (combined < MIN_INT64 || combined > MAX_INT64)) {\n      console.warn(combined, \"exceeds range of 64-bit signed int\");\n    }\n    return Number(combined);\n  }\n  getString(byteOffset, littleEndian, length) {\n    var output = \"\";\n    for (var i = 0; i < length; i++) {\n      let c = this.getUint8(byteOffset + i);\n      if (c) {\n        output += String.fromCharCode(c);\n      }\n    }\n    return decodeURIComponent(escape(output));\n  }\n  getVLENStruct(byteOffset, littleEndian, length) {\n    let item_size = this.getUint32(byteOffset, littleEndian);\n    let collection_address = this.getUint64(byteOffset + 4, littleEndian);\n    let object_index = this.getUint32(byteOffset + 12, littleEndian);\n    return [item_size, collection_address, object_index];\n  }\n};\nfunction bitSize(integer) {\n  return integer.toString(2).length;\n}\nfunction _unpack_integer(nbytes, fh, offset = 0, littleEndian = true) {\n  let bytes = new Uint8Array(fh.slice(offset, offset + nbytes));\n  if (!littleEndian) {\n    bytes.reverse();\n  }\n  let integer = bytes.reduce((accumulator, currentValue, index) => accumulator + (currentValue << index * 8), 0);\n  return integer;\n}\n\n// esm/datatype-msg.js\nvar DatatypeMessage = class {\n  constructor(buf, offset) {\n    this.buf = buf;\n    this.offset = offset;\n    this.dtype = this.determine_dtype();\n  }\n  determine_dtype() {\n    let datatype_msg = _unpack_struct_from(DATATYPE_MSG, this.buf, this.offset);\n    this.offset += DATATYPE_MSG_SIZE;\n    let datatype_class = datatype_msg.get(\"class_and_version\") & 15;\n    if (datatype_class == DATATYPE_FIXED_POINT) {\n      return this._determine_dtype_fixed_point(datatype_msg);\n    } else if (datatype_class == DATATYPE_FLOATING_POINT) {\n      return this._determine_dtype_floating_point(datatype_msg);\n    } else if (datatype_class == DATATYPE_TIME) {\n      throw \"Time datatype class not supported.\";\n    } else if (datatype_class == DATATYPE_STRING) {\n      return this._determine_dtype_string(datatype_msg);\n    } else if (datatype_class == DATATYPE_BITFIELD) {\n      throw \"Bitfield datatype class not supported.\";\n    } else if (datatype_class == DATATYPE_OPAQUE) {\n      throw \"Opaque datatype class not supported.\";\n    } else if (datatype_class == DATATYPE_COMPOUND) {\n      return this._determine_dtype_compound(datatype_msg);\n    } else if (datatype_class == DATATYPE_REFERENCE) {\n      return [\"REFERENCE\", datatype_msg.get(\"size\")];\n    } else if (datatype_class == DATATYPE_ENUMERATED) {\n      throw \"Enumerated datatype class not supported.\";\n    } else if (datatype_class == DATATYPE_ARRAY) {\n      throw \"Array datatype class not supported.\";\n    } else if (datatype_class == DATATYPE_VARIABLE_LENGTH) {\n      let vlen_type = this._determine_dtype_vlen(datatype_msg);\n      if (vlen_type[0] == \"VLEN_SEQUENCE\") {\n        let base_type = this.determine_dtype();\n        vlen_type = [\"VLEN_SEQUENCE\", base_type];\n      }\n      return vlen_type;\n    } else {\n      throw \"Invalid datatype class \" + datatype_class;\n    }\n  }\n  _determine_dtype_fixed_point(datatype_msg) {\n    let length_in_bytes = datatype_msg.get(\"size\");\n    if (![1, 2, 4, 8].includes(length_in_bytes)) {\n      throw \"Unsupported datatype size\";\n    }\n    let signed = datatype_msg.get(\"class_bit_field_0\") & 8;\n    var dtype_char;\n    if (signed > 0) {\n      dtype_char = \"i\";\n    } else {\n      dtype_char = \"u\";\n    }\n    let byte_order = datatype_msg.get(\"class_bit_field_0\") & 1;\n    var byte_order_char;\n    if (byte_order == 0) {\n      byte_order_char = \"<\";\n    } else {\n      byte_order_char = \">\";\n    }\n    this.offset += 4;\n    return byte_order_char + dtype_char + length_in_bytes.toFixed();\n  }\n  _determine_dtype_floating_point(datatype_msg) {\n    let length_in_bytes = datatype_msg.get(\"size\");\n    if (![1, 2, 4, 8].includes(length_in_bytes)) {\n      throw \"Unsupported datatype size\";\n    }\n    let dtype_char = \"f\";\n    let byte_order = datatype_msg.get(\"class_bit_field_0\") & 1;\n    var byte_order_char;\n    if (byte_order == 0) {\n      byte_order_char = \"<\";\n    } else {\n      byte_order_char = \">\";\n    }\n    this.offset += 12;\n    return byte_order_char + dtype_char + length_in_bytes.toFixed();\n  }\n  _determine_dtype_string(datatype_msg) {\n    return \"S\" + datatype_msg.get(\"size\").toFixed();\n  }\n  _determine_dtype_vlen(datatype_msg) {\n    let vlen_type = datatype_msg.get(\"class_bit_field_0\") & 1;\n    if (vlen_type != 1) {\n      return [\"VLEN_SEQUENCE\", 0, 0];\n    }\n    let padding_type = datatype_msg.get(\"class_bit_field_0\") >> 4;\n    let character_set = datatype_msg.get(\"class_bit_field_1\") & 1;\n    return [\"VLEN_STRING\", padding_type, character_set];\n  }\n  _determine_dtype_compound(datatype_msg) {\n    throw \"not yet implemented!\";\n  }\n};\nvar DATATYPE_MSG = /* @__PURE__ */ new Map([\n  [\"class_and_version\", \"B\"],\n  [\"class_bit_field_0\", \"B\"],\n  [\"class_bit_field_1\", \"B\"],\n  [\"class_bit_field_2\", \"B\"],\n  [\"size\", \"I\"]\n]);\nvar DATATYPE_MSG_SIZE = _structure_size(DATATYPE_MSG);\nvar COMPOUND_PROP_DESC_V1 = /* @__PURE__ */ new Map([\n  [\"offset\", \"I\"],\n  [\"dimensionality\", \"B\"],\n  [\"reserved_0\", \"B\"],\n  [\"reserved_1\", \"B\"],\n  [\"reserved_2\", \"B\"],\n  [\"permutation\", \"I\"],\n  [\"reserved_3\", \"I\"],\n  [\"dim_size_1\", \"I\"],\n  [\"dim_size_2\", \"I\"],\n  [\"dim_size_3\", \"I\"],\n  [\"dim_size_4\", \"I\"]\n]);\nvar COMPOUND_PROP_DESC_V1_SIZE = _structure_size(COMPOUND_PROP_DESC_V1);\nvar DATATYPE_FIXED_POINT = 0;\nvar DATATYPE_FLOATING_POINT = 1;\nvar DATATYPE_TIME = 2;\nvar DATATYPE_STRING = 3;\nvar DATATYPE_BITFIELD = 4;\nvar DATATYPE_OPAQUE = 5;\nvar DATATYPE_COMPOUND = 6;\nvar DATATYPE_REFERENCE = 7;\nvar DATATYPE_ENUMERATED = 8;\nvar DATATYPE_VARIABLE_LENGTH = 9;\nvar DATATYPE_ARRAY = 10;\n\n// node_modules/pako/dist/pako.esm.mjs\nvar Z_FIXED$1 = 4;\nvar Z_BINARY = 0;\nvar Z_TEXT = 1;\nvar Z_UNKNOWN$1 = 2;\nfunction zero$1(buf) {\n  let len = buf.length;\n  while (--len >= 0) {\n    buf[len] = 0;\n  }\n}\nvar STORED_BLOCK = 0;\nvar STATIC_TREES = 1;\nvar DYN_TREES = 2;\nvar MIN_MATCH$1 = 3;\nvar MAX_MATCH$1 = 258;\nvar LENGTH_CODES$1 = 29;\nvar LITERALS$1 = 256;\nvar L_CODES$1 = LITERALS$1 + 1 + LENGTH_CODES$1;\nvar D_CODES$1 = 30;\nvar BL_CODES$1 = 19;\nvar HEAP_SIZE$1 = 2 * L_CODES$1 + 1;\nvar MAX_BITS$1 = 15;\nvar Buf_size = 16;\nvar MAX_BL_BITS = 7;\nvar END_BLOCK = 256;\nvar REP_3_6 = 16;\nvar REPZ_3_10 = 17;\nvar REPZ_11_138 = 18;\nvar extra_lbits = new Uint8Array([0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 2, 2, 2, 2, 3, 3, 3, 3, 4, 4, 4, 4, 5, 5, 5, 5, 0]);\nvar extra_dbits = new Uint8Array([0, 0, 0, 0, 1, 1, 2, 2, 3, 3, 4, 4, 5, 5, 6, 6, 7, 7, 8, 8, 9, 9, 10, 10, 11, 11, 12, 12, 13, 13]);\nvar extra_blbits = new Uint8Array([0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 2, 3, 7]);\nvar bl_order = new Uint8Array([16, 17, 18, 0, 8, 7, 9, 6, 10, 5, 11, 4, 12, 3, 13, 2, 14, 1, 15]);\nvar DIST_CODE_LEN = 512;\nvar static_ltree = new Array((L_CODES$1 + 2) * 2);\nzero$1(static_ltree);\nvar static_dtree = new Array(D_CODES$1 * 2);\nzero$1(static_dtree);\nvar _dist_code = new Array(DIST_CODE_LEN);\nzero$1(_dist_code);\nvar _length_code = new Array(MAX_MATCH$1 - MIN_MATCH$1 + 1);\nzero$1(_length_code);\nvar base_length = new Array(LENGTH_CODES$1);\nzero$1(base_length);\nvar base_dist = new Array(D_CODES$1);\nzero$1(base_dist);\nfunction StaticTreeDesc(static_tree, extra_bits, extra_base, elems, max_length) {\n  this.static_tree = static_tree;\n  this.extra_bits = extra_bits;\n  this.extra_base = extra_base;\n  this.elems = elems;\n  this.max_length = max_length;\n  this.has_stree = static_tree && static_tree.length;\n}\nvar static_l_desc;\nvar static_d_desc;\nvar static_bl_desc;\nfunction TreeDesc(dyn_tree, stat_desc) {\n  this.dyn_tree = dyn_tree;\n  this.max_code = 0;\n  this.stat_desc = stat_desc;\n}\nvar d_code = (dist) => {\n  return dist < 256 ? _dist_code[dist] : _dist_code[256 + (dist >>> 7)];\n};\nvar put_short = (s, w) => {\n  s.pending_buf[s.pending++] = w & 255;\n  s.pending_buf[s.pending++] = w >>> 8 & 255;\n};\nvar send_bits = (s, value, length) => {\n  if (s.bi_valid > Buf_size - length) {\n    s.bi_buf |= value << s.bi_valid & 65535;\n    put_short(s, s.bi_buf);\n    s.bi_buf = value >> Buf_size - s.bi_valid;\n    s.bi_valid += length - Buf_size;\n  } else {\n    s.bi_buf |= value << s.bi_valid & 65535;\n    s.bi_valid += length;\n  }\n};\nvar send_code = (s, c, tree) => {\n  send_bits(s, tree[c * 2], tree[c * 2 + 1]);\n};\nvar bi_reverse = (code, len) => {\n  let res = 0;\n  do {\n    res |= code & 1;\n    code >>>= 1;\n    res <<= 1;\n  } while (--len > 0);\n  return res >>> 1;\n};\nvar bi_flush = (s) => {\n  if (s.bi_valid === 16) {\n    put_short(s, s.bi_buf);\n    s.bi_buf = 0;\n    s.bi_valid = 0;\n  } else if (s.bi_valid >= 8) {\n    s.pending_buf[s.pending++] = s.bi_buf & 255;\n    s.bi_buf >>= 8;\n    s.bi_valid -= 8;\n  }\n};\nvar gen_bitlen = (s, desc) => {\n  const tree = desc.dyn_tree;\n  const max_code = desc.max_code;\n  const stree = desc.stat_desc.static_tree;\n  const has_stree = desc.stat_desc.has_stree;\n  const extra = desc.stat_desc.extra_bits;\n  const base = desc.stat_desc.extra_base;\n  const max_length = desc.stat_desc.max_length;\n  let h;\n  let n, m;\n  let bits;\n  let xbits;\n  let f;\n  let overflow = 0;\n  for (bits = 0; bits <= MAX_BITS$1; bits++) {\n    s.bl_count[bits] = 0;\n  }\n  tree[s.heap[s.heap_max] * 2 + 1] = 0;\n  for (h = s.heap_max + 1; h < HEAP_SIZE$1; h++) {\n    n = s.heap[h];\n    bits = tree[tree[n * 2 + 1] * 2 + 1] + 1;\n    if (bits > max_length) {\n      bits = max_length;\n      overflow++;\n    }\n    tree[n * 2 + 1] = bits;\n    if (n > max_code) {\n      continue;\n    }\n    s.bl_count[bits]++;\n    xbits = 0;\n    if (n >= base) {\n      xbits = extra[n - base];\n    }\n    f = tree[n * 2];\n    s.opt_len += f * (bits + xbits);\n    if (has_stree) {\n      s.static_len += f * (stree[n * 2 + 1] + xbits);\n    }\n  }\n  if (overflow === 0) {\n    return;\n  }\n  do {\n    bits = max_length - 1;\n    while (s.bl_count[bits] === 0) {\n      bits--;\n    }\n    s.bl_count[bits]--;\n    s.bl_count[bits + 1] += 2;\n    s.bl_count[max_length]--;\n    overflow -= 2;\n  } while (overflow > 0);\n  for (bits = max_length; bits !== 0; bits--) {\n    n = s.bl_count[bits];\n    while (n !== 0) {\n      m = s.heap[--h];\n      if (m > max_code) {\n        continue;\n      }\n      if (tree[m * 2 + 1] !== bits) {\n        s.opt_len += (bits - tree[m * 2 + 1]) * tree[m * 2];\n        tree[m * 2 + 1] = bits;\n      }\n      n--;\n    }\n  }\n};\nvar gen_codes = (tree, max_code, bl_count) => {\n  const next_code = new Array(MAX_BITS$1 + 1);\n  let code = 0;\n  let bits;\n  let n;\n  for (bits = 1; bits <= MAX_BITS$1; bits++) {\n    next_code[bits] = code = code + bl_count[bits - 1] << 1;\n  }\n  for (n = 0; n <= max_code; n++) {\n    let len = tree[n * 2 + 1];\n    if (len === 0) {\n      continue;\n    }\n    tree[n * 2] = bi_reverse(next_code[len]++, len);\n  }\n};\nvar tr_static_init = () => {\n  let n;\n  let bits;\n  let length;\n  let code;\n  let dist;\n  const bl_count = new Array(MAX_BITS$1 + 1);\n  length = 0;\n  for (code = 0; code < LENGTH_CODES$1 - 1; code++) {\n    base_length[code] = length;\n    for (n = 0; n < 1 << extra_lbits[code]; n++) {\n      _length_code[length++] = code;\n    }\n  }\n  _length_code[length - 1] = code;\n  dist = 0;\n  for (code = 0; code < 16; code++) {\n    base_dist[code] = dist;\n    for (n = 0; n < 1 << extra_dbits[code]; n++) {\n      _dist_code[dist++] = code;\n    }\n  }\n  dist >>= 7;\n  for (; code < D_CODES$1; code++) {\n    base_dist[code] = dist << 7;\n    for (n = 0; n < 1 << extra_dbits[code] - 7; n++) {\n      _dist_code[256 + dist++] = code;\n    }\n  }\n  for (bits = 0; bits <= MAX_BITS$1; bits++) {\n    bl_count[bits] = 0;\n  }\n  n = 0;\n  while (n <= 143) {\n    static_ltree[n * 2 + 1] = 8;\n    n++;\n    bl_count[8]++;\n  }\n  while (n <= 255) {\n    static_ltree[n * 2 + 1] = 9;\n    n++;\n    bl_count[9]++;\n  }\n  while (n <= 279) {\n    static_ltree[n * 2 + 1] = 7;\n    n++;\n    bl_count[7]++;\n  }\n  while (n <= 287) {\n    static_ltree[n * 2 + 1] = 8;\n    n++;\n    bl_count[8]++;\n  }\n  gen_codes(static_ltree, L_CODES$1 + 1, bl_count);\n  for (n = 0; n < D_CODES$1; n++) {\n    static_dtree[n * 2 + 1] = 5;\n    static_dtree[n * 2] = bi_reverse(n, 5);\n  }\n  static_l_desc = new StaticTreeDesc(static_ltree, extra_lbits, LITERALS$1 + 1, L_CODES$1, MAX_BITS$1);\n  static_d_desc = new StaticTreeDesc(static_dtree, extra_dbits, 0, D_CODES$1, MAX_BITS$1);\n  static_bl_desc = new StaticTreeDesc(new Array(0), extra_blbits, 0, BL_CODES$1, MAX_BL_BITS);\n};\nvar init_block = (s) => {\n  let n;\n  for (n = 0; n < L_CODES$1; n++) {\n    s.dyn_ltree[n * 2] = 0;\n  }\n  for (n = 0; n < D_CODES$1; n++) {\n    s.dyn_dtree[n * 2] = 0;\n  }\n  for (n = 0; n < BL_CODES$1; n++) {\n    s.bl_tree[n * 2] = 0;\n  }\n  s.dyn_ltree[END_BLOCK * 2] = 1;\n  s.opt_len = s.static_len = 0;\n  s.last_lit = s.matches = 0;\n};\nvar bi_windup = (s) => {\n  if (s.bi_valid > 8) {\n    put_short(s, s.bi_buf);\n  } else if (s.bi_valid > 0) {\n    s.pending_buf[s.pending++] = s.bi_buf;\n  }\n  s.bi_buf = 0;\n  s.bi_valid = 0;\n};\nvar copy_block = (s, buf, len, header) => {\n  bi_windup(s);\n  if (header) {\n    put_short(s, len);\n    put_short(s, ~len);\n  }\n  s.pending_buf.set(s.window.subarray(buf, buf + len), s.pending);\n  s.pending += len;\n};\nvar smaller = (tree, n, m, depth) => {\n  const _n2 = n * 2;\n  const _m2 = m * 2;\n  return tree[_n2] < tree[_m2] || tree[_n2] === tree[_m2] && depth[n] <= depth[m];\n};\nvar pqdownheap = (s, tree, k) => {\n  const v = s.heap[k];\n  let j = k << 1;\n  while (j <= s.heap_len) {\n    if (j < s.heap_len && smaller(tree, s.heap[j + 1], s.heap[j], s.depth)) {\n      j++;\n    }\n    if (smaller(tree, v, s.heap[j], s.depth)) {\n      break;\n    }\n    s.heap[k] = s.heap[j];\n    k = j;\n    j <<= 1;\n  }\n  s.heap[k] = v;\n};\nvar compress_block = (s, ltree, dtree) => {\n  let dist;\n  let lc;\n  let lx = 0;\n  let code;\n  let extra;\n  if (s.last_lit !== 0) {\n    do {\n      dist = s.pending_buf[s.d_buf + lx * 2] << 8 | s.pending_buf[s.d_buf + lx * 2 + 1];\n      lc = s.pending_buf[s.l_buf + lx];\n      lx++;\n      if (dist === 0) {\n        send_code(s, lc, ltree);\n      } else {\n        code = _length_code[lc];\n        send_code(s, code + LITERALS$1 + 1, ltree);\n        extra = extra_lbits[code];\n        if (extra !== 0) {\n          lc -= base_length[code];\n          send_bits(s, lc, extra);\n        }\n        dist--;\n        code = d_code(dist);\n        send_code(s, code, dtree);\n        extra = extra_dbits[code];\n        if (extra !== 0) {\n          dist -= base_dist[code];\n          send_bits(s, dist, extra);\n        }\n      }\n    } while (lx < s.last_lit);\n  }\n  send_code(s, END_BLOCK, ltree);\n};\nvar build_tree = (s, desc) => {\n  const tree = desc.dyn_tree;\n  const stree = desc.stat_desc.static_tree;\n  const has_stree = desc.stat_desc.has_stree;\n  const elems = desc.stat_desc.elems;\n  let n, m;\n  let max_code = -1;\n  let node2;\n  s.heap_len = 0;\n  s.heap_max = HEAP_SIZE$1;\n  for (n = 0; n < elems; n++) {\n    if (tree[n * 2] !== 0) {\n      s.heap[++s.heap_len] = max_code = n;\n      s.depth[n] = 0;\n    } else {\n      tree[n * 2 + 1] = 0;\n    }\n  }\n  while (s.heap_len < 2) {\n    node2 = s.heap[++s.heap_len] = max_code < 2 ? ++max_code : 0;\n    tree[node2 * 2] = 1;\n    s.depth[node2] = 0;\n    s.opt_len--;\n    if (has_stree) {\n      s.static_len -= stree[node2 * 2 + 1];\n    }\n  }\n  desc.max_code = max_code;\n  for (n = s.heap_len >> 1; n >= 1; n--) {\n    pqdownheap(s, tree, n);\n  }\n  node2 = elems;\n  do {\n    n = s.heap[1];\n    s.heap[1] = s.heap[s.heap_len--];\n    pqdownheap(s, tree, 1);\n    m = s.heap[1];\n    s.heap[--s.heap_max] = n;\n    s.heap[--s.heap_max] = m;\n    tree[node2 * 2] = tree[n * 2] + tree[m * 2];\n    s.depth[node2] = (s.depth[n] >= s.depth[m] ? s.depth[n] : s.depth[m]) + 1;\n    tree[n * 2 + 1] = tree[m * 2 + 1] = node2;\n    s.heap[1] = node2++;\n    pqdownheap(s, tree, 1);\n  } while (s.heap_len >= 2);\n  s.heap[--s.heap_max] = s.heap[1];\n  gen_bitlen(s, desc);\n  gen_codes(tree, max_code, s.bl_count);\n};\nvar scan_tree = (s, tree, max_code) => {\n  let n;\n  let prevlen = -1;\n  let curlen;\n  let nextlen = tree[0 * 2 + 1];\n  let count = 0;\n  let max_count = 7;\n  let min_count = 4;\n  if (nextlen === 0) {\n    max_count = 138;\n    min_count = 3;\n  }\n  tree[(max_code + 1) * 2 + 1] = 65535;\n  for (n = 0; n <= max_code; n++) {\n    curlen = nextlen;\n    nextlen = tree[(n + 1) * 2 + 1];\n    if (++count < max_count && curlen === nextlen) {\n      continue;\n    } else if (count < min_count) {\n      s.bl_tree[curlen * 2] += count;\n    } else if (curlen !== 0) {\n      if (curlen !== prevlen) {\n        s.bl_tree[curlen * 2]++;\n      }\n      s.bl_tree[REP_3_6 * 2]++;\n    } else if (count <= 10) {\n      s.bl_tree[REPZ_3_10 * 2]++;\n    } else {\n      s.bl_tree[REPZ_11_138 * 2]++;\n    }\n    count = 0;\n    prevlen = curlen;\n    if (nextlen === 0) {\n      max_count = 138;\n      min_count = 3;\n    } else if (curlen === nextlen) {\n      max_count = 6;\n      min_count = 3;\n    } else {\n      max_count = 7;\n      min_count = 4;\n    }\n  }\n};\nvar send_tree = (s, tree, max_code) => {\n  let n;\n  let prevlen = -1;\n  let curlen;\n  let nextlen = tree[0 * 2 + 1];\n  let count = 0;\n  let max_count = 7;\n  let min_count = 4;\n  if (nextlen === 0) {\n    max_count = 138;\n    min_count = 3;\n  }\n  for (n = 0; n <= max_code; n++) {\n    curlen = nextlen;\n    nextlen = tree[(n + 1) * 2 + 1];\n    if (++count < max_count && curlen === nextlen) {\n      continue;\n    } else if (count < min_count) {\n      do {\n        send_code(s, curlen, s.bl_tree);\n      } while (--count !== 0);\n    } else if (curlen !== 0) {\n      if (curlen !== prevlen) {\n        send_code(s, curlen, s.bl_tree);\n        count--;\n      }\n      send_code(s, REP_3_6, s.bl_tree);\n      send_bits(s, count - 3, 2);\n    } else if (count <= 10) {\n      send_code(s, REPZ_3_10, s.bl_tree);\n      send_bits(s, count - 3, 3);\n    } else {\n      send_code(s, REPZ_11_138, s.bl_tree);\n      send_bits(s, count - 11, 7);\n    }\n    count = 0;\n    prevlen = curlen;\n    if (nextlen === 0) {\n      max_count = 138;\n      min_count = 3;\n    } else if (curlen === nextlen) {\n      max_count = 6;\n      min_count = 3;\n    } else {\n      max_count = 7;\n      min_count = 4;\n    }\n  }\n};\nvar build_bl_tree = (s) => {\n  let max_blindex;\n  scan_tree(s, s.dyn_ltree, s.l_desc.max_code);\n  scan_tree(s, s.dyn_dtree, s.d_desc.max_code);\n  build_tree(s, s.bl_desc);\n  for (max_blindex = BL_CODES$1 - 1; max_blindex >= 3; max_blindex--) {\n    if (s.bl_tree[bl_order[max_blindex] * 2 + 1] !== 0) {\n      break;\n    }\n  }\n  s.opt_len += 3 * (max_blindex + 1) + 5 + 5 + 4;\n  return max_blindex;\n};\nvar send_all_trees = (s, lcodes, dcodes, blcodes) => {\n  let rank2;\n  send_bits(s, lcodes - 257, 5);\n  send_bits(s, dcodes - 1, 5);\n  send_bits(s, blcodes - 4, 4);\n  for (rank2 = 0; rank2 < blcodes; rank2++) {\n    send_bits(s, s.bl_tree[bl_order[rank2] * 2 + 1], 3);\n  }\n  send_tree(s, s.dyn_ltree, lcodes - 1);\n  send_tree(s, s.dyn_dtree, dcodes - 1);\n};\nvar detect_data_type = (s) => {\n  let black_mask = 4093624447;\n  let n;\n  for (n = 0; n <= 31; n++, black_mask >>>= 1) {\n    if (black_mask & 1 && s.dyn_ltree[n * 2] !== 0) {\n      return Z_BINARY;\n    }\n  }\n  if (s.dyn_ltree[9 * 2] !== 0 || s.dyn_ltree[10 * 2] !== 0 || s.dyn_ltree[13 * 2] !== 0) {\n    return Z_TEXT;\n  }\n  for (n = 32; n < LITERALS$1; n++) {\n    if (s.dyn_ltree[n * 2] !== 0) {\n      return Z_TEXT;\n    }\n  }\n  return Z_BINARY;\n};\nvar static_init_done = false;\nvar _tr_init$1 = (s) => {\n  if (!static_init_done) {\n    tr_static_init();\n    static_init_done = true;\n  }\n  s.l_desc = new TreeDesc(s.dyn_ltree, static_l_desc);\n  s.d_desc = new TreeDesc(s.dyn_dtree, static_d_desc);\n  s.bl_desc = new TreeDesc(s.bl_tree, static_bl_desc);\n  s.bi_buf = 0;\n  s.bi_valid = 0;\n  init_block(s);\n};\nvar _tr_stored_block$1 = (s, buf, stored_len, last) => {\n  send_bits(s, (STORED_BLOCK << 1) + (last ? 1 : 0), 3);\n  copy_block(s, buf, stored_len, true);\n};\nvar _tr_align$1 = (s) => {\n  send_bits(s, STATIC_TREES << 1, 3);\n  send_code(s, END_BLOCK, static_ltree);\n  bi_flush(s);\n};\nvar _tr_flush_block$1 = (s, buf, stored_len, last) => {\n  let opt_lenb, static_lenb;\n  let max_blindex = 0;\n  if (s.level > 0) {\n    if (s.strm.data_type === Z_UNKNOWN$1) {\n      s.strm.data_type = detect_data_type(s);\n    }\n    build_tree(s, s.l_desc);\n    build_tree(s, s.d_desc);\n    max_blindex = build_bl_tree(s);\n    opt_lenb = s.opt_len + 3 + 7 >>> 3;\n    static_lenb = s.static_len + 3 + 7 >>> 3;\n    if (static_lenb <= opt_lenb) {\n      opt_lenb = static_lenb;\n    }\n  } else {\n    opt_lenb = static_lenb = stored_len + 5;\n  }\n  if (stored_len + 4 <= opt_lenb && buf !== -1) {\n    _tr_stored_block$1(s, buf, stored_len, last);\n  } else if (s.strategy === Z_FIXED$1 || static_lenb === opt_lenb) {\n    send_bits(s, (STATIC_TREES << 1) + (last ? 1 : 0), 3);\n    compress_block(s, static_ltree, static_dtree);\n  } else {\n    send_bits(s, (DYN_TREES << 1) + (last ? 1 : 0), 3);\n    send_all_trees(s, s.l_desc.max_code + 1, s.d_desc.max_code + 1, max_blindex + 1);\n    compress_block(s, s.dyn_ltree, s.dyn_dtree);\n  }\n  init_block(s);\n  if (last) {\n    bi_windup(s);\n  }\n};\nvar _tr_tally$1 = (s, dist, lc) => {\n  s.pending_buf[s.d_buf + s.last_lit * 2] = dist >>> 8 & 255;\n  s.pending_buf[s.d_buf + s.last_lit * 2 + 1] = dist & 255;\n  s.pending_buf[s.l_buf + s.last_lit] = lc & 255;\n  s.last_lit++;\n  if (dist === 0) {\n    s.dyn_ltree[lc * 2]++;\n  } else {\n    s.matches++;\n    dist--;\n    s.dyn_ltree[(_length_code[lc] + LITERALS$1 + 1) * 2]++;\n    s.dyn_dtree[d_code(dist) * 2]++;\n  }\n  return s.last_lit === s.lit_bufsize - 1;\n};\nvar _tr_init_1 = _tr_init$1;\nvar _tr_stored_block_1 = _tr_stored_block$1;\nvar _tr_flush_block_1 = _tr_flush_block$1;\nvar _tr_tally_1 = _tr_tally$1;\nvar _tr_align_1 = _tr_align$1;\nvar trees = {\n  _tr_init: _tr_init_1,\n  _tr_stored_block: _tr_stored_block_1,\n  _tr_flush_block: _tr_flush_block_1,\n  _tr_tally: _tr_tally_1,\n  _tr_align: _tr_align_1\n};\nvar adler32 = (adler, buf, len, pos) => {\n  let s1 = adler & 65535 | 0, s2 = adler >>> 16 & 65535 | 0, n = 0;\n  while (len !== 0) {\n    n = len > 2e3 ? 2e3 : len;\n    len -= n;\n    do {\n      s1 = s1 + buf[pos++] | 0;\n      s2 = s2 + s1 | 0;\n    } while (--n);\n    s1 %= 65521;\n    s2 %= 65521;\n  }\n  return s1 | s2 << 16 | 0;\n};\nvar adler32_1 = adler32;\nvar makeTable = () => {\n  let c, table = [];\n  for (var n = 0; n < 256; n++) {\n    c = n;\n    for (var k = 0; k < 8; k++) {\n      c = c & 1 ? 3988292384 ^ c >>> 1 : c >>> 1;\n    }\n    table[n] = c;\n  }\n  return table;\n};\nvar crcTable = new Uint32Array(makeTable());\nvar crc32 = (crc, buf, len, pos) => {\n  const t = crcTable;\n  const end = pos + len;\n  crc ^= -1;\n  for (let i = pos; i < end; i++) {\n    crc = crc >>> 8 ^ t[(crc ^ buf[i]) & 255];\n  }\n  return crc ^ -1;\n};\nvar crc32_1 = crc32;\nvar messages = {\n  2: \"need dictionary\",\n  1: \"stream end\",\n  0: \"\",\n  \"-1\": \"file error\",\n  \"-2\": \"stream error\",\n  \"-3\": \"data error\",\n  \"-4\": \"insufficient memory\",\n  \"-5\": \"buffer error\",\n  \"-6\": \"incompatible version\"\n};\nvar constants$2 = {\n  Z_NO_FLUSH: 0,\n  Z_PARTIAL_FLUSH: 1,\n  Z_SYNC_FLUSH: 2,\n  Z_FULL_FLUSH: 3,\n  Z_FINISH: 4,\n  Z_BLOCK: 5,\n  Z_TREES: 6,\n  Z_OK: 0,\n  Z_STREAM_END: 1,\n  Z_NEED_DICT: 2,\n  Z_ERRNO: -1,\n  Z_STREAM_ERROR: -2,\n  Z_DATA_ERROR: -3,\n  Z_MEM_ERROR: -4,\n  Z_BUF_ERROR: -5,\n  Z_NO_COMPRESSION: 0,\n  Z_BEST_SPEED: 1,\n  Z_BEST_COMPRESSION: 9,\n  Z_DEFAULT_COMPRESSION: -1,\n  Z_FILTERED: 1,\n  Z_HUFFMAN_ONLY: 2,\n  Z_RLE: 3,\n  Z_FIXED: 4,\n  Z_DEFAULT_STRATEGY: 0,\n  Z_BINARY: 0,\n  Z_TEXT: 1,\n  Z_UNKNOWN: 2,\n  Z_DEFLATED: 8\n};\nvar { _tr_init, _tr_stored_block, _tr_flush_block, _tr_tally, _tr_align } = trees;\nvar {\n  Z_NO_FLUSH: Z_NO_FLUSH$2,\n  Z_PARTIAL_FLUSH,\n  Z_FULL_FLUSH: Z_FULL_FLUSH$1,\n  Z_FINISH: Z_FINISH$3,\n  Z_BLOCK: Z_BLOCK$1,\n  Z_OK: Z_OK$3,\n  Z_STREAM_END: Z_STREAM_END$3,\n  Z_STREAM_ERROR: Z_STREAM_ERROR$2,\n  Z_DATA_ERROR: Z_DATA_ERROR$2,\n  Z_BUF_ERROR: Z_BUF_ERROR$1,\n  Z_DEFAULT_COMPRESSION: Z_DEFAULT_COMPRESSION$1,\n  Z_FILTERED,\n  Z_HUFFMAN_ONLY,\n  Z_RLE,\n  Z_FIXED,\n  Z_DEFAULT_STRATEGY: Z_DEFAULT_STRATEGY$1,\n  Z_UNKNOWN,\n  Z_DEFLATED: Z_DEFLATED$2\n} = constants$2;\nvar MAX_MEM_LEVEL = 9;\nvar MAX_WBITS$1 = 15;\nvar DEF_MEM_LEVEL = 8;\nvar LENGTH_CODES = 29;\nvar LITERALS = 256;\nvar L_CODES = LITERALS + 1 + LENGTH_CODES;\nvar D_CODES = 30;\nvar BL_CODES = 19;\nvar HEAP_SIZE = 2 * L_CODES + 1;\nvar MAX_BITS = 15;\nvar MIN_MATCH = 3;\nvar MAX_MATCH = 258;\nvar MIN_LOOKAHEAD = MAX_MATCH + MIN_MATCH + 1;\nvar PRESET_DICT = 32;\nvar INIT_STATE = 42;\nvar EXTRA_STATE = 69;\nvar NAME_STATE = 73;\nvar COMMENT_STATE = 91;\nvar HCRC_STATE = 103;\nvar BUSY_STATE = 113;\nvar FINISH_STATE = 666;\nvar BS_NEED_MORE = 1;\nvar BS_BLOCK_DONE = 2;\nvar BS_FINISH_STARTED = 3;\nvar BS_FINISH_DONE = 4;\nvar OS_CODE = 3;\nvar err = (strm, errorCode) => {\n  strm.msg = messages[errorCode];\n  return errorCode;\n};\nvar rank = (f) => {\n  return (f << 1) - (f > 4 ? 9 : 0);\n};\nvar zero = (buf) => {\n  let len = buf.length;\n  while (--len >= 0) {\n    buf[len] = 0;\n  }\n};\nvar HASH_ZLIB = (s, prev, data) => (prev << s.hash_shift ^ data) & s.hash_mask;\nvar HASH = HASH_ZLIB;\nvar flush_pending = (strm) => {\n  const s = strm.state;\n  let len = s.pending;\n  if (len > strm.avail_out) {\n    len = strm.avail_out;\n  }\n  if (len === 0) {\n    return;\n  }\n  strm.output.set(s.pending_buf.subarray(s.pending_out, s.pending_out + len), strm.next_out);\n  strm.next_out += len;\n  s.pending_out += len;\n  strm.total_out += len;\n  strm.avail_out -= len;\n  s.pending -= len;\n  if (s.pending === 0) {\n    s.pending_out = 0;\n  }\n};\nvar flush_block_only = (s, last) => {\n  _tr_flush_block(s, s.block_start >= 0 ? s.block_start : -1, s.strstart - s.block_start, last);\n  s.block_start = s.strstart;\n  flush_pending(s.strm);\n};\nvar put_byte = (s, b) => {\n  s.pending_buf[s.pending++] = b;\n};\nvar putShortMSB = (s, b) => {\n  s.pending_buf[s.pending++] = b >>> 8 & 255;\n  s.pending_buf[s.pending++] = b & 255;\n};\nvar read_buf = (strm, buf, start, size) => {\n  let len = strm.avail_in;\n  if (len > size) {\n    len = size;\n  }\n  if (len === 0) {\n    return 0;\n  }\n  strm.avail_in -= len;\n  buf.set(strm.input.subarray(strm.next_in, strm.next_in + len), start);\n  if (strm.state.wrap === 1) {\n    strm.adler = adler32_1(strm.adler, buf, len, start);\n  } else if (strm.state.wrap === 2) {\n    strm.adler = crc32_1(strm.adler, buf, len, start);\n  }\n  strm.next_in += len;\n  strm.total_in += len;\n  return len;\n};\nvar longest_match = (s, cur_match) => {\n  let chain_length = s.max_chain_length;\n  let scan = s.strstart;\n  let match;\n  let len;\n  let best_len = s.prev_length;\n  let nice_match = s.nice_match;\n  const limit = s.strstart > s.w_size - MIN_LOOKAHEAD ? s.strstart - (s.w_size - MIN_LOOKAHEAD) : 0;\n  const _win = s.window;\n  const wmask = s.w_mask;\n  const prev = s.prev;\n  const strend = s.strstart + MAX_MATCH;\n  let scan_end1 = _win[scan + best_len - 1];\n  let scan_end = _win[scan + best_len];\n  if (s.prev_length >= s.good_match) {\n    chain_length >>= 2;\n  }\n  if (nice_match > s.lookahead) {\n    nice_match = s.lookahead;\n  }\n  do {\n    match = cur_match;\n    if (_win[match + best_len] !== scan_end || _win[match + best_len - 1] !== scan_end1 || _win[match] !== _win[scan] || _win[++match] !== _win[scan + 1]) {\n      continue;\n    }\n    scan += 2;\n    match++;\n    do {\n    } while (_win[++scan] === _win[++match] && _win[++scan] === _win[++match] && _win[++scan] === _win[++match] && _win[++scan] === _win[++match] && _win[++scan] === _win[++match] && _win[++scan] === _win[++match] && _win[++scan] === _win[++match] && _win[++scan] === _win[++match] && scan < strend);\n    len = MAX_MATCH - (strend - scan);\n    scan = strend - MAX_MATCH;\n    if (len > best_len) {\n      s.match_start = cur_match;\n      best_len = len;\n      if (len >= nice_match) {\n        break;\n      }\n      scan_end1 = _win[scan + best_len - 1];\n      scan_end = _win[scan + best_len];\n    }\n  } while ((cur_match = prev[cur_match & wmask]) > limit && --chain_length !== 0);\n  if (best_len <= s.lookahead) {\n    return best_len;\n  }\n  return s.lookahead;\n};\nvar fill_window = (s) => {\n  const _w_size = s.w_size;\n  let p, n, m, more, str;\n  do {\n    more = s.window_size - s.lookahead - s.strstart;\n    if (s.strstart >= _w_size + (_w_size - MIN_LOOKAHEAD)) {\n      s.window.set(s.window.subarray(_w_size, _w_size + _w_size), 0);\n      s.match_start -= _w_size;\n      s.strstart -= _w_size;\n      s.block_start -= _w_size;\n      n = s.hash_size;\n      p = n;\n      do {\n        m = s.head[--p];\n        s.head[p] = m >= _w_size ? m - _w_size : 0;\n      } while (--n);\n      n = _w_size;\n      p = n;\n      do {\n        m = s.prev[--p];\n        s.prev[p] = m >= _w_size ? m - _w_size : 0;\n      } while (--n);\n      more += _w_size;\n    }\n    if (s.strm.avail_in === 0) {\n      break;\n    }\n    n = read_buf(s.strm, s.window, s.strstart + s.lookahead, more);\n    s.lookahead += n;\n    if (s.lookahead + s.insert >= MIN_MATCH) {\n      str = s.strstart - s.insert;\n      s.ins_h = s.window[str];\n      s.ins_h = HASH(s, s.ins_h, s.window[str + 1]);\n      while (s.insert) {\n        s.ins_h = HASH(s, s.ins_h, s.window[str + MIN_MATCH - 1]);\n        s.prev[str & s.w_mask] = s.head[s.ins_h];\n        s.head[s.ins_h] = str;\n        str++;\n        s.insert--;\n        if (s.lookahead + s.insert < MIN_MATCH) {\n          break;\n        }\n      }\n    }\n  } while (s.lookahead < MIN_LOOKAHEAD && s.strm.avail_in !== 0);\n};\nvar deflate_stored = (s, flush) => {\n  let max_block_size = 65535;\n  if (max_block_size > s.pending_buf_size - 5) {\n    max_block_size = s.pending_buf_size - 5;\n  }\n  for (; ; ) {\n    if (s.lookahead <= 1) {\n      fill_window(s);\n      if (s.lookahead === 0 && flush === Z_NO_FLUSH$2) {\n        return BS_NEED_MORE;\n      }\n      if (s.lookahead === 0) {\n        break;\n      }\n    }\n    s.strstart += s.lookahead;\n    s.lookahead = 0;\n    const max_start = s.block_start + max_block_size;\n    if (s.strstart === 0 || s.strstart >= max_start) {\n      s.lookahead = s.strstart - max_start;\n      s.strstart = max_start;\n      flush_block_only(s, false);\n      if (s.strm.avail_out === 0) {\n        return BS_NEED_MORE;\n      }\n    }\n    if (s.strstart - s.block_start >= s.w_size - MIN_LOOKAHEAD) {\n      flush_block_only(s, false);\n      if (s.strm.avail_out === 0) {\n        return BS_NEED_MORE;\n      }\n    }\n  }\n  s.insert = 0;\n  if (flush === Z_FINISH$3) {\n    flush_block_only(s, true);\n    if (s.strm.avail_out === 0) {\n      return BS_FINISH_STARTED;\n    }\n    return BS_FINISH_DONE;\n  }\n  if (s.strstart > s.block_start) {\n    flush_block_only(s, false);\n    if (s.strm.avail_out === 0) {\n      return BS_NEED_MORE;\n    }\n  }\n  return BS_NEED_MORE;\n};\nvar deflate_fast = (s, flush) => {\n  let hash_head;\n  let bflush;\n  for (; ; ) {\n    if (s.lookahead < MIN_LOOKAHEAD) {\n      fill_window(s);\n      if (s.lookahead < MIN_LOOKAHEAD && flush === Z_NO_FLUSH$2) {\n        return BS_NEED_MORE;\n      }\n      if (s.lookahead === 0) {\n        break;\n      }\n    }\n    hash_head = 0;\n    if (s.lookahead >= MIN_MATCH) {\n      s.ins_h = HASH(s, s.ins_h, s.window[s.strstart + MIN_MATCH - 1]);\n      hash_head = s.prev[s.strstart & s.w_mask] = s.head[s.ins_h];\n      s.head[s.ins_h] = s.strstart;\n    }\n    if (hash_head !== 0 && s.strstart - hash_head <= s.w_size - MIN_LOOKAHEAD) {\n      s.match_length = longest_match(s, hash_head);\n    }\n    if (s.match_length >= MIN_MATCH) {\n      bflush = _tr_tally(s, s.strstart - s.match_start, s.match_length - MIN_MATCH);\n      s.lookahead -= s.match_length;\n      if (s.match_length <= s.max_lazy_match && s.lookahead >= MIN_MATCH) {\n        s.match_length--;\n        do {\n          s.strstart++;\n          s.ins_h = HASH(s, s.ins_h, s.window[s.strstart + MIN_MATCH - 1]);\n          hash_head = s.prev[s.strstart & s.w_mask] = s.head[s.ins_h];\n          s.head[s.ins_h] = s.strstart;\n        } while (--s.match_length !== 0);\n        s.strstart++;\n      } else {\n        s.strstart += s.match_length;\n        s.match_length = 0;\n        s.ins_h = s.window[s.strstart];\n        s.ins_h = HASH(s, s.ins_h, s.window[s.strstart + 1]);\n      }\n    } else {\n      bflush = _tr_tally(s, 0, s.window[s.strstart]);\n      s.lookahead--;\n      s.strstart++;\n    }\n    if (bflush) {\n      flush_block_only(s, false);\n      if (s.strm.avail_out === 0) {\n        return BS_NEED_MORE;\n      }\n    }\n  }\n  s.insert = s.strstart < MIN_MATCH - 1 ? s.strstart : MIN_MATCH - 1;\n  if (flush === Z_FINISH$3) {\n    flush_block_only(s, true);\n    if (s.strm.avail_out === 0) {\n      return BS_FINISH_STARTED;\n    }\n    return BS_FINISH_DONE;\n  }\n  if (s.last_lit) {\n    flush_block_only(s, false);\n    if (s.strm.avail_out === 0) {\n      return BS_NEED_MORE;\n    }\n  }\n  return BS_BLOCK_DONE;\n};\nvar deflate_slow = (s, flush) => {\n  let hash_head;\n  let bflush;\n  let max_insert;\n  for (; ; ) {\n    if (s.lookahead < MIN_LOOKAHEAD) {\n      fill_window(s);\n      if (s.lookahead < MIN_LOOKAHEAD && flush === Z_NO_FLUSH$2) {\n        return BS_NEED_MORE;\n      }\n      if (s.lookahead === 0) {\n        break;\n      }\n    }\n    hash_head = 0;\n    if (s.lookahead >= MIN_MATCH) {\n      s.ins_h = HASH(s, s.ins_h, s.window[s.strstart + MIN_MATCH - 1]);\n      hash_head = s.prev[s.strstart & s.w_mask] = s.head[s.ins_h];\n      s.head[s.ins_h] = s.strstart;\n    }\n    s.prev_length = s.match_length;\n    s.prev_match = s.match_start;\n    s.match_length = MIN_MATCH - 1;\n    if (hash_head !== 0 && s.prev_length < s.max_lazy_match && s.strstart - hash_head <= s.w_size - MIN_LOOKAHEAD) {\n      s.match_length = longest_match(s, hash_head);\n      if (s.match_length <= 5 && (s.strategy === Z_FILTERED || s.match_length === MIN_MATCH && s.strstart - s.match_start > 4096)) {\n        s.match_length = MIN_MATCH - 1;\n      }\n    }\n    if (s.prev_length >= MIN_MATCH && s.match_length <= s.prev_length) {\n      max_insert = s.strstart + s.lookahead - MIN_MATCH;\n      bflush = _tr_tally(s, s.strstart - 1 - s.prev_match, s.prev_length - MIN_MATCH);\n      s.lookahead -= s.prev_length - 1;\n      s.prev_length -= 2;\n      do {\n        if (++s.strstart <= max_insert) {\n          s.ins_h = HASH(s, s.ins_h, s.window[s.strstart + MIN_MATCH - 1]);\n          hash_head = s.prev[s.strstart & s.w_mask] = s.head[s.ins_h];\n          s.head[s.ins_h] = s.strstart;\n        }\n      } while (--s.prev_length !== 0);\n      s.match_available = 0;\n      s.match_length = MIN_MATCH - 1;\n      s.strstart++;\n      if (bflush) {\n        flush_block_only(s, false);\n        if (s.strm.avail_out === 0) {\n          return BS_NEED_MORE;\n        }\n      }\n    } else if (s.match_available) {\n      bflush = _tr_tally(s, 0, s.window[s.strstart - 1]);\n      if (bflush) {\n        flush_block_only(s, false);\n      }\n      s.strstart++;\n      s.lookahead--;\n      if (s.strm.avail_out === 0) {\n        return BS_NEED_MORE;\n      }\n    } else {\n      s.match_available = 1;\n      s.strstart++;\n      s.lookahead--;\n    }\n  }\n  if (s.match_available) {\n    bflush = _tr_tally(s, 0, s.window[s.strstart - 1]);\n    s.match_available = 0;\n  }\n  s.insert = s.strstart < MIN_MATCH - 1 ? s.strstart : MIN_MATCH - 1;\n  if (flush === Z_FINISH$3) {\n    flush_block_only(s, true);\n    if (s.strm.avail_out === 0) {\n      return BS_FINISH_STARTED;\n    }\n    return BS_FINISH_DONE;\n  }\n  if (s.last_lit) {\n    flush_block_only(s, false);\n    if (s.strm.avail_out === 0) {\n      return BS_NEED_MORE;\n    }\n  }\n  return BS_BLOCK_DONE;\n};\nvar deflate_rle = (s, flush) => {\n  let bflush;\n  let prev;\n  let scan, strend;\n  const _win = s.window;\n  for (; ; ) {\n    if (s.lookahead <= MAX_MATCH) {\n      fill_window(s);\n      if (s.lookahead <= MAX_MATCH && flush === Z_NO_FLUSH$2) {\n        return BS_NEED_MORE;\n      }\n      if (s.lookahead === 0) {\n        break;\n      }\n    }\n    s.match_length = 0;\n    if (s.lookahead >= MIN_MATCH && s.strstart > 0) {\n      scan = s.strstart - 1;\n      prev = _win[scan];\n      if (prev === _win[++scan] && prev === _win[++scan] && prev === _win[++scan]) {\n        strend = s.strstart + MAX_MATCH;\n        do {\n        } while (prev === _win[++scan] && prev === _win[++scan] && prev === _win[++scan] && prev === _win[++scan] && prev === _win[++scan] && prev === _win[++scan] && prev === _win[++scan] && prev === _win[++scan] && scan < strend);\n        s.match_length = MAX_MATCH - (strend - scan);\n        if (s.match_length > s.lookahead) {\n          s.match_length = s.lookahead;\n        }\n      }\n    }\n    if (s.match_length >= MIN_MATCH) {\n      bflush = _tr_tally(s, 1, s.match_length - MIN_MATCH);\n      s.lookahead -= s.match_length;\n      s.strstart += s.match_length;\n      s.match_length = 0;\n    } else {\n      bflush = _tr_tally(s, 0, s.window[s.strstart]);\n      s.lookahead--;\n      s.strstart++;\n    }\n    if (bflush) {\n      flush_block_only(s, false);\n      if (s.strm.avail_out === 0) {\n        return BS_NEED_MORE;\n      }\n    }\n  }\n  s.insert = 0;\n  if (flush === Z_FINISH$3) {\n    flush_block_only(s, true);\n    if (s.strm.avail_out === 0) {\n      return BS_FINISH_STARTED;\n    }\n    return BS_FINISH_DONE;\n  }\n  if (s.last_lit) {\n    flush_block_only(s, false);\n    if (s.strm.avail_out === 0) {\n      return BS_NEED_MORE;\n    }\n  }\n  return BS_BLOCK_DONE;\n};\nvar deflate_huff = (s, flush) => {\n  let bflush;\n  for (; ; ) {\n    if (s.lookahead === 0) {\n      fill_window(s);\n      if (s.lookahead === 0) {\n        if (flush === Z_NO_FLUSH$2) {\n          return BS_NEED_MORE;\n        }\n        break;\n      }\n    }\n    s.match_length = 0;\n    bflush = _tr_tally(s, 0, s.window[s.strstart]);\n    s.lookahead--;\n    s.strstart++;\n    if (bflush) {\n      flush_block_only(s, false);\n      if (s.strm.avail_out === 0) {\n        return BS_NEED_MORE;\n      }\n    }\n  }\n  s.insert = 0;\n  if (flush === Z_FINISH$3) {\n    flush_block_only(s, true);\n    if (s.strm.avail_out === 0) {\n      return BS_FINISH_STARTED;\n    }\n    return BS_FINISH_DONE;\n  }\n  if (s.last_lit) {\n    flush_block_only(s, false);\n    if (s.strm.avail_out === 0) {\n      return BS_NEED_MORE;\n    }\n  }\n  return BS_BLOCK_DONE;\n};\nfunction Config(good_length, max_lazy, nice_length, max_chain, func) {\n  this.good_length = good_length;\n  this.max_lazy = max_lazy;\n  this.nice_length = nice_length;\n  this.max_chain = max_chain;\n  this.func = func;\n}\nvar configuration_table = [\n  new Config(0, 0, 0, 0, deflate_stored),\n  new Config(4, 4, 8, 4, deflate_fast),\n  new Config(4, 5, 16, 8, deflate_fast),\n  new Config(4, 6, 32, 32, deflate_fast),\n  new Config(4, 4, 16, 16, deflate_slow),\n  new Config(8, 16, 32, 32, deflate_slow),\n  new Config(8, 16, 128, 128, deflate_slow),\n  new Config(8, 32, 128, 256, deflate_slow),\n  new Config(32, 128, 258, 1024, deflate_slow),\n  new Config(32, 258, 258, 4096, deflate_slow)\n];\nvar lm_init = (s) => {\n  s.window_size = 2 * s.w_size;\n  zero(s.head);\n  s.max_lazy_match = configuration_table[s.level].max_lazy;\n  s.good_match = configuration_table[s.level].good_length;\n  s.nice_match = configuration_table[s.level].nice_length;\n  s.max_chain_length = configuration_table[s.level].max_chain;\n  s.strstart = 0;\n  s.block_start = 0;\n  s.lookahead = 0;\n  s.insert = 0;\n  s.match_length = s.prev_length = MIN_MATCH - 1;\n  s.match_available = 0;\n  s.ins_h = 0;\n};\nfunction DeflateState() {\n  this.strm = null;\n  this.status = 0;\n  this.pending_buf = null;\n  this.pending_buf_size = 0;\n  this.pending_out = 0;\n  this.pending = 0;\n  this.wrap = 0;\n  this.gzhead = null;\n  this.gzindex = 0;\n  this.method = Z_DEFLATED$2;\n  this.last_flush = -1;\n  this.w_size = 0;\n  this.w_bits = 0;\n  this.w_mask = 0;\n  this.window = null;\n  this.window_size = 0;\n  this.prev = null;\n  this.head = null;\n  this.ins_h = 0;\n  this.hash_size = 0;\n  this.hash_bits = 0;\n  this.hash_mask = 0;\n  this.hash_shift = 0;\n  this.block_start = 0;\n  this.match_length = 0;\n  this.prev_match = 0;\n  this.match_available = 0;\n  this.strstart = 0;\n  this.match_start = 0;\n  this.lookahead = 0;\n  this.prev_length = 0;\n  this.max_chain_length = 0;\n  this.max_lazy_match = 0;\n  this.level = 0;\n  this.strategy = 0;\n  this.good_match = 0;\n  this.nice_match = 0;\n  this.dyn_ltree = new Uint16Array(HEAP_SIZE * 2);\n  this.dyn_dtree = new Uint16Array((2 * D_CODES + 1) * 2);\n  this.bl_tree = new Uint16Array((2 * BL_CODES + 1) * 2);\n  zero(this.dyn_ltree);\n  zero(this.dyn_dtree);\n  zero(this.bl_tree);\n  this.l_desc = null;\n  this.d_desc = null;\n  this.bl_desc = null;\n  this.bl_count = new Uint16Array(MAX_BITS + 1);\n  this.heap = new Uint16Array(2 * L_CODES + 1);\n  zero(this.heap);\n  this.heap_len = 0;\n  this.heap_max = 0;\n  this.depth = new Uint16Array(2 * L_CODES + 1);\n  zero(this.depth);\n  this.l_buf = 0;\n  this.lit_bufsize = 0;\n  this.last_lit = 0;\n  this.d_buf = 0;\n  this.opt_len = 0;\n  this.static_len = 0;\n  this.matches = 0;\n  this.insert = 0;\n  this.bi_buf = 0;\n  this.bi_valid = 0;\n}\nvar deflateResetKeep = (strm) => {\n  if (!strm || !strm.state) {\n    return err(strm, Z_STREAM_ERROR$2);\n  }\n  strm.total_in = strm.total_out = 0;\n  strm.data_type = Z_UNKNOWN;\n  const s = strm.state;\n  s.pending = 0;\n  s.pending_out = 0;\n  if (s.wrap < 0) {\n    s.wrap = -s.wrap;\n  }\n  s.status = s.wrap ? INIT_STATE : BUSY_STATE;\n  strm.adler = s.wrap === 2 ? 0 : 1;\n  s.last_flush = Z_NO_FLUSH$2;\n  _tr_init(s);\n  return Z_OK$3;\n};\nvar deflateReset = (strm) => {\n  const ret = deflateResetKeep(strm);\n  if (ret === Z_OK$3) {\n    lm_init(strm.state);\n  }\n  return ret;\n};\nvar deflateSetHeader = (strm, head) => {\n  if (!strm || !strm.state) {\n    return Z_STREAM_ERROR$2;\n  }\n  if (strm.state.wrap !== 2) {\n    return Z_STREAM_ERROR$2;\n  }\n  strm.state.gzhead = head;\n  return Z_OK$3;\n};\nvar deflateInit2 = (strm, level, method, windowBits, memLevel, strategy) => {\n  if (!strm) {\n    return Z_STREAM_ERROR$2;\n  }\n  let wrap = 1;\n  if (level === Z_DEFAULT_COMPRESSION$1) {\n    level = 6;\n  }\n  if (windowBits < 0) {\n    wrap = 0;\n    windowBits = -windowBits;\n  } else if (windowBits > 15) {\n    wrap = 2;\n    windowBits -= 16;\n  }\n  if (memLevel < 1 || memLevel > MAX_MEM_LEVEL || method !== Z_DEFLATED$2 || windowBits < 8 || windowBits > 15 || level < 0 || level > 9 || strategy < 0 || strategy > Z_FIXED) {\n    return err(strm, Z_STREAM_ERROR$2);\n  }\n  if (windowBits === 8) {\n    windowBits = 9;\n  }\n  const s = new DeflateState();\n  strm.state = s;\n  s.strm = strm;\n  s.wrap = wrap;\n  s.gzhead = null;\n  s.w_bits = windowBits;\n  s.w_size = 1 << s.w_bits;\n  s.w_mask = s.w_size - 1;\n  s.hash_bits = memLevel + 7;\n  s.hash_size = 1 << s.hash_bits;\n  s.hash_mask = s.hash_size - 1;\n  s.hash_shift = ~~((s.hash_bits + MIN_MATCH - 1) / MIN_MATCH);\n  s.window = new Uint8Array(s.w_size * 2);\n  s.head = new Uint16Array(s.hash_size);\n  s.prev = new Uint16Array(s.w_size);\n  s.lit_bufsize = 1 << memLevel + 6;\n  s.pending_buf_size = s.lit_bufsize * 4;\n  s.pending_buf = new Uint8Array(s.pending_buf_size);\n  s.d_buf = 1 * s.lit_bufsize;\n  s.l_buf = (1 + 2) * s.lit_bufsize;\n  s.level = level;\n  s.strategy = strategy;\n  s.method = method;\n  return deflateReset(strm);\n};\nvar deflateInit = (strm, level) => {\n  return deflateInit2(strm, level, Z_DEFLATED$2, MAX_WBITS$1, DEF_MEM_LEVEL, Z_DEFAULT_STRATEGY$1);\n};\nvar deflate$2 = (strm, flush) => {\n  let beg, val;\n  if (!strm || !strm.state || flush > Z_BLOCK$1 || flush < 0) {\n    return strm ? err(strm, Z_STREAM_ERROR$2) : Z_STREAM_ERROR$2;\n  }\n  const s = strm.state;\n  if (!strm.output || !strm.input && strm.avail_in !== 0 || s.status === FINISH_STATE && flush !== Z_FINISH$3) {\n    return err(strm, strm.avail_out === 0 ? Z_BUF_ERROR$1 : Z_STREAM_ERROR$2);\n  }\n  s.strm = strm;\n  const old_flush = s.last_flush;\n  s.last_flush = flush;\n  if (s.status === INIT_STATE) {\n    if (s.wrap === 2) {\n      strm.adler = 0;\n      put_byte(s, 31);\n      put_byte(s, 139);\n      put_byte(s, 8);\n      if (!s.gzhead) {\n        put_byte(s, 0);\n        put_byte(s, 0);\n        put_byte(s, 0);\n        put_byte(s, 0);\n        put_byte(s, 0);\n        put_byte(s, s.level === 9 ? 2 : s.strategy >= Z_HUFFMAN_ONLY || s.level < 2 ? 4 : 0);\n        put_byte(s, OS_CODE);\n        s.status = BUSY_STATE;\n      } else {\n        put_byte(s, (s.gzhead.text ? 1 : 0) + (s.gzhead.hcrc ? 2 : 0) + (!s.gzhead.extra ? 0 : 4) + (!s.gzhead.name ? 0 : 8) + (!s.gzhead.comment ? 0 : 16));\n        put_byte(s, s.gzhead.time & 255);\n        put_byte(s, s.gzhead.time >> 8 & 255);\n        put_byte(s, s.gzhead.time >> 16 & 255);\n        put_byte(s, s.gzhead.time >> 24 & 255);\n        put_byte(s, s.level === 9 ? 2 : s.strategy >= Z_HUFFMAN_ONLY || s.level < 2 ? 4 : 0);\n        put_byte(s, s.gzhead.os & 255);\n        if (s.gzhead.extra && s.gzhead.extra.length) {\n          put_byte(s, s.gzhead.extra.length & 255);\n          put_byte(s, s.gzhead.extra.length >> 8 & 255);\n        }\n        if (s.gzhead.hcrc) {\n          strm.adler = crc32_1(strm.adler, s.pending_buf, s.pending, 0);\n        }\n        s.gzindex = 0;\n        s.status = EXTRA_STATE;\n      }\n    } else {\n      let header = Z_DEFLATED$2 + (s.w_bits - 8 << 4) << 8;\n      let level_flags = -1;\n      if (s.strategy >= Z_HUFFMAN_ONLY || s.level < 2) {\n        level_flags = 0;\n      } else if (s.level < 6) {\n        level_flags = 1;\n      } else if (s.level === 6) {\n        level_flags = 2;\n      } else {\n        level_flags = 3;\n      }\n      header |= level_flags << 6;\n      if (s.strstart !== 0) {\n        header |= PRESET_DICT;\n      }\n      header += 31 - header % 31;\n      s.status = BUSY_STATE;\n      putShortMSB(s, header);\n      if (s.strstart !== 0) {\n        putShortMSB(s, strm.adler >>> 16);\n        putShortMSB(s, strm.adler & 65535);\n      }\n      strm.adler = 1;\n    }\n  }\n  if (s.status === EXTRA_STATE) {\n    if (s.gzhead.extra) {\n      beg = s.pending;\n      while (s.gzindex < (s.gzhead.extra.length & 65535)) {\n        if (s.pending === s.pending_buf_size) {\n          if (s.gzhead.hcrc && s.pending > beg) {\n            strm.adler = crc32_1(strm.adler, s.pending_buf, s.pending - beg, beg);\n          }\n          flush_pending(strm);\n          beg = s.pending;\n          if (s.pending === s.pending_buf_size) {\n            break;\n          }\n        }\n        put_byte(s, s.gzhead.extra[s.gzindex] & 255);\n        s.gzindex++;\n      }\n      if (s.gzhead.hcrc && s.pending > beg) {\n        strm.adler = crc32_1(strm.adler, s.pending_buf, s.pending - beg, beg);\n      }\n      if (s.gzindex === s.gzhead.extra.length) {\n        s.gzindex = 0;\n        s.status = NAME_STATE;\n      }\n    } else {\n      s.status = NAME_STATE;\n    }\n  }\n  if (s.status === NAME_STATE) {\n    if (s.gzhead.name) {\n      beg = s.pending;\n      do {\n        if (s.pending === s.pending_buf_size) {\n          if (s.gzhead.hcrc && s.pending > beg) {\n            strm.adler = crc32_1(strm.adler, s.pending_buf, s.pending - beg, beg);\n          }\n          flush_pending(strm);\n          beg = s.pending;\n          if (s.pending === s.pending_buf_size) {\n            val = 1;\n            break;\n          }\n        }\n        if (s.gzindex < s.gzhead.name.length) {\n          val = s.gzhead.name.charCodeAt(s.gzindex++) & 255;\n        } else {\n          val = 0;\n        }\n        put_byte(s, val);\n      } while (val !== 0);\n      if (s.gzhead.hcrc && s.pending > beg) {\n        strm.adler = crc32_1(strm.adler, s.pending_buf, s.pending - beg, beg);\n      }\n      if (val === 0) {\n        s.gzindex = 0;\n        s.status = COMMENT_STATE;\n      }\n    } else {\n      s.status = COMMENT_STATE;\n    }\n  }\n  if (s.status === COMMENT_STATE) {\n    if (s.gzhead.comment) {\n      beg = s.pending;\n      do {\n        if (s.pending === s.pending_buf_size) {\n          if (s.gzhead.hcrc && s.pending > beg) {\n            strm.adler = crc32_1(strm.adler, s.pending_buf, s.pending - beg, beg);\n          }\n          flush_pending(strm);\n          beg = s.pending;\n          if (s.pending === s.pending_buf_size) {\n            val = 1;\n            break;\n          }\n        }\n        if (s.gzindex < s.gzhead.comment.length) {\n          val = s.gzhead.comment.charCodeAt(s.gzindex++) & 255;\n        } else {\n          val = 0;\n        }\n        put_byte(s, val);\n      } while (val !== 0);\n      if (s.gzhead.hcrc && s.pending > beg) {\n        strm.adler = crc32_1(strm.adler, s.pending_buf, s.pending - beg, beg);\n      }\n      if (val === 0) {\n        s.status = HCRC_STATE;\n      }\n    } else {\n      s.status = HCRC_STATE;\n    }\n  }\n  if (s.status === HCRC_STATE) {\n    if (s.gzhead.hcrc) {\n      if (s.pending + 2 > s.pending_buf_size) {\n        flush_pending(strm);\n      }\n      if (s.pending + 2 <= s.pending_buf_size) {\n        put_byte(s, strm.adler & 255);\n        put_byte(s, strm.adler >> 8 & 255);\n        strm.adler = 0;\n        s.status = BUSY_STATE;\n      }\n    } else {\n      s.status = BUSY_STATE;\n    }\n  }\n  if (s.pending !== 0) {\n    flush_pending(strm);\n    if (strm.avail_out === 0) {\n      s.last_flush = -1;\n      return Z_OK$3;\n    }\n  } else if (strm.avail_in === 0 && rank(flush) <= rank(old_flush) && flush !== Z_FINISH$3) {\n    return err(strm, Z_BUF_ERROR$1);\n  }\n  if (s.status === FINISH_STATE && strm.avail_in !== 0) {\n    return err(strm, Z_BUF_ERROR$1);\n  }\n  if (strm.avail_in !== 0 || s.lookahead !== 0 || flush !== Z_NO_FLUSH$2 && s.status !== FINISH_STATE) {\n    let bstate = s.strategy === Z_HUFFMAN_ONLY ? deflate_huff(s, flush) : s.strategy === Z_RLE ? deflate_rle(s, flush) : configuration_table[s.level].func(s, flush);\n    if (bstate === BS_FINISH_STARTED || bstate === BS_FINISH_DONE) {\n      s.status = FINISH_STATE;\n    }\n    if (bstate === BS_NEED_MORE || bstate === BS_FINISH_STARTED) {\n      if (strm.avail_out === 0) {\n        s.last_flush = -1;\n      }\n      return Z_OK$3;\n    }\n    if (bstate === BS_BLOCK_DONE) {\n      if (flush === Z_PARTIAL_FLUSH) {\n        _tr_align(s);\n      } else if (flush !== Z_BLOCK$1) {\n        _tr_stored_block(s, 0, 0, false);\n        if (flush === Z_FULL_FLUSH$1) {\n          zero(s.head);\n          if (s.lookahead === 0) {\n            s.strstart = 0;\n            s.block_start = 0;\n            s.insert = 0;\n          }\n        }\n      }\n      flush_pending(strm);\n      if (strm.avail_out === 0) {\n        s.last_flush = -1;\n        return Z_OK$3;\n      }\n    }\n  }\n  if (flush !== Z_FINISH$3) {\n    return Z_OK$3;\n  }\n  if (s.wrap <= 0) {\n    return Z_STREAM_END$3;\n  }\n  if (s.wrap === 2) {\n    put_byte(s, strm.adler & 255);\n    put_byte(s, strm.adler >> 8 & 255);\n    put_byte(s, strm.adler >> 16 & 255);\n    put_byte(s, strm.adler >> 24 & 255);\n    put_byte(s, strm.total_in & 255);\n    put_byte(s, strm.total_in >> 8 & 255);\n    put_byte(s, strm.total_in >> 16 & 255);\n    put_byte(s, strm.total_in >> 24 & 255);\n  } else {\n    putShortMSB(s, strm.adler >>> 16);\n    putShortMSB(s, strm.adler & 65535);\n  }\n  flush_pending(strm);\n  if (s.wrap > 0) {\n    s.wrap = -s.wrap;\n  }\n  return s.pending !== 0 ? Z_OK$3 : Z_STREAM_END$3;\n};\nvar deflateEnd = (strm) => {\n  if (!strm || !strm.state) {\n    return Z_STREAM_ERROR$2;\n  }\n  const status = strm.state.status;\n  if (status !== INIT_STATE && status !== EXTRA_STATE && status !== NAME_STATE && status !== COMMENT_STATE && status !== HCRC_STATE && status !== BUSY_STATE && status !== FINISH_STATE) {\n    return err(strm, Z_STREAM_ERROR$2);\n  }\n  strm.state = null;\n  return status === BUSY_STATE ? err(strm, Z_DATA_ERROR$2) : Z_OK$3;\n};\nvar deflateSetDictionary = (strm, dictionary) => {\n  let dictLength = dictionary.length;\n  if (!strm || !strm.state) {\n    return Z_STREAM_ERROR$2;\n  }\n  const s = strm.state;\n  const wrap = s.wrap;\n  if (wrap === 2 || wrap === 1 && s.status !== INIT_STATE || s.lookahead) {\n    return Z_STREAM_ERROR$2;\n  }\n  if (wrap === 1) {\n    strm.adler = adler32_1(strm.adler, dictionary, dictLength, 0);\n  }\n  s.wrap = 0;\n  if (dictLength >= s.w_size) {\n    if (wrap === 0) {\n      zero(s.head);\n      s.strstart = 0;\n      s.block_start = 0;\n      s.insert = 0;\n    }\n    let tmpDict = new Uint8Array(s.w_size);\n    tmpDict.set(dictionary.subarray(dictLength - s.w_size, dictLength), 0);\n    dictionary = tmpDict;\n    dictLength = s.w_size;\n  }\n  const avail = strm.avail_in;\n  const next = strm.next_in;\n  const input = strm.input;\n  strm.avail_in = dictLength;\n  strm.next_in = 0;\n  strm.input = dictionary;\n  fill_window(s);\n  while (s.lookahead >= MIN_MATCH) {\n    let str = s.strstart;\n    let n = s.lookahead - (MIN_MATCH - 1);\n    do {\n      s.ins_h = HASH(s, s.ins_h, s.window[str + MIN_MATCH - 1]);\n      s.prev[str & s.w_mask] = s.head[s.ins_h];\n      s.head[s.ins_h] = str;\n      str++;\n    } while (--n);\n    s.strstart = str;\n    s.lookahead = MIN_MATCH - 1;\n    fill_window(s);\n  }\n  s.strstart += s.lookahead;\n  s.block_start = s.strstart;\n  s.insert = s.lookahead;\n  s.lookahead = 0;\n  s.match_length = s.prev_length = MIN_MATCH - 1;\n  s.match_available = 0;\n  strm.next_in = next;\n  strm.input = input;\n  strm.avail_in = avail;\n  s.wrap = wrap;\n  return Z_OK$3;\n};\nvar deflateInit_1 = deflateInit;\nvar deflateInit2_1 = deflateInit2;\nvar deflateReset_1 = deflateReset;\nvar deflateResetKeep_1 = deflateResetKeep;\nvar deflateSetHeader_1 = deflateSetHeader;\nvar deflate_2$1 = deflate$2;\nvar deflateEnd_1 = deflateEnd;\nvar deflateSetDictionary_1 = deflateSetDictionary;\nvar deflateInfo = \"pako deflate (from Nodeca project)\";\nvar deflate_1$2 = {\n  deflateInit: deflateInit_1,\n  deflateInit2: deflateInit2_1,\n  deflateReset: deflateReset_1,\n  deflateResetKeep: deflateResetKeep_1,\n  deflateSetHeader: deflateSetHeader_1,\n  deflate: deflate_2$1,\n  deflateEnd: deflateEnd_1,\n  deflateSetDictionary: deflateSetDictionary_1,\n  deflateInfo\n};\nvar _has = (obj, key) => {\n  return Object.prototype.hasOwnProperty.call(obj, key);\n};\nvar assign = function(obj) {\n  const sources = Array.prototype.slice.call(arguments, 1);\n  while (sources.length) {\n    const source = sources.shift();\n    if (!source) {\n      continue;\n    }\n    if (typeof source !== \"object\") {\n      throw new TypeError(source + \"must be non-object\");\n    }\n    for (const p in source) {\n      if (_has(source, p)) {\n        obj[p] = source[p];\n      }\n    }\n  }\n  return obj;\n};\nvar flattenChunks = (chunks) => {\n  let len = 0;\n  for (let i = 0, l = chunks.length; i < l; i++) {\n    len += chunks[i].length;\n  }\n  const result = new Uint8Array(len);\n  for (let i = 0, pos = 0, l = chunks.length; i < l; i++) {\n    let chunk = chunks[i];\n    result.set(chunk, pos);\n    pos += chunk.length;\n  }\n  return result;\n};\nvar common = {\n  assign,\n  flattenChunks\n};\nvar STR_APPLY_UIA_OK = true;\ntry {\n  String.fromCharCode.apply(null, new Uint8Array(1));\n} catch (__) {\n  STR_APPLY_UIA_OK = false;\n}\nvar _utf8len = new Uint8Array(256);\nfor (let q = 0; q < 256; q++) {\n  _utf8len[q] = q >= 252 ? 6 : q >= 248 ? 5 : q >= 240 ? 4 : q >= 224 ? 3 : q >= 192 ? 2 : 1;\n}\n_utf8len[254] = _utf8len[254] = 1;\nvar string2buf = (str) => {\n  if (typeof TextEncoder === \"function\" && TextEncoder.prototype.encode) {\n    return new TextEncoder().encode(str);\n  }\n  let buf, c, c2, m_pos, i, str_len = str.length, buf_len = 0;\n  for (m_pos = 0; m_pos < str_len; m_pos++) {\n    c = str.charCodeAt(m_pos);\n    if ((c & 64512) === 55296 && m_pos + 1 < str_len) {\n      c2 = str.charCodeAt(m_pos + 1);\n      if ((c2 & 64512) === 56320) {\n        c = 65536 + (c - 55296 << 10) + (c2 - 56320);\n        m_pos++;\n      }\n    }\n    buf_len += c < 128 ? 1 : c < 2048 ? 2 : c < 65536 ? 3 : 4;\n  }\n  buf = new Uint8Array(buf_len);\n  for (i = 0, m_pos = 0; i < buf_len; m_pos++) {\n    c = str.charCodeAt(m_pos);\n    if ((c & 64512) === 55296 && m_pos + 1 < str_len) {\n      c2 = str.charCodeAt(m_pos + 1);\n      if ((c2 & 64512) === 56320) {\n        c = 65536 + (c - 55296 << 10) + (c2 - 56320);\n        m_pos++;\n      }\n    }\n    if (c < 128) {\n      buf[i++] = c;\n    } else if (c < 2048) {\n      buf[i++] = 192 | c >>> 6;\n      buf[i++] = 128 | c & 63;\n    } else if (c < 65536) {\n      buf[i++] = 224 | c >>> 12;\n      buf[i++] = 128 | c >>> 6 & 63;\n      buf[i++] = 128 | c & 63;\n    } else {\n      buf[i++] = 240 | c >>> 18;\n      buf[i++] = 128 | c >>> 12 & 63;\n      buf[i++] = 128 | c >>> 6 & 63;\n      buf[i++] = 128 | c & 63;\n    }\n  }\n  return buf;\n};\nvar buf2binstring = (buf, len) => {\n  if (len < 65534) {\n    if (buf.subarray && STR_APPLY_UIA_OK) {\n      return String.fromCharCode.apply(null, buf.length === len ? buf : buf.subarray(0, len));\n    }\n  }\n  let result = \"\";\n  for (let i = 0; i < len; i++) {\n    result += String.fromCharCode(buf[i]);\n  }\n  return result;\n};\nvar buf2string = (buf, max) => {\n  const len = max || buf.length;\n  if (typeof TextDecoder === \"function\" && TextDecoder.prototype.decode) {\n    return new TextDecoder().decode(buf.subarray(0, max));\n  }\n  let i, out;\n  const utf16buf = new Array(len * 2);\n  for (out = 0, i = 0; i < len; ) {\n    let c = buf[i++];\n    if (c < 128) {\n      utf16buf[out++] = c;\n      continue;\n    }\n    let c_len = _utf8len[c];\n    if (c_len > 4) {\n      utf16buf[out++] = 65533;\n      i += c_len - 1;\n      continue;\n    }\n    c &= c_len === 2 ? 31 : c_len === 3 ? 15 : 7;\n    while (c_len > 1 && i < len) {\n      c = c << 6 | buf[i++] & 63;\n      c_len--;\n    }\n    if (c_len > 1) {\n      utf16buf[out++] = 65533;\n      continue;\n    }\n    if (c < 65536) {\n      utf16buf[out++] = c;\n    } else {\n      c -= 65536;\n      utf16buf[out++] = 55296 | c >> 10 & 1023;\n      utf16buf[out++] = 56320 | c & 1023;\n    }\n  }\n  return buf2binstring(utf16buf, out);\n};\nvar utf8border = (buf, max) => {\n  max = max || buf.length;\n  if (max > buf.length) {\n    max = buf.length;\n  }\n  let pos = max - 1;\n  while (pos >= 0 && (buf[pos] & 192) === 128) {\n    pos--;\n  }\n  if (pos < 0) {\n    return max;\n  }\n  if (pos === 0) {\n    return max;\n  }\n  return pos + _utf8len[buf[pos]] > max ? pos : max;\n};\nvar strings = {\n  string2buf,\n  buf2string,\n  utf8border\n};\nfunction ZStream() {\n  this.input = null;\n  this.next_in = 0;\n  this.avail_in = 0;\n  this.total_in = 0;\n  this.output = null;\n  this.next_out = 0;\n  this.avail_out = 0;\n  this.total_out = 0;\n  this.msg = \"\";\n  this.state = null;\n  this.data_type = 2;\n  this.adler = 0;\n}\nvar zstream = ZStream;\nvar toString$1 = Object.prototype.toString;\nvar {\n  Z_NO_FLUSH: Z_NO_FLUSH$1,\n  Z_SYNC_FLUSH,\n  Z_FULL_FLUSH,\n  Z_FINISH: Z_FINISH$2,\n  Z_OK: Z_OK$2,\n  Z_STREAM_END: Z_STREAM_END$2,\n  Z_DEFAULT_COMPRESSION,\n  Z_DEFAULT_STRATEGY,\n  Z_DEFLATED: Z_DEFLATED$1\n} = constants$2;\nfunction Deflate$1(options) {\n  this.options = common.assign({\n    level: Z_DEFAULT_COMPRESSION,\n    method: Z_DEFLATED$1,\n    chunkSize: 16384,\n    windowBits: 15,\n    memLevel: 8,\n    strategy: Z_DEFAULT_STRATEGY\n  }, options || {});\n  let opt = this.options;\n  if (opt.raw && opt.windowBits > 0) {\n    opt.windowBits = -opt.windowBits;\n  } else if (opt.gzip && opt.windowBits > 0 && opt.windowBits < 16) {\n    opt.windowBits += 16;\n  }\n  this.err = 0;\n  this.msg = \"\";\n  this.ended = false;\n  this.chunks = [];\n  this.strm = new zstream();\n  this.strm.avail_out = 0;\n  let status = deflate_1$2.deflateInit2(this.strm, opt.level, opt.method, opt.windowBits, opt.memLevel, opt.strategy);\n  if (status !== Z_OK$2) {\n    throw new Error(messages[status]);\n  }\n  if (opt.header) {\n    deflate_1$2.deflateSetHeader(this.strm, opt.header);\n  }\n  if (opt.dictionary) {\n    let dict;\n    if (typeof opt.dictionary === \"string\") {\n      dict = strings.string2buf(opt.dictionary);\n    } else if (toString$1.call(opt.dictionary) === \"[object ArrayBuffer]\") {\n      dict = new Uint8Array(opt.dictionary);\n    } else {\n      dict = opt.dictionary;\n    }\n    status = deflate_1$2.deflateSetDictionary(this.strm, dict);\n    if (status !== Z_OK$2) {\n      throw new Error(messages[status]);\n    }\n    this._dict_set = true;\n  }\n}\nDeflate$1.prototype.push = function(data, flush_mode) {\n  const strm = this.strm;\n  const chunkSize = this.options.chunkSize;\n  let status, _flush_mode;\n  if (this.ended) {\n    return false;\n  }\n  if (flush_mode === ~~flush_mode)\n    _flush_mode = flush_mode;\n  else\n    _flush_mode = flush_mode === true ? Z_FINISH$2 : Z_NO_FLUSH$1;\n  if (typeof data === \"string\") {\n    strm.input = strings.string2buf(data);\n  } else if (toString$1.call(data) === \"[object ArrayBuffer]\") {\n    strm.input = new Uint8Array(data);\n  } else {\n    strm.input = data;\n  }\n  strm.next_in = 0;\n  strm.avail_in = strm.input.length;\n  for (; ; ) {\n    if (strm.avail_out === 0) {\n      strm.output = new Uint8Array(chunkSize);\n      strm.next_out = 0;\n      strm.avail_out = chunkSize;\n    }\n    if ((_flush_mode === Z_SYNC_FLUSH || _flush_mode === Z_FULL_FLUSH) && strm.avail_out <= 6) {\n      this.onData(strm.output.subarray(0, strm.next_out));\n      strm.avail_out = 0;\n      continue;\n    }\n    status = deflate_1$2.deflate(strm, _flush_mode);\n    if (status === Z_STREAM_END$2) {\n      if (strm.next_out > 0) {\n        this.onData(strm.output.subarray(0, strm.next_out));\n      }\n      status = deflate_1$2.deflateEnd(this.strm);\n      this.onEnd(status);\n      this.ended = true;\n      return status === Z_OK$2;\n    }\n    if (strm.avail_out === 0) {\n      this.onData(strm.output);\n      continue;\n    }\n    if (_flush_mode > 0 && strm.next_out > 0) {\n      this.onData(strm.output.subarray(0, strm.next_out));\n      strm.avail_out = 0;\n      continue;\n    }\n    if (strm.avail_in === 0)\n      break;\n  }\n  return true;\n};\nDeflate$1.prototype.onData = function(chunk) {\n  this.chunks.push(chunk);\n};\nDeflate$1.prototype.onEnd = function(status) {\n  if (status === Z_OK$2) {\n    this.result = common.flattenChunks(this.chunks);\n  }\n  this.chunks = [];\n  this.err = status;\n  this.msg = this.strm.msg;\n};\nvar BAD$1 = 30;\nvar TYPE$1 = 12;\nvar inffast = function inflate_fast(strm, start) {\n  let _in;\n  let last;\n  let _out;\n  let beg;\n  let end;\n  let dmax;\n  let wsize;\n  let whave;\n  let wnext;\n  let s_window;\n  let hold;\n  let bits;\n  let lcode;\n  let dcode;\n  let lmask;\n  let dmask;\n  let here;\n  let op;\n  let len;\n  let dist;\n  let from;\n  let from_source;\n  let input, output;\n  const state = strm.state;\n  _in = strm.next_in;\n  input = strm.input;\n  last = _in + (strm.avail_in - 5);\n  _out = strm.next_out;\n  output = strm.output;\n  beg = _out - (start - strm.avail_out);\n  end = _out + (strm.avail_out - 257);\n  dmax = state.dmax;\n  wsize = state.wsize;\n  whave = state.whave;\n  wnext = state.wnext;\n  s_window = state.window;\n  hold = state.hold;\n  bits = state.bits;\n  lcode = state.lencode;\n  dcode = state.distcode;\n  lmask = (1 << state.lenbits) - 1;\n  dmask = (1 << state.distbits) - 1;\n  top:\n    do {\n      if (bits < 15) {\n        hold += input[_in++] << bits;\n        bits += 8;\n        hold += input[_in++] << bits;\n        bits += 8;\n      }\n      here = lcode[hold & lmask];\n      dolen:\n        for (; ; ) {\n          op = here >>> 24;\n          hold >>>= op;\n          bits -= op;\n          op = here >>> 16 & 255;\n          if (op === 0) {\n            output[_out++] = here & 65535;\n          } else if (op & 16) {\n            len = here & 65535;\n            op &= 15;\n            if (op) {\n              if (bits < op) {\n                hold += input[_in++] << bits;\n                bits += 8;\n              }\n              len += hold & (1 << op) - 1;\n              hold >>>= op;\n              bits -= op;\n            }\n            if (bits < 15) {\n              hold += input[_in++] << bits;\n              bits += 8;\n              hold += input[_in++] << bits;\n              bits += 8;\n            }\n            here = dcode[hold & dmask];\n            dodist:\n              for (; ; ) {\n                op = here >>> 24;\n                hold >>>= op;\n                bits -= op;\n                op = here >>> 16 & 255;\n                if (op & 16) {\n                  dist = here & 65535;\n                  op &= 15;\n                  if (bits < op) {\n                    hold += input[_in++] << bits;\n                    bits += 8;\n                    if (bits < op) {\n                      hold += input[_in++] << bits;\n                      bits += 8;\n                    }\n                  }\n                  dist += hold & (1 << op) - 1;\n                  if (dist > dmax) {\n                    strm.msg = \"invalid distance too far back\";\n                    state.mode = BAD$1;\n                    break top;\n                  }\n                  hold >>>= op;\n                  bits -= op;\n                  op = _out - beg;\n                  if (dist > op) {\n                    op = dist - op;\n                    if (op > whave) {\n                      if (state.sane) {\n                        strm.msg = \"invalid distance too far back\";\n                        state.mode = BAD$1;\n                        break top;\n                      }\n                    }\n                    from = 0;\n                    from_source = s_window;\n                    if (wnext === 0) {\n                      from += wsize - op;\n                      if (op < len) {\n                        len -= op;\n                        do {\n                          output[_out++] = s_window[from++];\n                        } while (--op);\n                        from = _out - dist;\n                        from_source = output;\n                      }\n                    } else if (wnext < op) {\n                      from += wsize + wnext - op;\n                      op -= wnext;\n                      if (op < len) {\n                        len -= op;\n                        do {\n                          output[_out++] = s_window[from++];\n                        } while (--op);\n                        from = 0;\n                        if (wnext < len) {\n                          op = wnext;\n                          len -= op;\n                          do {\n                            output[_out++] = s_window[from++];\n                          } while (--op);\n                          from = _out - dist;\n                          from_source = output;\n                        }\n                      }\n                    } else {\n                      from += wnext - op;\n                      if (op < len) {\n                        len -= op;\n                        do {\n                          output[_out++] = s_window[from++];\n                        } while (--op);\n                        from = _out - dist;\n                        from_source = output;\n                      }\n                    }\n                    while (len > 2) {\n                      output[_out++] = from_source[from++];\n                      output[_out++] = from_source[from++];\n                      output[_out++] = from_source[from++];\n                      len -= 3;\n                    }\n                    if (len) {\n                      output[_out++] = from_source[from++];\n                      if (len > 1) {\n                        output[_out++] = from_source[from++];\n                      }\n                    }\n                  } else {\n                    from = _out - dist;\n                    do {\n                      output[_out++] = output[from++];\n                      output[_out++] = output[from++];\n                      output[_out++] = output[from++];\n                      len -= 3;\n                    } while (len > 2);\n                    if (len) {\n                      output[_out++] = output[from++];\n                      if (len > 1) {\n                        output[_out++] = output[from++];\n                      }\n                    }\n                  }\n                } else if ((op & 64) === 0) {\n                  here = dcode[(here & 65535) + (hold & (1 << op) - 1)];\n                  continue dodist;\n                } else {\n                  strm.msg = \"invalid distance code\";\n                  state.mode = BAD$1;\n                  break top;\n                }\n                break;\n              }\n          } else if ((op & 64) === 0) {\n            here = lcode[(here & 65535) + (hold & (1 << op) - 1)];\n            continue dolen;\n          } else if (op & 32) {\n            state.mode = TYPE$1;\n            break top;\n          } else {\n            strm.msg = \"invalid literal/length code\";\n            state.mode = BAD$1;\n            break top;\n          }\n          break;\n        }\n    } while (_in < last && _out < end);\n  len = bits >> 3;\n  _in -= len;\n  bits -= len << 3;\n  hold &= (1 << bits) - 1;\n  strm.next_in = _in;\n  strm.next_out = _out;\n  strm.avail_in = _in < last ? 5 + (last - _in) : 5 - (_in - last);\n  strm.avail_out = _out < end ? 257 + (end - _out) : 257 - (_out - end);\n  state.hold = hold;\n  state.bits = bits;\n  return;\n};\nvar MAXBITS = 15;\nvar ENOUGH_LENS$1 = 852;\nvar ENOUGH_DISTS$1 = 592;\nvar CODES$1 = 0;\nvar LENS$1 = 1;\nvar DISTS$1 = 2;\nvar lbase = new Uint16Array([\n  3,\n  4,\n  5,\n  6,\n  7,\n  8,\n  9,\n  10,\n  11,\n  13,\n  15,\n  17,\n  19,\n  23,\n  27,\n  31,\n  35,\n  43,\n  51,\n  59,\n  67,\n  83,\n  99,\n  115,\n  131,\n  163,\n  195,\n  227,\n  258,\n  0,\n  0\n]);\nvar lext = new Uint8Array([\n  16,\n  16,\n  16,\n  16,\n  16,\n  16,\n  16,\n  16,\n  17,\n  17,\n  17,\n  17,\n  18,\n  18,\n  18,\n  18,\n  19,\n  19,\n  19,\n  19,\n  20,\n  20,\n  20,\n  20,\n  21,\n  21,\n  21,\n  21,\n  16,\n  72,\n  78\n]);\nvar dbase = new Uint16Array([\n  1,\n  2,\n  3,\n  4,\n  5,\n  7,\n  9,\n  13,\n  17,\n  25,\n  33,\n  49,\n  65,\n  97,\n  129,\n  193,\n  257,\n  385,\n  513,\n  769,\n  1025,\n  1537,\n  2049,\n  3073,\n  4097,\n  6145,\n  8193,\n  12289,\n  16385,\n  24577,\n  0,\n  0\n]);\nvar dext = new Uint8Array([\n  16,\n  16,\n  16,\n  16,\n  17,\n  17,\n  18,\n  18,\n  19,\n  19,\n  20,\n  20,\n  21,\n  21,\n  22,\n  22,\n  23,\n  23,\n  24,\n  24,\n  25,\n  25,\n  26,\n  26,\n  27,\n  27,\n  28,\n  28,\n  29,\n  29,\n  64,\n  64\n]);\nvar inflate_table = (type, lens, lens_index, codes, table, table_index, work, opts) => {\n  const bits = opts.bits;\n  let len = 0;\n  let sym = 0;\n  let min = 0, max = 0;\n  let root = 0;\n  let curr = 0;\n  let drop = 0;\n  let left = 0;\n  let used = 0;\n  let huff = 0;\n  let incr;\n  let fill;\n  let low;\n  let mask;\n  let next;\n  let base = null;\n  let base_index = 0;\n  let end;\n  const count = new Uint16Array(MAXBITS + 1);\n  const offs = new Uint16Array(MAXBITS + 1);\n  let extra = null;\n  let extra_index = 0;\n  let here_bits, here_op, here_val;\n  for (len = 0; len <= MAXBITS; len++) {\n    count[len] = 0;\n  }\n  for (sym = 0; sym < codes; sym++) {\n    count[lens[lens_index + sym]]++;\n  }\n  root = bits;\n  for (max = MAXBITS; max >= 1; max--) {\n    if (count[max] !== 0) {\n      break;\n    }\n  }\n  if (root > max) {\n    root = max;\n  }\n  if (max === 0) {\n    table[table_index++] = 1 << 24 | 64 << 16 | 0;\n    table[table_index++] = 1 << 24 | 64 << 16 | 0;\n    opts.bits = 1;\n    return 0;\n  }\n  for (min = 1; min < max; min++) {\n    if (count[min] !== 0) {\n      break;\n    }\n  }\n  if (root < min) {\n    root = min;\n  }\n  left = 1;\n  for (len = 1; len <= MAXBITS; len++) {\n    left <<= 1;\n    left -= count[len];\n    if (left < 0) {\n      return -1;\n    }\n  }\n  if (left > 0 && (type === CODES$1 || max !== 1)) {\n    return -1;\n  }\n  offs[1] = 0;\n  for (len = 1; len < MAXBITS; len++) {\n    offs[len + 1] = offs[len] + count[len];\n  }\n  for (sym = 0; sym < codes; sym++) {\n    if (lens[lens_index + sym] !== 0) {\n      work[offs[lens[lens_index + sym]]++] = sym;\n    }\n  }\n  if (type === CODES$1) {\n    base = extra = work;\n    end = 19;\n  } else if (type === LENS$1) {\n    base = lbase;\n    base_index -= 257;\n    extra = lext;\n    extra_index -= 257;\n    end = 256;\n  } else {\n    base = dbase;\n    extra = dext;\n    end = -1;\n  }\n  huff = 0;\n  sym = 0;\n  len = min;\n  next = table_index;\n  curr = root;\n  drop = 0;\n  low = -1;\n  used = 1 << root;\n  mask = used - 1;\n  if (type === LENS$1 && used > ENOUGH_LENS$1 || type === DISTS$1 && used > ENOUGH_DISTS$1) {\n    return 1;\n  }\n  for (; ; ) {\n    here_bits = len - drop;\n    if (work[sym] < end) {\n      here_op = 0;\n      here_val = work[sym];\n    } else if (work[sym] > end) {\n      here_op = extra[extra_index + work[sym]];\n      here_val = base[base_index + work[sym]];\n    } else {\n      here_op = 32 + 64;\n      here_val = 0;\n    }\n    incr = 1 << len - drop;\n    fill = 1 << curr;\n    min = fill;\n    do {\n      fill -= incr;\n      table[next + (huff >> drop) + fill] = here_bits << 24 | here_op << 16 | here_val | 0;\n    } while (fill !== 0);\n    incr = 1 << len - 1;\n    while (huff & incr) {\n      incr >>= 1;\n    }\n    if (incr !== 0) {\n      huff &= incr - 1;\n      huff += incr;\n    } else {\n      huff = 0;\n    }\n    sym++;\n    if (--count[len] === 0) {\n      if (len === max) {\n        break;\n      }\n      len = lens[lens_index + work[sym]];\n    }\n    if (len > root && (huff & mask) !== low) {\n      if (drop === 0) {\n        drop = root;\n      }\n      next += min;\n      curr = len - drop;\n      left = 1 << curr;\n      while (curr + drop < max) {\n        left -= count[curr + drop];\n        if (left <= 0) {\n          break;\n        }\n        curr++;\n        left <<= 1;\n      }\n      used += 1 << curr;\n      if (type === LENS$1 && used > ENOUGH_LENS$1 || type === DISTS$1 && used > ENOUGH_DISTS$1) {\n        return 1;\n      }\n      low = huff & mask;\n      table[low] = root << 24 | curr << 16 | next - table_index | 0;\n    }\n  }\n  if (huff !== 0) {\n    table[next + huff] = len - drop << 24 | 64 << 16 | 0;\n  }\n  opts.bits = root;\n  return 0;\n};\nvar inftrees = inflate_table;\nvar CODES = 0;\nvar LENS = 1;\nvar DISTS = 2;\nvar {\n  Z_FINISH: Z_FINISH$1,\n  Z_BLOCK,\n  Z_TREES,\n  Z_OK: Z_OK$1,\n  Z_STREAM_END: Z_STREAM_END$1,\n  Z_NEED_DICT: Z_NEED_DICT$1,\n  Z_STREAM_ERROR: Z_STREAM_ERROR$1,\n  Z_DATA_ERROR: Z_DATA_ERROR$1,\n  Z_MEM_ERROR: Z_MEM_ERROR$1,\n  Z_BUF_ERROR,\n  Z_DEFLATED\n} = constants$2;\nvar HEAD = 1;\nvar FLAGS = 2;\nvar TIME = 3;\nvar OS = 4;\nvar EXLEN = 5;\nvar EXTRA = 6;\nvar NAME = 7;\nvar COMMENT = 8;\nvar HCRC = 9;\nvar DICTID = 10;\nvar DICT = 11;\nvar TYPE = 12;\nvar TYPEDO = 13;\nvar STORED = 14;\nvar COPY_ = 15;\nvar COPY = 16;\nvar TABLE = 17;\nvar LENLENS = 18;\nvar CODELENS = 19;\nvar LEN_ = 20;\nvar LEN = 21;\nvar LENEXT = 22;\nvar DIST = 23;\nvar DISTEXT = 24;\nvar MATCH = 25;\nvar LIT = 26;\nvar CHECK = 27;\nvar LENGTH = 28;\nvar DONE = 29;\nvar BAD = 30;\nvar MEM = 31;\nvar SYNC = 32;\nvar ENOUGH_LENS = 852;\nvar ENOUGH_DISTS = 592;\nvar MAX_WBITS = 15;\nvar DEF_WBITS = MAX_WBITS;\nvar zswap32 = (q) => {\n  return (q >>> 24 & 255) + (q >>> 8 & 65280) + ((q & 65280) << 8) + ((q & 255) << 24);\n};\nfunction InflateState() {\n  this.mode = 0;\n  this.last = false;\n  this.wrap = 0;\n  this.havedict = false;\n  this.flags = 0;\n  this.dmax = 0;\n  this.check = 0;\n  this.total = 0;\n  this.head = null;\n  this.wbits = 0;\n  this.wsize = 0;\n  this.whave = 0;\n  this.wnext = 0;\n  this.window = null;\n  this.hold = 0;\n  this.bits = 0;\n  this.length = 0;\n  this.offset = 0;\n  this.extra = 0;\n  this.lencode = null;\n  this.distcode = null;\n  this.lenbits = 0;\n  this.distbits = 0;\n  this.ncode = 0;\n  this.nlen = 0;\n  this.ndist = 0;\n  this.have = 0;\n  this.next = null;\n  this.lens = new Uint16Array(320);\n  this.work = new Uint16Array(288);\n  this.lendyn = null;\n  this.distdyn = null;\n  this.sane = 0;\n  this.back = 0;\n  this.was = 0;\n}\nvar inflateResetKeep = (strm) => {\n  if (!strm || !strm.state) {\n    return Z_STREAM_ERROR$1;\n  }\n  const state = strm.state;\n  strm.total_in = strm.total_out = state.total = 0;\n  strm.msg = \"\";\n  if (state.wrap) {\n    strm.adler = state.wrap & 1;\n  }\n  state.mode = HEAD;\n  state.last = 0;\n  state.havedict = 0;\n  state.dmax = 32768;\n  state.head = null;\n  state.hold = 0;\n  state.bits = 0;\n  state.lencode = state.lendyn = new Int32Array(ENOUGH_LENS);\n  state.distcode = state.distdyn = new Int32Array(ENOUGH_DISTS);\n  state.sane = 1;\n  state.back = -1;\n  return Z_OK$1;\n};\nvar inflateReset = (strm) => {\n  if (!strm || !strm.state) {\n    return Z_STREAM_ERROR$1;\n  }\n  const state = strm.state;\n  state.wsize = 0;\n  state.whave = 0;\n  state.wnext = 0;\n  return inflateResetKeep(strm);\n};\nvar inflateReset2 = (strm, windowBits) => {\n  let wrap;\n  if (!strm || !strm.state) {\n    return Z_STREAM_ERROR$1;\n  }\n  const state = strm.state;\n  if (windowBits < 0) {\n    wrap = 0;\n    windowBits = -windowBits;\n  } else {\n    wrap = (windowBits >> 4) + 1;\n    if (windowBits < 48) {\n      windowBits &= 15;\n    }\n  }\n  if (windowBits && (windowBits < 8 || windowBits > 15)) {\n    return Z_STREAM_ERROR$1;\n  }\n  if (state.window !== null && state.wbits !== windowBits) {\n    state.window = null;\n  }\n  state.wrap = wrap;\n  state.wbits = windowBits;\n  return inflateReset(strm);\n};\nvar inflateInit2 = (strm, windowBits) => {\n  if (!strm) {\n    return Z_STREAM_ERROR$1;\n  }\n  const state = new InflateState();\n  strm.state = state;\n  state.window = null;\n  const ret = inflateReset2(strm, windowBits);\n  if (ret !== Z_OK$1) {\n    strm.state = null;\n  }\n  return ret;\n};\nvar inflateInit = (strm) => {\n  return inflateInit2(strm, DEF_WBITS);\n};\nvar virgin = true;\nvar lenfix;\nvar distfix;\nvar fixedtables = (state) => {\n  if (virgin) {\n    lenfix = new Int32Array(512);\n    distfix = new Int32Array(32);\n    let sym = 0;\n    while (sym < 144) {\n      state.lens[sym++] = 8;\n    }\n    while (sym < 256) {\n      state.lens[sym++] = 9;\n    }\n    while (sym < 280) {\n      state.lens[sym++] = 7;\n    }\n    while (sym < 288) {\n      state.lens[sym++] = 8;\n    }\n    inftrees(LENS, state.lens, 0, 288, lenfix, 0, state.work, { bits: 9 });\n    sym = 0;\n    while (sym < 32) {\n      state.lens[sym++] = 5;\n    }\n    inftrees(DISTS, state.lens, 0, 32, distfix, 0, state.work, { bits: 5 });\n    virgin = false;\n  }\n  state.lencode = lenfix;\n  state.lenbits = 9;\n  state.distcode = distfix;\n  state.distbits = 5;\n};\nvar updatewindow = (strm, src, end, copy) => {\n  let dist;\n  const state = strm.state;\n  if (state.window === null) {\n    state.wsize = 1 << state.wbits;\n    state.wnext = 0;\n    state.whave = 0;\n    state.window = new Uint8Array(state.wsize);\n  }\n  if (copy >= state.wsize) {\n    state.window.set(src.subarray(end - state.wsize, end), 0);\n    state.wnext = 0;\n    state.whave = state.wsize;\n  } else {\n    dist = state.wsize - state.wnext;\n    if (dist > copy) {\n      dist = copy;\n    }\n    state.window.set(src.subarray(end - copy, end - copy + dist), state.wnext);\n    copy -= dist;\n    if (copy) {\n      state.window.set(src.subarray(end - copy, end), 0);\n      state.wnext = copy;\n      state.whave = state.wsize;\n    } else {\n      state.wnext += dist;\n      if (state.wnext === state.wsize) {\n        state.wnext = 0;\n      }\n      if (state.whave < state.wsize) {\n        state.whave += dist;\n      }\n    }\n  }\n  return 0;\n};\nvar inflate$2 = (strm, flush) => {\n  let state;\n  let input, output;\n  let next;\n  let put;\n  let have, left;\n  let hold;\n  let bits;\n  let _in, _out;\n  let copy;\n  let from;\n  let from_source;\n  let here = 0;\n  let here_bits, here_op, here_val;\n  let last_bits, last_op, last_val;\n  let len;\n  let ret;\n  const hbuf = new Uint8Array(4);\n  let opts;\n  let n;\n  const order = new Uint8Array([16, 17, 18, 0, 8, 7, 9, 6, 10, 5, 11, 4, 12, 3, 13, 2, 14, 1, 15]);\n  if (!strm || !strm.state || !strm.output || !strm.input && strm.avail_in !== 0) {\n    return Z_STREAM_ERROR$1;\n  }\n  state = strm.state;\n  if (state.mode === TYPE) {\n    state.mode = TYPEDO;\n  }\n  put = strm.next_out;\n  output = strm.output;\n  left = strm.avail_out;\n  next = strm.next_in;\n  input = strm.input;\n  have = strm.avail_in;\n  hold = state.hold;\n  bits = state.bits;\n  _in = have;\n  _out = left;\n  ret = Z_OK$1;\n  inf_leave:\n    for (; ; ) {\n      switch (state.mode) {\n        case HEAD:\n          if (state.wrap === 0) {\n            state.mode = TYPEDO;\n            break;\n          }\n          while (bits < 16) {\n            if (have === 0) {\n              break inf_leave;\n            }\n            have--;\n            hold += input[next++] << bits;\n            bits += 8;\n          }\n          if (state.wrap & 2 && hold === 35615) {\n            state.check = 0;\n            hbuf[0] = hold & 255;\n            hbuf[1] = hold >>> 8 & 255;\n            state.check = crc32_1(state.check, hbuf, 2, 0);\n            hold = 0;\n            bits = 0;\n            state.mode = FLAGS;\n            break;\n          }\n          state.flags = 0;\n          if (state.head) {\n            state.head.done = false;\n          }\n          if (!(state.wrap & 1) || (((hold & 255) << 8) + (hold >> 8)) % 31) {\n            strm.msg = \"incorrect header check\";\n            state.mode = BAD;\n            break;\n          }\n          if ((hold & 15) !== Z_DEFLATED) {\n            strm.msg = \"unknown compression method\";\n            state.mode = BAD;\n            break;\n          }\n          hold >>>= 4;\n          bits -= 4;\n          len = (hold & 15) + 8;\n          if (state.wbits === 0) {\n            state.wbits = len;\n          } else if (len > state.wbits) {\n            strm.msg = \"invalid window size\";\n            state.mode = BAD;\n            break;\n          }\n          state.dmax = 1 << state.wbits;\n          strm.adler = state.check = 1;\n          state.mode = hold & 512 ? DICTID : TYPE;\n          hold = 0;\n          bits = 0;\n          break;\n        case FLAGS:\n          while (bits < 16) {\n            if (have === 0) {\n              break inf_leave;\n            }\n            have--;\n            hold += input[next++] << bits;\n            bits += 8;\n          }\n          state.flags = hold;\n          if ((state.flags & 255) !== Z_DEFLATED) {\n            strm.msg = \"unknown compression method\";\n            state.mode = BAD;\n            break;\n          }\n          if (state.flags & 57344) {\n            strm.msg = \"unknown header flags set\";\n            state.mode = BAD;\n            break;\n          }\n          if (state.head) {\n            state.head.text = hold >> 8 & 1;\n          }\n          if (state.flags & 512) {\n            hbuf[0] = hold & 255;\n            hbuf[1] = hold >>> 8 & 255;\n            state.check = crc32_1(state.check, hbuf, 2, 0);\n          }\n          hold = 0;\n          bits = 0;\n          state.mode = TIME;\n        case TIME:\n          while (bits < 32) {\n            if (have === 0) {\n              break inf_leave;\n            }\n            have--;\n            hold += input[next++] << bits;\n            bits += 8;\n          }\n          if (state.head) {\n            state.head.time = hold;\n          }\n          if (state.flags & 512) {\n            hbuf[0] = hold & 255;\n            hbuf[1] = hold >>> 8 & 255;\n            hbuf[2] = hold >>> 16 & 255;\n            hbuf[3] = hold >>> 24 & 255;\n            state.check = crc32_1(state.check, hbuf, 4, 0);\n          }\n          hold = 0;\n          bits = 0;\n          state.mode = OS;\n        case OS:\n          while (bits < 16) {\n            if (have === 0) {\n              break inf_leave;\n            }\n            have--;\n            hold += input[next++] << bits;\n            bits += 8;\n          }\n          if (state.head) {\n            state.head.xflags = hold & 255;\n            state.head.os = hold >> 8;\n          }\n          if (state.flags & 512) {\n            hbuf[0] = hold & 255;\n            hbuf[1] = hold >>> 8 & 255;\n            state.check = crc32_1(state.check, hbuf, 2, 0);\n          }\n          hold = 0;\n          bits = 0;\n          state.mode = EXLEN;\n        case EXLEN:\n          if (state.flags & 1024) {\n            while (bits < 16) {\n              if (have === 0) {\n                break inf_leave;\n              }\n              have--;\n              hold += input[next++] << bits;\n              bits += 8;\n            }\n            state.length = hold;\n            if (state.head) {\n              state.head.extra_len = hold;\n            }\n            if (state.flags & 512) {\n              hbuf[0] = hold & 255;\n              hbuf[1] = hold >>> 8 & 255;\n              state.check = crc32_1(state.check, hbuf, 2, 0);\n            }\n            hold = 0;\n            bits = 0;\n          } else if (state.head) {\n            state.head.extra = null;\n          }\n          state.mode = EXTRA;\n        case EXTRA:\n          if (state.flags & 1024) {\n            copy = state.length;\n            if (copy > have) {\n              copy = have;\n            }\n            if (copy) {\n              if (state.head) {\n                len = state.head.extra_len - state.length;\n                if (!state.head.extra) {\n                  state.head.extra = new Uint8Array(state.head.extra_len);\n                }\n                state.head.extra.set(input.subarray(next, next + copy), len);\n              }\n              if (state.flags & 512) {\n                state.check = crc32_1(state.check, input, copy, next);\n              }\n              have -= copy;\n              next += copy;\n              state.length -= copy;\n            }\n            if (state.length) {\n              break inf_leave;\n            }\n          }\n          state.length = 0;\n          state.mode = NAME;\n        case NAME:\n          if (state.flags & 2048) {\n            if (have === 0) {\n              break inf_leave;\n            }\n            copy = 0;\n            do {\n              len = input[next + copy++];\n              if (state.head && len && state.length < 65536) {\n                state.head.name += String.fromCharCode(len);\n              }\n            } while (len && copy < have);\n            if (state.flags & 512) {\n              state.check = crc32_1(state.check, input, copy, next);\n            }\n            have -= copy;\n            next += copy;\n            if (len) {\n              break inf_leave;\n            }\n          } else if (state.head) {\n            state.head.name = null;\n          }\n          state.length = 0;\n          state.mode = COMMENT;\n        case COMMENT:\n          if (state.flags & 4096) {\n            if (have === 0) {\n              break inf_leave;\n            }\n            copy = 0;\n            do {\n              len = input[next + copy++];\n              if (state.head && len && state.length < 65536) {\n                state.head.comment += String.fromCharCode(len);\n              }\n            } while (len && copy < have);\n            if (state.flags & 512) {\n              state.check = crc32_1(state.check, input, copy, next);\n            }\n            have -= copy;\n            next += copy;\n            if (len) {\n              break inf_leave;\n            }\n          } else if (state.head) {\n            state.head.comment = null;\n          }\n          state.mode = HCRC;\n        case HCRC:\n          if (state.flags & 512) {\n            while (bits < 16) {\n              if (have === 0) {\n                break inf_leave;\n              }\n              have--;\n              hold += input[next++] << bits;\n              bits += 8;\n            }\n            if (hold !== (state.check & 65535)) {\n              strm.msg = \"header crc mismatch\";\n              state.mode = BAD;\n              break;\n            }\n            hold = 0;\n            bits = 0;\n          }\n          if (state.head) {\n            state.head.hcrc = state.flags >> 9 & 1;\n            state.head.done = true;\n          }\n          strm.adler = state.check = 0;\n          state.mode = TYPE;\n          break;\n        case DICTID:\n          while (bits < 32) {\n            if (have === 0) {\n              break inf_leave;\n            }\n            have--;\n            hold += input[next++] << bits;\n            bits += 8;\n          }\n          strm.adler = state.check = zswap32(hold);\n          hold = 0;\n          bits = 0;\n          state.mode = DICT;\n        case DICT:\n          if (state.havedict === 0) {\n            strm.next_out = put;\n            strm.avail_out = left;\n            strm.next_in = next;\n            strm.avail_in = have;\n            state.hold = hold;\n            state.bits = bits;\n            return Z_NEED_DICT$1;\n          }\n          strm.adler = state.check = 1;\n          state.mode = TYPE;\n        case TYPE:\n          if (flush === Z_BLOCK || flush === Z_TREES) {\n            break inf_leave;\n          }\n        case TYPEDO:\n          if (state.last) {\n            hold >>>= bits & 7;\n            bits -= bits & 7;\n            state.mode = CHECK;\n            break;\n          }\n          while (bits < 3) {\n            if (have === 0) {\n              break inf_leave;\n            }\n            have--;\n            hold += input[next++] << bits;\n            bits += 8;\n          }\n          state.last = hold & 1;\n          hold >>>= 1;\n          bits -= 1;\n          switch (hold & 3) {\n            case 0:\n              state.mode = STORED;\n              break;\n            case 1:\n              fixedtables(state);\n              state.mode = LEN_;\n              if (flush === Z_TREES) {\n                hold >>>= 2;\n                bits -= 2;\n                break inf_leave;\n              }\n              break;\n            case 2:\n              state.mode = TABLE;\n              break;\n            case 3:\n              strm.msg = \"invalid block type\";\n              state.mode = BAD;\n          }\n          hold >>>= 2;\n          bits -= 2;\n          break;\n        case STORED:\n          hold >>>= bits & 7;\n          bits -= bits & 7;\n          while (bits < 32) {\n            if (have === 0) {\n              break inf_leave;\n            }\n            have--;\n            hold += input[next++] << bits;\n            bits += 8;\n          }\n          if ((hold & 65535) !== (hold >>> 16 ^ 65535)) {\n            strm.msg = \"invalid stored block lengths\";\n            state.mode = BAD;\n            break;\n          }\n          state.length = hold & 65535;\n          hold = 0;\n          bits = 0;\n          state.mode = COPY_;\n          if (flush === Z_TREES) {\n            break inf_leave;\n          }\n        case COPY_:\n          state.mode = COPY;\n        case COPY:\n          copy = state.length;\n          if (copy) {\n            if (copy > have) {\n              copy = have;\n            }\n            if (copy > left) {\n              copy = left;\n            }\n            if (copy === 0) {\n              break inf_leave;\n            }\n            output.set(input.subarray(next, next + copy), put);\n            have -= copy;\n            next += copy;\n            left -= copy;\n            put += copy;\n            state.length -= copy;\n            break;\n          }\n          state.mode = TYPE;\n          break;\n        case TABLE:\n          while (bits < 14) {\n            if (have === 0) {\n              break inf_leave;\n            }\n            have--;\n            hold += input[next++] << bits;\n            bits += 8;\n          }\n          state.nlen = (hold & 31) + 257;\n          hold >>>= 5;\n          bits -= 5;\n          state.ndist = (hold & 31) + 1;\n          hold >>>= 5;\n          bits -= 5;\n          state.ncode = (hold & 15) + 4;\n          hold >>>= 4;\n          bits -= 4;\n          if (state.nlen > 286 || state.ndist > 30) {\n            strm.msg = \"too many length or distance symbols\";\n            state.mode = BAD;\n            break;\n          }\n          state.have = 0;\n          state.mode = LENLENS;\n        case LENLENS:\n          while (state.have < state.ncode) {\n            while (bits < 3) {\n              if (have === 0) {\n                break inf_leave;\n              }\n              have--;\n              hold += input[next++] << bits;\n              bits += 8;\n            }\n            state.lens[order[state.have++]] = hold & 7;\n            hold >>>= 3;\n            bits -= 3;\n          }\n          while (state.have < 19) {\n            state.lens[order[state.have++]] = 0;\n          }\n          state.lencode = state.lendyn;\n          state.lenbits = 7;\n          opts = { bits: state.lenbits };\n          ret = inftrees(CODES, state.lens, 0, 19, state.lencode, 0, state.work, opts);\n          state.lenbits = opts.bits;\n          if (ret) {\n            strm.msg = \"invalid code lengths set\";\n            state.mode = BAD;\n            break;\n          }\n          state.have = 0;\n          state.mode = CODELENS;\n        case CODELENS:\n          while (state.have < state.nlen + state.ndist) {\n            for (; ; ) {\n              here = state.lencode[hold & (1 << state.lenbits) - 1];\n              here_bits = here >>> 24;\n              here_op = here >>> 16 & 255;\n              here_val = here & 65535;\n              if (here_bits <= bits) {\n                break;\n              }\n              if (have === 0) {\n                break inf_leave;\n              }\n              have--;\n              hold += input[next++] << bits;\n              bits += 8;\n            }\n            if (here_val < 16) {\n              hold >>>= here_bits;\n              bits -= here_bits;\n              state.lens[state.have++] = here_val;\n            } else {\n              if (here_val === 16) {\n                n = here_bits + 2;\n                while (bits < n) {\n                  if (have === 0) {\n                    break inf_leave;\n                  }\n                  have--;\n                  hold += input[next++] << bits;\n                  bits += 8;\n                }\n                hold >>>= here_bits;\n                bits -= here_bits;\n                if (state.have === 0) {\n                  strm.msg = \"invalid bit length repeat\";\n                  state.mode = BAD;\n                  break;\n                }\n                len = state.lens[state.have - 1];\n                copy = 3 + (hold & 3);\n                hold >>>= 2;\n                bits -= 2;\n              } else if (here_val === 17) {\n                n = here_bits + 3;\n                while (bits < n) {\n                  if (have === 0) {\n                    break inf_leave;\n                  }\n                  have--;\n                  hold += input[next++] << bits;\n                  bits += 8;\n                }\n                hold >>>= here_bits;\n                bits -= here_bits;\n                len = 0;\n                copy = 3 + (hold & 7);\n                hold >>>= 3;\n                bits -= 3;\n              } else {\n                n = here_bits + 7;\n                while (bits < n) {\n                  if (have === 0) {\n                    break inf_leave;\n                  }\n                  have--;\n                  hold += input[next++] << bits;\n                  bits += 8;\n                }\n                hold >>>= here_bits;\n                bits -= here_bits;\n                len = 0;\n                copy = 11 + (hold & 127);\n                hold >>>= 7;\n                bits -= 7;\n              }\n              if (state.have + copy > state.nlen + state.ndist) {\n                strm.msg = \"invalid bit length repeat\";\n                state.mode = BAD;\n                break;\n              }\n              while (copy--) {\n                state.lens[state.have++] = len;\n              }\n            }\n          }\n          if (state.mode === BAD) {\n            break;\n          }\n          if (state.lens[256] === 0) {\n            strm.msg = \"invalid code -- missing end-of-block\";\n            state.mode = BAD;\n            break;\n          }\n          state.lenbits = 9;\n          opts = { bits: state.lenbits };\n          ret = inftrees(LENS, state.lens, 0, state.nlen, state.lencode, 0, state.work, opts);\n          state.lenbits = opts.bits;\n          if (ret) {\n            strm.msg = \"invalid literal/lengths set\";\n            state.mode = BAD;\n            break;\n          }\n          state.distbits = 6;\n          state.distcode = state.distdyn;\n          opts = { bits: state.distbits };\n          ret = inftrees(DISTS, state.lens, state.nlen, state.ndist, state.distcode, 0, state.work, opts);\n          state.distbits = opts.bits;\n          if (ret) {\n            strm.msg = \"invalid distances set\";\n            state.mode = BAD;\n            break;\n          }\n          state.mode = LEN_;\n          if (flush === Z_TREES) {\n            break inf_leave;\n          }\n        case LEN_:\n          state.mode = LEN;\n        case LEN:\n          if (have >= 6 && left >= 258) {\n            strm.next_out = put;\n            strm.avail_out = left;\n            strm.next_in = next;\n            strm.avail_in = have;\n            state.hold = hold;\n            state.bits = bits;\n            inffast(strm, _out);\n            put = strm.next_out;\n            output = strm.output;\n            left = strm.avail_out;\n            next = strm.next_in;\n            input = strm.input;\n            have = strm.avail_in;\n            hold = state.hold;\n            bits = state.bits;\n            if (state.mode === TYPE) {\n              state.back = -1;\n            }\n            break;\n          }\n          state.back = 0;\n          for (; ; ) {\n            here = state.lencode[hold & (1 << state.lenbits) - 1];\n            here_bits = here >>> 24;\n            here_op = here >>> 16 & 255;\n            here_val = here & 65535;\n            if (here_bits <= bits) {\n              break;\n            }\n            if (have === 0) {\n              break inf_leave;\n            }\n            have--;\n            hold += input[next++] << bits;\n            bits += 8;\n          }\n          if (here_op && (here_op & 240) === 0) {\n            last_bits = here_bits;\n            last_op = here_op;\n            last_val = here_val;\n            for (; ; ) {\n              here = state.lencode[last_val + ((hold & (1 << last_bits + last_op) - 1) >> last_bits)];\n              here_bits = here >>> 24;\n              here_op = here >>> 16 & 255;\n              here_val = here & 65535;\n              if (last_bits + here_bits <= bits) {\n                break;\n              }\n              if (have === 0) {\n                break inf_leave;\n              }\n              have--;\n              hold += input[next++] << bits;\n              bits += 8;\n            }\n            hold >>>= last_bits;\n            bits -= last_bits;\n            state.back += last_bits;\n          }\n          hold >>>= here_bits;\n          bits -= here_bits;\n          state.back += here_bits;\n          state.length = here_val;\n          if (here_op === 0) {\n            state.mode = LIT;\n            break;\n          }\n          if (here_op & 32) {\n            state.back = -1;\n            state.mode = TYPE;\n            break;\n          }\n          if (here_op & 64) {\n            strm.msg = \"invalid literal/length code\";\n            state.mode = BAD;\n            break;\n          }\n          state.extra = here_op & 15;\n          state.mode = LENEXT;\n        case LENEXT:\n          if (state.extra) {\n            n = state.extra;\n            while (bits < n) {\n              if (have === 0) {\n                break inf_leave;\n              }\n              have--;\n              hold += input[next++] << bits;\n              bits += 8;\n            }\n            state.length += hold & (1 << state.extra) - 1;\n            hold >>>= state.extra;\n            bits -= state.extra;\n            state.back += state.extra;\n          }\n          state.was = state.length;\n          state.mode = DIST;\n        case DIST:\n          for (; ; ) {\n            here = state.distcode[hold & (1 << state.distbits) - 1];\n            here_bits = here >>> 24;\n            here_op = here >>> 16 & 255;\n            here_val = here & 65535;\n            if (here_bits <= bits) {\n              break;\n            }\n            if (have === 0) {\n              break inf_leave;\n            }\n            have--;\n            hold += input[next++] << bits;\n            bits += 8;\n          }\n          if ((here_op & 240) === 0) {\n            last_bits = here_bits;\n            last_op = here_op;\n            last_val = here_val;\n            for (; ; ) {\n              here = state.distcode[last_val + ((hold & (1 << last_bits + last_op) - 1) >> last_bits)];\n              here_bits = here >>> 24;\n              here_op = here >>> 16 & 255;\n              here_val = here & 65535;\n              if (last_bits + here_bits <= bits) {\n                break;\n              }\n              if (have === 0) {\n                break inf_leave;\n              }\n              have--;\n              hold += input[next++] << bits;\n              bits += 8;\n            }\n            hold >>>= last_bits;\n            bits -= last_bits;\n            state.back += last_bits;\n          }\n          hold >>>= here_bits;\n          bits -= here_bits;\n          state.back += here_bits;\n          if (here_op & 64) {\n            strm.msg = \"invalid distance code\";\n            state.mode = BAD;\n            break;\n          }\n          state.offset = here_val;\n          state.extra = here_op & 15;\n          state.mode = DISTEXT;\n        case DISTEXT:\n          if (state.extra) {\n            n = state.extra;\n            while (bits < n) {\n              if (have === 0) {\n                break inf_leave;\n              }\n              have--;\n              hold += input[next++] << bits;\n              bits += 8;\n            }\n            state.offset += hold & (1 << state.extra) - 1;\n            hold >>>= state.extra;\n            bits -= state.extra;\n            state.back += state.extra;\n          }\n          if (state.offset > state.dmax) {\n            strm.msg = \"invalid distance too far back\";\n            state.mode = BAD;\n            break;\n          }\n          state.mode = MATCH;\n        case MATCH:\n          if (left === 0) {\n            break inf_leave;\n          }\n          copy = _out - left;\n          if (state.offset > copy) {\n            copy = state.offset - copy;\n            if (copy > state.whave) {\n              if (state.sane) {\n                strm.msg = \"invalid distance too far back\";\n                state.mode = BAD;\n                break;\n              }\n            }\n            if (copy > state.wnext) {\n              copy -= state.wnext;\n              from = state.wsize - copy;\n            } else {\n              from = state.wnext - copy;\n            }\n            if (copy > state.length) {\n              copy = state.length;\n            }\n            from_source = state.window;\n          } else {\n            from_source = output;\n            from = put - state.offset;\n            copy = state.length;\n          }\n          if (copy > left) {\n            copy = left;\n          }\n          left -= copy;\n          state.length -= copy;\n          do {\n            output[put++] = from_source[from++];\n          } while (--copy);\n          if (state.length === 0) {\n            state.mode = LEN;\n          }\n          break;\n        case LIT:\n          if (left === 0) {\n            break inf_leave;\n          }\n          output[put++] = state.length;\n          left--;\n          state.mode = LEN;\n          break;\n        case CHECK:\n          if (state.wrap) {\n            while (bits < 32) {\n              if (have === 0) {\n                break inf_leave;\n              }\n              have--;\n              hold |= input[next++] << bits;\n              bits += 8;\n            }\n            _out -= left;\n            strm.total_out += _out;\n            state.total += _out;\n            if (_out) {\n              strm.adler = state.check = state.flags ? crc32_1(state.check, output, _out, put - _out) : adler32_1(state.check, output, _out, put - _out);\n            }\n            _out = left;\n            if ((state.flags ? hold : zswap32(hold)) !== state.check) {\n              strm.msg = \"incorrect data check\";\n              state.mode = BAD;\n              break;\n            }\n            hold = 0;\n            bits = 0;\n          }\n          state.mode = LENGTH;\n        case LENGTH:\n          if (state.wrap && state.flags) {\n            while (bits < 32) {\n              if (have === 0) {\n                break inf_leave;\n              }\n              have--;\n              hold += input[next++] << bits;\n              bits += 8;\n            }\n            if (hold !== (state.total & 4294967295)) {\n              strm.msg = \"incorrect length check\";\n              state.mode = BAD;\n              break;\n            }\n            hold = 0;\n            bits = 0;\n          }\n          state.mode = DONE;\n        case DONE:\n          ret = Z_STREAM_END$1;\n          break inf_leave;\n        case BAD:\n          ret = Z_DATA_ERROR$1;\n          break inf_leave;\n        case MEM:\n          return Z_MEM_ERROR$1;\n        case SYNC:\n        default:\n          return Z_STREAM_ERROR$1;\n      }\n    }\n  strm.next_out = put;\n  strm.avail_out = left;\n  strm.next_in = next;\n  strm.avail_in = have;\n  state.hold = hold;\n  state.bits = bits;\n  if (state.wsize || _out !== strm.avail_out && state.mode < BAD && (state.mode < CHECK || flush !== Z_FINISH$1)) {\n    if (updatewindow(strm, strm.output, strm.next_out, _out - strm.avail_out))\n      ;\n  }\n  _in -= strm.avail_in;\n  _out -= strm.avail_out;\n  strm.total_in += _in;\n  strm.total_out += _out;\n  state.total += _out;\n  if (state.wrap && _out) {\n    strm.adler = state.check = state.flags ? crc32_1(state.check, output, _out, strm.next_out - _out) : adler32_1(state.check, output, _out, strm.next_out - _out);\n  }\n  strm.data_type = state.bits + (state.last ? 64 : 0) + (state.mode === TYPE ? 128 : 0) + (state.mode === LEN_ || state.mode === COPY_ ? 256 : 0);\n  if ((_in === 0 && _out === 0 || flush === Z_FINISH$1) && ret === Z_OK$1) {\n    ret = Z_BUF_ERROR;\n  }\n  return ret;\n};\nvar inflateEnd = (strm) => {\n  if (!strm || !strm.state) {\n    return Z_STREAM_ERROR$1;\n  }\n  let state = strm.state;\n  if (state.window) {\n    state.window = null;\n  }\n  strm.state = null;\n  return Z_OK$1;\n};\nvar inflateGetHeader = (strm, head) => {\n  if (!strm || !strm.state) {\n    return Z_STREAM_ERROR$1;\n  }\n  const state = strm.state;\n  if ((state.wrap & 2) === 0) {\n    return Z_STREAM_ERROR$1;\n  }\n  state.head = head;\n  head.done = false;\n  return Z_OK$1;\n};\nvar inflateSetDictionary = (strm, dictionary) => {\n  const dictLength = dictionary.length;\n  let state;\n  let dictid;\n  let ret;\n  if (!strm || !strm.state) {\n    return Z_STREAM_ERROR$1;\n  }\n  state = strm.state;\n  if (state.wrap !== 0 && state.mode !== DICT) {\n    return Z_STREAM_ERROR$1;\n  }\n  if (state.mode === DICT) {\n    dictid = 1;\n    dictid = adler32_1(dictid, dictionary, dictLength, 0);\n    if (dictid !== state.check) {\n      return Z_DATA_ERROR$1;\n    }\n  }\n  ret = updatewindow(strm, dictionary, dictLength, dictLength);\n  if (ret) {\n    state.mode = MEM;\n    return Z_MEM_ERROR$1;\n  }\n  state.havedict = 1;\n  return Z_OK$1;\n};\nvar inflateReset_1 = inflateReset;\nvar inflateReset2_1 = inflateReset2;\nvar inflateResetKeep_1 = inflateResetKeep;\nvar inflateInit_1 = inflateInit;\nvar inflateInit2_1 = inflateInit2;\nvar inflate_2$1 = inflate$2;\nvar inflateEnd_1 = inflateEnd;\nvar inflateGetHeader_1 = inflateGetHeader;\nvar inflateSetDictionary_1 = inflateSetDictionary;\nvar inflateInfo = \"pako inflate (from Nodeca project)\";\nvar inflate_1$2 = {\n  inflateReset: inflateReset_1,\n  inflateReset2: inflateReset2_1,\n  inflateResetKeep: inflateResetKeep_1,\n  inflateInit: inflateInit_1,\n  inflateInit2: inflateInit2_1,\n  inflate: inflate_2$1,\n  inflateEnd: inflateEnd_1,\n  inflateGetHeader: inflateGetHeader_1,\n  inflateSetDictionary: inflateSetDictionary_1,\n  inflateInfo\n};\nfunction GZheader() {\n  this.text = 0;\n  this.time = 0;\n  this.xflags = 0;\n  this.os = 0;\n  this.extra = null;\n  this.extra_len = 0;\n  this.name = \"\";\n  this.comment = \"\";\n  this.hcrc = 0;\n  this.done = false;\n}\nvar gzheader = GZheader;\nvar toString = Object.prototype.toString;\nvar {\n  Z_NO_FLUSH,\n  Z_FINISH,\n  Z_OK,\n  Z_STREAM_END,\n  Z_NEED_DICT,\n  Z_STREAM_ERROR,\n  Z_DATA_ERROR,\n  Z_MEM_ERROR\n} = constants$2;\nfunction Inflate$1(options) {\n  this.options = common.assign({\n    chunkSize: 1024 * 64,\n    windowBits: 15,\n    to: \"\"\n  }, options || {});\n  const opt = this.options;\n  if (opt.raw && opt.windowBits >= 0 && opt.windowBits < 16) {\n    opt.windowBits = -opt.windowBits;\n    if (opt.windowBits === 0) {\n      opt.windowBits = -15;\n    }\n  }\n  if (opt.windowBits >= 0 && opt.windowBits < 16 && !(options && options.windowBits)) {\n    opt.windowBits += 32;\n  }\n  if (opt.windowBits > 15 && opt.windowBits < 48) {\n    if ((opt.windowBits & 15) === 0) {\n      opt.windowBits |= 15;\n    }\n  }\n  this.err = 0;\n  this.msg = \"\";\n  this.ended = false;\n  this.chunks = [];\n  this.strm = new zstream();\n  this.strm.avail_out = 0;\n  let status = inflate_1$2.inflateInit2(this.strm, opt.windowBits);\n  if (status !== Z_OK) {\n    throw new Error(messages[status]);\n  }\n  this.header = new gzheader();\n  inflate_1$2.inflateGetHeader(this.strm, this.header);\n  if (opt.dictionary) {\n    if (typeof opt.dictionary === \"string\") {\n      opt.dictionary = strings.string2buf(opt.dictionary);\n    } else if (toString.call(opt.dictionary) === \"[object ArrayBuffer]\") {\n      opt.dictionary = new Uint8Array(opt.dictionary);\n    }\n    if (opt.raw) {\n      status = inflate_1$2.inflateSetDictionary(this.strm, opt.dictionary);\n      if (status !== Z_OK) {\n        throw new Error(messages[status]);\n      }\n    }\n  }\n}\nInflate$1.prototype.push = function(data, flush_mode) {\n  const strm = this.strm;\n  const chunkSize = this.options.chunkSize;\n  const dictionary = this.options.dictionary;\n  let status, _flush_mode, last_avail_out;\n  if (this.ended)\n    return false;\n  if (flush_mode === ~~flush_mode)\n    _flush_mode = flush_mode;\n  else\n    _flush_mode = flush_mode === true ? Z_FINISH : Z_NO_FLUSH;\n  if (toString.call(data) === \"[object ArrayBuffer]\") {\n    strm.input = new Uint8Array(data);\n  } else {\n    strm.input = data;\n  }\n  strm.next_in = 0;\n  strm.avail_in = strm.input.length;\n  for (; ; ) {\n    if (strm.avail_out === 0) {\n      strm.output = new Uint8Array(chunkSize);\n      strm.next_out = 0;\n      strm.avail_out = chunkSize;\n    }\n    status = inflate_1$2.inflate(strm, _flush_mode);\n    if (status === Z_NEED_DICT && dictionary) {\n      status = inflate_1$2.inflateSetDictionary(strm, dictionary);\n      if (status === Z_OK) {\n        status = inflate_1$2.inflate(strm, _flush_mode);\n      } else if (status === Z_DATA_ERROR) {\n        status = Z_NEED_DICT;\n      }\n    }\n    while (strm.avail_in > 0 && status === Z_STREAM_END && strm.state.wrap > 0 && data[strm.next_in] !== 0) {\n      inflate_1$2.inflateReset(strm);\n      status = inflate_1$2.inflate(strm, _flush_mode);\n    }\n    switch (status) {\n      case Z_STREAM_ERROR:\n      case Z_DATA_ERROR:\n      case Z_NEED_DICT:\n      case Z_MEM_ERROR:\n        this.onEnd(status);\n        this.ended = true;\n        return false;\n    }\n    last_avail_out = strm.avail_out;\n    if (strm.next_out) {\n      if (strm.avail_out === 0 || status === Z_STREAM_END) {\n        if (this.options.to === \"string\") {\n          let next_out_utf8 = strings.utf8border(strm.output, strm.next_out);\n          let tail = strm.next_out - next_out_utf8;\n          let utf8str = strings.buf2string(strm.output, next_out_utf8);\n          strm.next_out = tail;\n          strm.avail_out = chunkSize - tail;\n          if (tail)\n            strm.output.set(strm.output.subarray(next_out_utf8, next_out_utf8 + tail), 0);\n          this.onData(utf8str);\n        } else {\n          this.onData(strm.output.length === strm.next_out ? strm.output : strm.output.subarray(0, strm.next_out));\n        }\n      }\n    }\n    if (status === Z_OK && last_avail_out === 0)\n      continue;\n    if (status === Z_STREAM_END) {\n      status = inflate_1$2.inflateEnd(this.strm);\n      this.onEnd(status);\n      this.ended = true;\n      return true;\n    }\n    if (strm.avail_in === 0)\n      break;\n  }\n  return true;\n};\nInflate$1.prototype.onData = function(chunk) {\n  this.chunks.push(chunk);\n};\nInflate$1.prototype.onEnd = function(status) {\n  if (status === Z_OK) {\n    if (this.options.to === \"string\") {\n      this.result = this.chunks.join(\"\");\n    } else {\n      this.result = common.flattenChunks(this.chunks);\n    }\n  }\n  this.chunks = [];\n  this.err = status;\n  this.msg = this.strm.msg;\n};\nfunction inflate$1(input, options) {\n  const inflator = new Inflate$1(options);\n  inflator.push(input);\n  if (inflator.err)\n    throw inflator.msg || messages[inflator.err];\n  return inflator.result;\n}\nfunction inflateRaw$1(input, options) {\n  options = options || {};\n  options.raw = true;\n  return inflate$1(input, options);\n}\nvar Inflate_1$1 = Inflate$1;\nvar inflate_2 = inflate$1;\nvar inflateRaw_1$1 = inflateRaw$1;\nvar ungzip$1 = inflate$1;\nvar constants = constants$2;\nvar inflate_1$1 = {\n  Inflate: Inflate_1$1,\n  inflate: inflate_2,\n  inflateRaw: inflateRaw_1$1,\n  ungzip: ungzip$1,\n  constants\n};\nvar { Inflate, inflate, inflateRaw, ungzip } = inflate_1$1;\nvar inflate_1 = inflate;\n\n// esm/filters.js\nvar zlib_decompress = function(buf, itemsize) {\n  let input_array = new Uint8Array(buf);\n  return inflate_1(input_array).buffer;\n};\nvar unshuffle = function(buf, itemsize) {\n  let buffer_size = buf.byteLength;\n  let unshuffled_view = new Uint8Array(buffer_size);\n  let step = Math.floor(buffer_size / itemsize);\n  let shuffled_view = new DataView(buf);\n  for (var j = 0; j < itemsize; j++) {\n    for (var i = 0; i < step; i++) {\n      unshuffled_view[j + i * itemsize] = shuffled_view.getUint8(j * step + i);\n    }\n  }\n  return unshuffled_view.buffer;\n};\nvar fletch32 = function(buf, itemsize) {\n  _verify_fletcher32(buf);\n  return buf.slice(0, -4);\n};\nfunction _verify_fletcher32(chunk_buffer) {\n  var odd_chunk_buffer = chunk_buffer.byteLength % 2 != 0;\n  var data_length = chunk_buffer.byteLength - 4;\n  var view = new DataView(chunk_buffer);\n  var sum1 = 0;\n  var sum2 = 0;\n  for (var offset = 0; offset < data_length - 1; offset += 2) {\n    let datum = view.getUint16(offset, true);\n    sum1 = (sum1 + datum) % 65535;\n    sum2 = (sum2 + sum1) % 65535;\n  }\n  if (odd_chunk_buffer) {\n    let datum = view.getUint8(data_length - 1);\n    sum1 = (sum1 + datum) % 65535;\n    sum2 = (sum2 + sum1) % 65535;\n  }\n  var [ref_sum1, ref_sum2] = struct.unpack_from(\">HH\", chunk_buffer, data_length);\n  ref_sum1 = ref_sum1 % 65535;\n  ref_sum2 = ref_sum2 % 65535;\n  if (sum1 != ref_sum1 || sum2 != ref_sum2) {\n    throw 'ValueError(\"fletcher32 checksum invalid\")';\n  }\n  return true;\n}\nvar GZIP_DEFLATE_FILTER = 1;\nvar SHUFFLE_FILTER = 2;\nvar FLETCH32_FILTER = 3;\nvar Filters = /* @__PURE__ */ new Map([\n  [GZIP_DEFLATE_FILTER, zlib_decompress],\n  [SHUFFLE_FILTER, unshuffle],\n  [FLETCH32_FILTER, fletch32]\n]);\n\n// esm/btree.js\nvar AbstractBTree = class {\n  constructor(fh, offset) {\n    this.fh = fh;\n    this.offset = offset;\n    this.depth = null;\n  }\n  init() {\n    this.all_nodes = /* @__PURE__ */ new Map();\n    this._read_root_node();\n    this._read_children();\n  }\n  _read_children() {\n    let node_level = this.depth;\n    while (node_level > 0) {\n      for (var parent_node of this.all_nodes.get(node_level)) {\n        for (var child_addr of parent_node.get(\"addresses\")) {\n          this._add_node(this._read_node(child_addr, node_level - 1));\n        }\n      }\n      node_level--;\n    }\n  }\n  _read_root_node() {\n    let root_node = this._read_node(this.offset, null);\n    this._add_node(root_node);\n    this.depth = root_node.get(\"node_level\");\n  }\n  _add_node(node2) {\n    let node_level = node2.get(\"node_level\");\n    if (this.all_nodes.has(node_level)) {\n      this.all_nodes.get(node_level).push(node2);\n    } else {\n      this.all_nodes.set(node_level, [node2]);\n    }\n  }\n  _read_node(offset, node_level) {\n    node = this._read_node_header(offset, node_level);\n    node.set(\"keys\", []);\n    node.set(\"addresses\", []);\n    return node;\n  }\n  _read_node_header(offset) {\n    throw \"NotImplementedError: must define _read_node_header in implementation class\";\n  }\n};\nvar BTreeV1 = class extends AbstractBTree {\n  B_LINK_NODE = /* @__PURE__ */ new Map([\n    [\"signature\", \"4s\"],\n    [\"node_type\", \"B\"],\n    [\"node_level\", \"B\"],\n    [\"entries_used\", \"H\"],\n    [\"left_sibling\", \"Q\"],\n    [\"right_sibling\", \"Q\"]\n  ]);\n  _read_node_header(offset, node_level) {\n    let node2 = _unpack_struct_from(this.B_LINK_NODE, this.fh, offset);\n    if (node_level != null) {\n      if (node2.get(\"node_level\") != node_level) {\n        throw \"node level does not match\";\n      }\n    }\n    return node2;\n  }\n};\nvar BTreeV1Groups = class extends BTreeV1 {\n  NODE_TYPE = 0;\n  constructor(fh, offset) {\n    super(fh, offset);\n    this.init();\n  }\n  _read_node(offset, node_level) {\n    let node2 = this._read_node_header(offset, node_level);\n    offset += _structure_size(this.B_LINK_NODE);\n    let keys = [];\n    let addresses = [];\n    let entries_used = node2.get(\"entries_used\");\n    for (var i = 0; i < entries_used; i++) {\n      let key = struct.unpack_from(\"<Q\", this.fh, offset)[0];\n      offset += 8;\n      let address = struct.unpack_from(\"<Q\", this.fh, offset)[0];\n      offset += 8;\n      keys.push(key);\n      addresses.push(address);\n    }\n    keys.push(struct.unpack_from(\"<Q\", this.fh, offset)[0]);\n    node2.set(\"keys\", keys);\n    node2.set(\"addresses\", addresses);\n    return node2;\n  }\n  symbol_table_addresses() {\n    var all_address = [];\n    var root_nodes = this.all_nodes.get(0);\n    for (var node2 of root_nodes) {\n      all_address = all_address.concat(node2.get(\"addresses\"));\n    }\n    return all_address;\n  }\n};\nvar BTreeV1RawDataChunks = class extends BTreeV1 {\n  NODE_TYPE = 1;\n  constructor(fh, offset, dims) {\n    super(fh, offset);\n    this.dims = dims;\n    this.init();\n  }\n  _read_node(offset, node_level) {\n    let node2 = this._read_node_header(offset, node_level);\n    offset += _structure_size(this.B_LINK_NODE);\n    var keys = [];\n    var addresses = [];\n    let entries_used = node2.get(\"entries_used\");\n    for (var i = 0; i < entries_used; i++) {\n      let [chunk_size, filter_mask] = struct.unpack_from(\"<II\", this.fh, offset);\n      offset += 8;\n      let fmt = \"<\" + this.dims.toFixed() + \"Q\";\n      let fmt_size = struct.calcsize(fmt);\n      let chunk_offset = struct.unpack_from(fmt, this.fh, offset);\n      offset += fmt_size;\n      let chunk_address = struct.unpack_from(\"<Q\", this.fh, offset)[0];\n      offset += 8;\n      keys.push(/* @__PURE__ */ new Map([\n        [\"chunk_size\", chunk_size],\n        [\"filter_mask\", filter_mask],\n        [\"chunk_offset\", chunk_offset]\n      ]));\n      addresses.push(chunk_address);\n    }\n    node2.set(\"keys\", keys);\n    node2.set(\"addresses\", addresses);\n    return node2;\n  }\n  construct_data_from_chunks(chunk_shape, data_shape, dtype, filter_pipeline) {\n    var true_dtype;\n    var item_getter, item_big_endian, item_size;\n    if (dtype instanceof Array) {\n      true_dtype = dtype;\n      let dtype_class = dtype[0];\n      if (dtype_class == \"REFERENCE\") {\n        let size = dtype[1];\n        if (size != 8) {\n          throw \"NotImplementedError('Unsupported Reference type')\";\n        }\n        var dtype = \"<u8\";\n        item_getter = \"getUint64\";\n        item_big_endian = false;\n        item_size = 8;\n      } else if (dtype_class == \"VLEN_STRING\" || dtype_class == \"VLEN_SEQUENCE\") {\n        item_getter = \"getVLENStruct\";\n        item_big_endian = false;\n        item_size = 16;\n      } else {\n        throw \"NotImplementedError('datatype not implemented')\";\n      }\n    } else {\n      true_dtype = null;\n      [item_getter, item_big_endian, item_size] = dtype_getter(dtype);\n    }\n    var data_size = data_shape.reduce(function(a, b) {\n      return a * b;\n    }, 1);\n    var chunk_size = chunk_shape.reduce(function(a, b) {\n      return a * b;\n    }, 1);\n    let dims = data_shape.length;\n    var current_stride = 1;\n    var chunk_strides = chunk_shape.slice().map(function(d2) {\n      let s = current_stride;\n      current_stride *= d2;\n      return s;\n    });\n    var current_stride = 1;\n    var data_strides = data_shape.slice().reverse().map(function(d2) {\n      let s = current_stride;\n      current_stride *= d2;\n      return s;\n    }).reverse();\n    var data = new Array(data_size);\n    let chunk_buffer_size = chunk_size * item_size;\n    for (var node2 of this.all_nodes.get(0)) {\n      let node_keys = node2.get(\"keys\");\n      let node_addresses = node2.get(\"addresses\");\n      let nkeys = node_keys.length;\n      for (var ik = 0; ik < nkeys; ik++) {\n        let node_key = node_keys[ik];\n        let addr = node_addresses[ik];\n        var chunk_buffer;\n        if (filter_pipeline == null) {\n          chunk_buffer = this.fh.slice(addr, addr + chunk_buffer_size);\n        } else {\n          chunk_buffer = this.fh.slice(addr, addr + node_key.get(\"chunk_size\"));\n          let filter_mask = node_key.get(\"filter_mask\");\n          chunk_buffer = this._filter_chunk(chunk_buffer, filter_mask, filter_pipeline, item_size);\n        }\n        var chunk_offset = node_key.get(\"chunk_offset\").slice();\n        var apos = chunk_offset.slice();\n        var cpos = apos.map(function() {\n          return 0;\n        });\n        var cview = new DataView64(chunk_buffer);\n        for (var ci = 0; ci < chunk_size; ci++) {\n          for (var d = dims - 1; d >= 0; d--) {\n            if (cpos[d] >= chunk_shape[d]) {\n              cpos[d] = 0;\n              apos[d] = chunk_offset[d];\n              if (d > 0) {\n                cpos[d - 1] += 1;\n                apos[d - 1] += 1;\n              }\n            } else {\n              break;\n            }\n          }\n          let inbounds = apos.slice(0, -1).every(function(p, d2) {\n            return p < data_shape[d2];\n          });\n          if (inbounds) {\n            let cb_offset = ci * item_size;\n            let datum = cview[item_getter](cb_offset, !item_big_endian, item_size);\n            let ai = apos.slice(0, -1).reduce(function(prev, curr, index) {\n              return curr * data_strides[index] + prev;\n            }, 0);\n            data[ai] = datum;\n          }\n          cpos[dims - 1] += 1;\n          apos[dims - 1] += 1;\n        }\n      }\n    }\n    return data;\n  }\n  _filter_chunk(chunk_buffer, filter_mask, filter_pipeline, itemsize) {\n    let num_filters = filter_pipeline.length;\n    let buf = chunk_buffer.slice();\n    for (var filter_index = num_filters - 1; filter_index >= 0; filter_index--) {\n      if (filter_mask & 1 << filter_index) {\n        continue;\n      }\n      let pipeline_entry = filter_pipeline[filter_index];\n      let filter_id = pipeline_entry.get(\"filter_id\");\n      let client_data = pipeline_entry.get(\"client_data\");\n      if (Filters.has(filter_id)) {\n        buf = Filters.get(filter_id)(buf, itemsize, client_data);\n      } else {\n        throw 'NotImplementedError(\"Filter with id:' + filter_id.toFixed() + ' not supported\")';\n      }\n    }\n    return buf;\n  }\n};\nvar BTreeV2 = class extends AbstractBTree {\n  B_TREE_HEADER = /* @__PURE__ */ new Map([\n    [\"signature\", \"4s\"],\n    [\"version\", \"B\"],\n    [\"node_type\", \"B\"],\n    [\"node_size\", \"I\"],\n    [\"record_size\", \"H\"],\n    [\"depth\", \"H\"],\n    [\"split_percent\", \"B\"],\n    [\"merge_percent\", \"B\"],\n    [\"root_address\", \"Q\"],\n    [\"root_nrecords\", \"H\"],\n    [\"total_nrecords\", \"Q\"]\n  ]);\n  B_LINK_NODE = /* @__PURE__ */ new Map([\n    [\"signature\", \"4s\"],\n    [\"version\", \"B\"],\n    [\"node_type\", \"B\"]\n  ]);\n  constructor(fh, offset) {\n    super(fh, offset);\n    this.init();\n  }\n  _read_root_node() {\n    let h = this._read_tree_header(this.offset);\n    this.address_formats = this._calculate_address_formats(h);\n    this.header = h;\n    this.depth = h.get(\"depth\");\n    let address = [h.get(\"root_address\"), h.get(\"root_nrecords\"), h.get(\"total_nrecords\")];\n    let root_node = this._read_node(address, this.depth);\n    this._add_node(root_node);\n  }\n  _read_tree_header(offset) {\n    let header = _unpack_struct_from(this.B_TREE_HEADER, this.fh, this.offset);\n    return header;\n  }\n  _calculate_address_formats(header) {\n    let node_size = header.get(\"node_size\");\n    let record_size = header.get(\"record_size\");\n    let nrecords_max = 0;\n    let ntotalrecords_max = 0;\n    let address_formats = /* @__PURE__ */ new Map();\n    let max_depth = header.get(\"depth\");\n    for (var node_level = 0; node_level <= max_depth; node_level++) {\n      let offset_fmt = \"\";\n      let num1_fmt = \"\";\n      let num2_fmt = \"\";\n      let offset_size, num1_size, num2_size;\n      if (node_level == 0) {\n        offset_size = 0;\n        num1_size = 0;\n        num2_size = 0;\n      } else if (node_level == 1) {\n        offset_size = 8;\n        offset_fmt = \"<Q\";\n        num1_size = this._required_bytes(nrecords_max);\n        num1_fmt = this._int_format(num1_size);\n        num2_size = 0;\n      } else {\n        offset_size = 8;\n        offset_fmt = \"<Q\";\n        num1_size = this._required_bytes(nrecords_max);\n        num1_fmt = this._int_format(num1_size);\n        num2_size = this._required_bytes(ntotalrecords_max);\n        num2_fmt = this._int_format(num2_size);\n      }\n      address_formats.set(node_level, [\n        offset_size,\n        num1_size,\n        num2_size,\n        offset_fmt,\n        num1_fmt,\n        num2_fmt\n      ]);\n      if (node_level < max_depth) {\n        let addr_size = offset_size + num1_size + num2_size;\n        nrecords_max = this._nrecords_max(node_size, record_size, addr_size);\n        if (ntotalrecords_max > 0) {\n          ntotalrecords_max *= nrecords_max;\n        } else {\n          ntotalrecords_max = nrecords_max;\n        }\n      }\n    }\n    return address_formats;\n  }\n  _nrecords_max(node_size, record_size, addr_size) {\n    return Math.floor((node_size - 10 - addr_size) / (record_size + addr_size));\n  }\n  _required_bytes(integer) {\n    return Math.ceil(bitSize(integer) / 8);\n  }\n  _int_format(bytelength) {\n    return [\"<B\", \"<H\", \"<I\", \"<Q\"][bytelength - 1];\n  }\n  _read_node(address, node_level) {\n    let [offset, nrecords, ntotalrecords] = address;\n    let node2 = this._read_node_header(offset, node_level);\n    offset += _structure_size(this.B_LINK_NODE);\n    let record_size = this.header.get(\"record_size\");\n    let keys = [];\n    for (let i = 0; i < nrecords; i++) {\n      let record = this._parse_record(this.fh, offset, record_size);\n      offset += record_size;\n      keys.push(record);\n    }\n    let addresses = [];\n    let fmts = this.address_formats.get(node_level);\n    if (node_level != 0) {\n      let [offset_size, num1_size, num2_size, offset_fmt, num1_fmt, num2_fmt] = fmts;\n      for (let j = 0; j <= nrecords; j++) {\n        let address_offset = struct.unpack_from(offset_fmt, this.fh, offset)[0];\n        offset += offset_size;\n        let num1 = struct.unpack_from(num1_fmt, this.fh, offset)[0];\n        offset += num1_size;\n        let num2 = num1;\n        if (num2_size > 0) {\n          num2 = struct.unpack_from(num2_fmt, this.fh, offset)[0];\n        }\n        addresses.push([address_offset, num1, num2]);\n      }\n    }\n    node2.set(\"keys\", keys);\n    node2.set(\"addresses\", addresses);\n    return node2;\n  }\n  _read_node_header(offset, node_level) {\n    let node2 = _unpack_struct_from(this.B_LINK_NODE, this.fh, offset);\n    if (node_level > 0) {\n    } else {\n    }\n    node2.set(\"node_level\", node_level);\n    return node2;\n  }\n  *iter_records() {\n    for (let nodelist of this.all_nodes.values()) {\n      for (let node2 of nodelist) {\n        for (let key of node2.get(\"keys\")) {\n          yield key;\n        }\n      }\n    }\n  }\n  _parse_record(record) {\n    throw \"NotImplementedError\";\n  }\n};\nvar BTreeV2GroupNames = class extends BTreeV2 {\n  NODE_TYPE = 5;\n  _parse_record(buf, offset, size) {\n    let namehash = struct.unpack_from(\"<I\", buf, offset)[0];\n    offset += 4;\n    return /* @__PURE__ */ new Map([[\"namehash\", namehash], [\"heapid\", buf.slice(offset, offset + 7)]]);\n  }\n};\nvar BTreeV2GroupOrders = class extends BTreeV2 {\n  NODE_TYPE = 6;\n  _parse_record(buf, offset, size) {\n    let creationorder = struct.unpack_from(\"<Q\", buf, offset)[0];\n    offset += 8;\n    return /* @__PURE__ */ new Map([[\"creationorder\", creationorder], [\"heapid\", buf.slice(offset, offset + 7)]]);\n  }\n};\n\n// esm/misc-low-level.js\nvar SuperBlock = class {\n  constructor(fh, offset) {\n    let version_hint = struct.unpack_from(\"<B\", fh, offset + 8);\n    var contents;\n    if (version_hint == 0) {\n      contents = _unpack_struct_from(SUPERBLOCK_V0, fh, offset);\n      this._end_of_sblock = offset + SUPERBLOCK_V0_SIZE;\n    } else if (version_hint == 2 || version_hint == 3) {\n      contents = _unpack_struct_from(SUPERBLOCK_V2_V3, fh, offset);\n      this._end_of_sblock = offset + SUPERBLOCK_V2_V3_SIZE;\n    } else {\n      throw \"unsupported superblock version: \" + version_hint.toFixed();\n    }\n    if (contents.get(\"format_signature\") != FORMAT_SIGNATURE) {\n      throw \"Incorrect file signature: \" + contents.get(\"format_signature\");\n    }\n    if (contents.get(\"offset_size\") != 8 || contents.get(\"length_size\") != 8) {\n      throw \"File uses non-64-bit addressing\";\n    }\n    this.version = contents.get(\"superblock_version\");\n    this._contents = contents;\n    this._root_symbol_table = null;\n    this._fh = fh;\n  }\n  get offset_to_dataobjects() {\n    if (this.version == 0) {\n      var sym_table = new SymbolTable(this._fh, this._end_of_sblock, true);\n      this._root_symbol_table = sym_table;\n      return sym_table.group_offset;\n    } else if (this.version == 2 || this.version == 3) {\n      return this._contents.get(\"root_group_address\");\n    } else {\n      throw \"Not implemented version = \" + this.version.toFixed();\n    }\n  }\n};\nvar Heap = class {\n  constructor(fh, offset) {\n    let local_heap = _unpack_struct_from(LOCAL_HEAP, fh, offset);\n    assert(local_heap.get(\"signature\") == \"HEAP\");\n    assert(local_heap.get(\"version\") == 0);\n    let data_offset = local_heap.get(\"address_of_data_segment\");\n    let heap_data = fh.slice(data_offset, data_offset + local_heap.get(\"data_segment_size\"));\n    local_heap.set(\"heap_data\", heap_data);\n    this._contents = local_heap;\n    this.data = heap_data;\n  }\n  get_object_name(offset) {\n    let end = new Uint8Array(this.data).indexOf(0, offset);\n    let name_size = end - offset;\n    let name = struct.unpack_from(\"<\" + name_size.toFixed() + \"s\", this.data, offset)[0];\n    return name;\n  }\n};\nvar SymbolTable = class {\n  constructor(fh, offset, root = false) {\n    var node2;\n    if (root) {\n      node2 = /* @__PURE__ */ new Map([[\"symbols\", 1]]);\n    } else {\n      node2 = _unpack_struct_from(SYMBOL_TABLE_NODE, fh, offset);\n      if (node2.get(\"signature\") != \"SNOD\") {\n        throw \"incorrect node type\";\n      }\n      offset += SYMBOL_TABLE_NODE_SIZE;\n    }\n    var entries = [];\n    var n_symbols = node2.get(\"symbols\");\n    for (var i = 0; i < n_symbols; i++) {\n      entries.push(_unpack_struct_from(SYMBOL_TABLE_ENTRY, fh, offset));\n      offset += SYMBOL_TABLE_ENTRY_SIZE;\n    }\n    if (root) {\n      this.group_offset = entries[0].get(\"object_header_address\");\n    }\n    this.entries = entries;\n    this._contents = node2;\n  }\n  assign_name(heap) {\n    this.entries.forEach(function(entry) {\n      let offset = entry.get(\"link_name_offset\");\n      let link_name = heap.get_object_name(offset);\n      entry.set(\"link_name\", link_name);\n    });\n  }\n  get_links(heap) {\n    var links = {};\n    this.entries.forEach(function(e) {\n      let cache_type = e.get(\"cache_type\");\n      let link_name = e.get(\"link_name\");\n      if (cache_type == 0 || cache_type == 1) {\n        links[link_name] = e.get(\"object_header_address\");\n      } else if (cache_type == 2) {\n        let scratch = e.get(\"scratch\");\n        let buf = new ArrayBuffer(4);\n        let bufView = new Uint8Array(buf);\n        for (var i = 0; i < 4; i++) {\n          bufView[i] = scratch.charCodeAt(i);\n        }\n        let offset = struct.unpack_from(\"<I\", buf, 0)[0];\n        links[link_name] = heap.get_object_name(offset);\n      }\n    });\n    return links;\n  }\n};\nvar GlobalHeap = class {\n  constructor(fh, offset) {\n    let header = _unpack_struct_from(GLOBAL_HEAP_HEADER, fh, offset);\n    offset += GLOBAL_HEAP_HEADER_SIZE;\n    let heap_data_size = header.get(\"collection_size\") - GLOBAL_HEAP_HEADER_SIZE;\n    let heap_data = fh.slice(offset, offset + heap_data_size);\n    this.heap_data = heap_data;\n    this._header = header;\n    this._objects = null;\n  }\n  get objects() {\n    if (this._objects == null) {\n      this._objects = /* @__PURE__ */ new Map();\n      var offset = 0;\n      while (offset <= this.heap_data.byteLength - GLOBAL_HEAP_OBJECT_SIZE) {\n        let info = _unpack_struct_from(GLOBAL_HEAP_OBJECT, this.heap_data, offset);\n        if (info.get(\"object_index\") == 0) {\n          break;\n        }\n        offset += GLOBAL_HEAP_OBJECT_SIZE;\n        let obj_data = this.heap_data.slice(offset, offset + info.get(\"object_size\"));\n        this._objects.set(info.get(\"object_index\"), obj_data);\n        offset += _padded_size(info.get(\"object_size\"));\n      }\n    }\n    return this._objects;\n  }\n};\nvar FractalHeap = class {\n  constructor(fh, offset) {\n    this.fh = fh;\n    let header = _unpack_struct_from(FRACTAL_HEAP_HEADER, fh, offset);\n    offset += _structure_size(FRACTAL_HEAP_HEADER);\n    assert(header.get(\"signature\") == \"FRHP\");\n    assert(header.get(\"version\") == 0);\n    if (header.get(\"filter_info_size\") > 0) {\n      throw \"Filter info size not supported on FractalHeap\";\n    }\n    if (header.get(\"btree_address_huge_objects\") == UNDEFINED_ADDRESS) {\n      header.set(\"btree_address_huge_objects\", null);\n    } else {\n      throw \"Huge objects not implemented in FractalHeap\";\n    }\n    if (header.get(\"root_block_address\") == UNDEFINED_ADDRESS) {\n      header.set(\"root_block_address\", null);\n    }\n    let nbits = header.get(\"log2_maximum_heap_size\");\n    let block_offset_size = this._min_size_nbits(nbits);\n    let h = /* @__PURE__ */ new Map([\n      [\"signature\", \"4s\"],\n      [\"version\", \"B\"],\n      [\"heap_header_adddress\", \"Q\"],\n      [\"block_offset\", `${block_offset_size}B`]\n    ]);\n    this.indirect_block_header = new Map(h);\n    this.indirect_block_header_size = _structure_size(h);\n    if ((header.get(\"flags\") & 2) == 2) {\n      h.set(\"checksum\", \"I\");\n    }\n    this.direct_block_header = h;\n    this.direct_block_header_size = _structure_size(h);\n    let maximum_dblock_size = header.get(\"maximum_direct_block_size\");\n    this._managed_object_offset_size = this._min_size_nbits(nbits);\n    let value = Math.min(maximum_dblock_size, header.get(\"max_managed_object_size\"));\n    this._managed_object_length_size = this._min_size_integer(value);\n    let start_block_size = header.get(\"starting_block_size\");\n    let table_width = header.get(\"table_width\");\n    if (!(start_block_size > 0)) {\n      throw \"Starting block size == 0 not implemented\";\n    }\n    let log2_maximum_dblock_size = Number(Math.floor(Math.log2(maximum_dblock_size)));\n    assert(1n << BigInt(log2_maximum_dblock_size) == maximum_dblock_size);\n    let log2_start_block_size = Number(Math.floor(Math.log2(start_block_size)));\n    assert(1n << BigInt(log2_start_block_size) == start_block_size);\n    this._max_direct_nrows = log2_maximum_dblock_size - log2_start_block_size + 2;\n    let log2_table_width = Math.floor(Math.log2(table_width));\n    assert(1 << log2_table_width == table_width);\n    this._indirect_nrows_sub = log2_table_width + log2_start_block_size - 1;\n    this.header = header;\n    this.nobjects = header.get(\"managed_object_count\") + header.get(\"huge_object_count\") + header.get(\"tiny_object_count\");\n    let managed = [];\n    let root_address = header.get(\"root_block_address\");\n    let nrows = 0;\n    if (root_address != null) {\n      nrows = header.get(\"indirect_current_rows_count\");\n    }\n    if (nrows > 0) {\n      for (let data of this._iter_indirect_block(fh, root_address, nrows)) {\n        managed.push(data);\n      }\n    } else {\n      let data = this._read_direct_block(fh, root_address, start_block_size);\n      managed.push(data);\n    }\n    let data_size = managed.reduce((p, c) => p + c.byteLength, 0);\n    let combined = new Uint8Array(data_size);\n    let moffset = 0;\n    managed.forEach((m) => {\n      combined.set(new Uint8Array(m), moffset);\n      moffset += m.byteLength;\n    });\n    this.managed = combined.buffer;\n  }\n  _read_direct_block(fh, offset, block_size) {\n    let data = fh.slice(offset, offset + block_size);\n    let header = _unpack_struct_from(this.direct_block_header, data);\n    assert(header.get(\"signature\") == \"FHDB\");\n    return data;\n  }\n  get_data(heapid) {\n    let firstbyte = struct.unpack_from(\"<B\", heapid, 0)[0];\n    let reserved = firstbyte & 15;\n    let idtype = firstbyte >> 4 & 3;\n    let version = firstbyte >> 6;\n    let data_offset = 1;\n    if (idtype == 0) {\n      assert(version == 0);\n      let nbytes = this._managed_object_offset_size;\n      let offset = _unpack_integer(nbytes, heapid, data_offset);\n      data_offset += nbytes;\n      nbytes = this._managed_object_length_size;\n      let size = _unpack_integer(nbytes, heapid, data_offset);\n      return this.managed.slice(offset, offset + size);\n    } else if (idtype == 1) {\n      throw \"tiny objectID not supported in FractalHeap\";\n    } else if (idtype == 2) {\n      throw \"huge objectID not supported in FractalHeap\";\n    } else {\n      throw \"unknown objectID type in FractalHeap\";\n    }\n  }\n  _min_size_integer(integer) {\n    return this._min_size_nbits(bitSize(integer));\n  }\n  _min_size_nbits(nbits) {\n    return Math.ceil(nbits / 8);\n  }\n  *_iter_indirect_block(fh, offset, nrows) {\n    let header = _unpack_struct_from(this.indirect_block_header, fh, offset);\n    offset += this.indirect_block_header_size;\n    assert(header.get(\"signature\") == \"FHIB\");\n    let block_offset_bytes = header.get(\"block_offset\");\n    let block_offset = block_offset_bytes.reduce((p, c, i) => p + (c << i * 8), 0);\n    header.set(\"block_offset\", block_offset);\n    let [ndirect, nindirect] = this._indirect_info(nrows);\n    let direct_blocks = [];\n    for (let i = 0; i < ndirect; i++) {\n      let address = struct.unpack_from(\"<Q\", fh, offset)[0];\n      offset += 8;\n      if (address == UNDEFINED_ADDRESS) {\n        break;\n      }\n      let block_size = this._calc_block_size(i);\n      direct_blocks.push([address, block_size]);\n    }\n    let indirect_blocks = [];\n    for (let i = ndirect; i < ndirect + nindirect; i++) {\n      let address = struct.unpack_from(\"<Q\", fh, offset)[0];\n      offset += 8;\n      if (address == UNDEFINED_ADDRESS) {\n        break;\n      }\n      let block_size = this._calc_block_size(i);\n      let nrows2 = this._iblock_nrows_from_block_size(block_size);\n      indirect_blocks.push([address, nrows2]);\n    }\n    for (let [address, block_size] of direct_blocks) {\n      let obj = this._read_direct_block(fh, address, block_size);\n      yield obj;\n    }\n    for (let [address, nrows2] of indirect_blocks) {\n      for (let obj of this._iter_indirect_block(fh, address, nrows2)) {\n        yield obj;\n      }\n    }\n  }\n  _calc_block_size(iblock) {\n    let row = Math.floor(iblock / this.header.get(\"table_width\"));\n    return 2 ** Math.max(row - 1, 0) * this.header.get(\"starting_block_size\");\n  }\n  _iblock_nrows_from_block_size(block_size) {\n    let log2_block_size = Math.floor(Math.log2(block_size));\n    assert(2 ** log2_block_size == block_size);\n    return log2_block_size - this._indirect_nrows_sub;\n  }\n  _indirect_info(nrows) {\n    let table_width = this.header.get(\"table_width\");\n    let nobjects = nrows * table_width;\n    let ndirect_max = this._max_direct_nrows * table_width;\n    let ndirect, nindirect;\n    if (nrows <= ndirect_max) {\n      ndirect = nobjects;\n      nindirect = 0;\n    } else {\n      ndirect = ndirect_max;\n      nindirect = nobjects - ndirect_max;\n    }\n    return [ndirect, nindirect];\n  }\n  _int_format(bytelength) {\n    return [\"B\", \"H\", \"I\", \"Q\"][bytelength - 1];\n  }\n};\nvar FORMAT_SIGNATURE = struct.unpack_from(\"8s\", new Uint8Array([137, 72, 68, 70, 13, 10, 26, 10]).buffer)[0];\nvar UNDEFINED_ADDRESS = struct.unpack_from(\"<Q\", new Uint8Array([255, 255, 255, 255, 255, 255, 255, 255]).buffer)[0];\nvar SUPERBLOCK_V0 = /* @__PURE__ */ new Map([\n  [\"format_signature\", \"8s\"],\n  [\"superblock_version\", \"B\"],\n  [\"free_storage_version\", \"B\"],\n  [\"root_group_version\", \"B\"],\n  [\"reserved_0\", \"B\"],\n  [\"shared_header_version\", \"B\"],\n  [\"offset_size\", \"B\"],\n  [\"length_size\", \"B\"],\n  [\"reserved_1\", \"B\"],\n  [\"group_leaf_node_k\", \"H\"],\n  [\"group_internal_node_k\", \"H\"],\n  [\"file_consistency_flags\", \"L\"],\n  [\"base_address_lower\", \"Q\"],\n  [\"free_space_address\", \"Q\"],\n  [\"end_of_file_address\", \"Q\"],\n  [\"driver_information_address\", \"Q\"]\n]);\nvar SUPERBLOCK_V0_SIZE = _structure_size(SUPERBLOCK_V0);\nvar SUPERBLOCK_V2_V3 = /* @__PURE__ */ new Map([\n  [\"format_signature\", \"8s\"],\n  [\"superblock_version\", \"B\"],\n  [\"offset_size\", \"B\"],\n  [\"length_size\", \"B\"],\n  [\"file_consistency_flags\", \"B\"],\n  [\"base_address\", \"Q\"],\n  [\"superblock_extension_address\", \"Q\"],\n  [\"end_of_file_address\", \"Q\"],\n  [\"root_group_address\", \"Q\"],\n  [\"superblock_checksum\", \"I\"]\n]);\nvar SUPERBLOCK_V2_V3_SIZE = _structure_size(SUPERBLOCK_V2_V3);\nvar SYMBOL_TABLE_ENTRY = /* @__PURE__ */ new Map([\n  [\"link_name_offset\", \"Q\"],\n  [\"object_header_address\", \"Q\"],\n  [\"cache_type\", \"I\"],\n  [\"reserved\", \"I\"],\n  [\"scratch\", \"16s\"]\n]);\nvar SYMBOL_TABLE_ENTRY_SIZE = _structure_size(SYMBOL_TABLE_ENTRY);\nvar SYMBOL_TABLE_NODE = /* @__PURE__ */ new Map([\n  [\"signature\", \"4s\"],\n  [\"version\", \"B\"],\n  [\"reserved_0\", \"B\"],\n  [\"symbols\", \"H\"]\n]);\nvar SYMBOL_TABLE_NODE_SIZE = _structure_size(SYMBOL_TABLE_NODE);\nvar LOCAL_HEAP = /* @__PURE__ */ new Map([\n  [\"signature\", \"4s\"],\n  [\"version\", \"B\"],\n  [\"reserved\", \"3s\"],\n  [\"data_segment_size\", \"Q\"],\n  [\"offset_to_free_list\", \"Q\"],\n  [\"address_of_data_segment\", \"Q\"]\n]);\nvar GLOBAL_HEAP_HEADER = /* @__PURE__ */ new Map([\n  [\"signature\", \"4s\"],\n  [\"version\", \"B\"],\n  [\"reserved\", \"3s\"],\n  [\"collection_size\", \"Q\"]\n]);\nvar GLOBAL_HEAP_HEADER_SIZE = _structure_size(GLOBAL_HEAP_HEADER);\nvar GLOBAL_HEAP_OBJECT = /* @__PURE__ */ new Map([\n  [\"object_index\", \"H\"],\n  [\"reference_count\", \"H\"],\n  [\"reserved\", \"I\"],\n  [\"object_size\", \"Q\"]\n]);\nvar GLOBAL_HEAP_OBJECT_SIZE = _structure_size(GLOBAL_HEAP_OBJECT);\nvar FRACTAL_HEAP_HEADER = /* @__PURE__ */ new Map([\n  [\"signature\", \"4s\"],\n  [\"version\", \"B\"],\n  [\"object_index_size\", \"H\"],\n  [\"filter_info_size\", \"H\"],\n  [\"flags\", \"B\"],\n  [\"max_managed_object_size\", \"I\"],\n  [\"next_huge_object_index\", \"Q\"],\n  [\"btree_address_huge_objects\", \"Q\"],\n  [\"managed_freespace_size\", \"Q\"],\n  [\"freespace_manager_address\", \"Q\"],\n  [\"managed_space_size\", \"Q\"],\n  [\"managed_alloc_size\", \"Q\"],\n  [\"next_directblock_iterator_address\", \"Q\"],\n  [\"managed_object_count\", \"Q\"],\n  [\"huge_objects_total_size\", \"Q\"],\n  [\"huge_object_count\", \"Q\"],\n  [\"tiny_objects_total_size\", \"Q\"],\n  [\"tiny_object_count\", \"Q\"],\n  [\"table_width\", \"H\"],\n  [\"starting_block_size\", \"Q\"],\n  [\"maximum_direct_block_size\", \"Q\"],\n  [\"log2_maximum_heap_size\", \"H\"],\n  [\"indirect_starting_rows_count\", \"H\"],\n  [\"root_block_address\", \"Q\"],\n  [\"indirect_current_rows_count\", \"H\"]\n]);\n\n// esm/dataobjects.js\nvar DataObjects = class {\n  constructor(fh, offset) {\n    let version_hint = struct.unpack_from(\"<B\", fh, offset)[0];\n    if (version_hint == 1) {\n      var [msgs, msg_data, header] = this._parse_v1_objects(fh, offset);\n    } else if (version_hint == \"O\".charCodeAt(0)) {\n      var [msgs, msg_data, header] = this._parse_v2_objects(fh, offset);\n    } else {\n      throw \"InvalidHDF5File('unknown Data Object Header')\";\n    }\n    this.fh = fh;\n    this.msgs = msgs;\n    this.msg_data = msg_data;\n    this.offset = offset;\n    this._global_heaps = {};\n    this._header = header;\n    this._filter_pipeline = null;\n    this._chunk_params_set = false;\n    this._chunks = null;\n    this._chunk_dims = null;\n    this._chunk_address = null;\n  }\n  get dtype() {\n    let msg = this.find_msg_type(DATATYPE_MSG_TYPE)[0];\n    let msg_offset = msg.get(\"offset_to_message\");\n    return new DatatypeMessage(this.fh, msg_offset).dtype;\n  }\n  get chunks() {\n    this._get_chunk_params();\n    return this._chunks;\n  }\n  get shape() {\n    let msg = this.find_msg_type(DATASPACE_MSG_TYPE)[0];\n    let msg_offset = msg.get(\"offset_to_message\");\n    return determine_data_shape(this.fh, msg_offset);\n  }\n  get filter_pipeline() {\n    if (this._filter_pipeline != null) {\n      return this._filter_pipeline;\n    }\n    let filter_msgs = this.find_msg_type(DATA_STORAGE_FILTER_PIPELINE_MSG_TYPE);\n    if (!filter_msgs.length) {\n      this._filter_pipeline = null;\n      return this._filter_pipeline;\n    }\n    var offset = filter_msgs[0].get(\"offset_to_message\");\n    let [version, nfilters] = struct.unpack_from(\"<BB\", this.fh, offset);\n    offset += struct.calcsize(\"<BB\");\n    var filters = [];\n    if (version == 1) {\n      let [res0, res1] = struct.unpack_from(\"<HI\", this.fh, offset);\n      offset += struct.calcsize(\"<HI\");\n      for (var _ = 0; _ < nfilters; _++) {\n        let filter_info = _unpack_struct_from(FILTER_PIPELINE_DESCR_V1, this.fh, offset);\n        offset += FILTER_PIPELINE_DESCR_V1_SIZE;\n        let padded_name_length = _padded_size(filter_info.get(\"name_length\"), 8);\n        let fmt = \"<\" + padded_name_length.toFixed() + \"s\";\n        let filter_name = struct.unpack_from(fmt, this.fh, offset)[0];\n        filter_info.set(\"filter_name\", filter_name);\n        offset += padded_name_length;\n        fmt = \"<\" + filter_info.get(\"client_data_values\").toFixed() + \"I\";\n        let client_data = struct.unpack_from(fmt, this.fh, offset);\n        filter_info.set(\"client_data\", client_data);\n        offset += 4 * filter_info.get(\"client_data_values\");\n        if (filter_info.get(\"client_data_values\") % 2) {\n          offset += 4;\n        }\n        filters.push(filter_info);\n      }\n    } else if (version == 2) {\n      for (let nf = 0; nf < nfilters; nf++) {\n        let filter_info = /* @__PURE__ */ new Map();\n        let buf = this.fh;\n        let filter_id = struct.unpack_from(\"<H\", buf, offset)[0];\n        offset += 2;\n        filter_info.set(\"filter_id\", filter_id);\n        let name_length = 0;\n        if (filter_id > 255) {\n          name_length = struct.unpack_from(\"<H\", buf, offset)[0];\n          offset += 2;\n        }\n        let flags = struct.unpack_from(\"<H\", buf, offset)[0];\n        offset += 2;\n        let optional = (flags & 1) > 0;\n        filter_info.set(\"optional\", optional);\n        let num_client_values = struct.unpack_from(\"<H\", buf, offset)[0];\n        offset += 2;\n        let name;\n        if (name_length > 0) {\n          name = struct.unpack_from(`${name_length}s`, buf, offset)[0];\n          offset += name_length;\n        }\n        filter_info.set(\"name\", name);\n        let client_values = struct.unpack_from(`<${num_client_values}i`, buf, offset);\n        offset += 4 * num_client_values;\n        filter_info.set(\"client_data_values\", client_values);\n        filters.push(filter_info);\n      }\n    } else {\n      throw `version ${version} is not supported`;\n    }\n    this._filter_pipeline = filters;\n    return this._filter_pipeline;\n  }\n  find_msg_type(msg_type) {\n    return this.msgs.filter(function(m) {\n      return m.get(\"type\") == msg_type;\n    });\n  }\n  get_attributes() {\n    let attrs = {};\n    let attr_msgs = this.find_msg_type(ATTRIBUTE_MSG_TYPE);\n    for (let msg of attr_msgs) {\n      let offset = msg.get(\"offset_to_message\");\n      let [name, value] = this.unpack_attribute(offset);\n      attrs[name] = value;\n    }\n    return attrs;\n  }\n  get fillvalue() {\n    let msg = this.find_msg_type(FILLVALUE_MSG_TYPE)[0];\n    var offset = msg.get(\"offset_to_message\");\n    var is_defined;\n    let version = struct.unpack_from(\"<B\", this.fh, offset)[0];\n    var info, size, fillvalue;\n    if (version == 1 || version == 2) {\n      info = _unpack_struct_from(FILLVAL_MSG_V1V2, this.fh, offset);\n      offset += FILLVAL_MSG_V1V2_SIZE;\n      is_defined = info.get(\"fillvalue_defined\");\n    } else if (version == 3) {\n      info = _unpack_struct_from(FILLVAL_MSG_V3, this.fh, offset);\n      offset += FILLVAL_MSG_V3_SIZE;\n      is_defined = info.get(\"flags\") & 32;\n    } else {\n      throw 'InvalidHDF5File(\"Unknown fillvalue msg version: \"' + String(version);\n    }\n    if (is_defined) {\n      size = struct.unpack_from(\"<I\", this.fh, offset)[0];\n      offset += 4;\n    } else {\n      size = 0;\n    }\n    if (size) {\n      let [getter, big_endian, size2] = dtype_getter(this.dtype);\n      let payload_view = new DataView64(this.fh);\n      fillvalue = payload_view[getter](offset, !big_endian, size2);\n    } else {\n      fillvalue = 0;\n    }\n    return fillvalue;\n  }\n  unpack_attribute(offset) {\n    let version = struct.unpack_from(\"<B\", this.fh, offset)[0];\n    var attr_map, padding_multiple;\n    if (version == 1) {\n      attr_map = _unpack_struct_from(ATTR_MSG_HEADER_V1, this.fh, offset);\n      assert(attr_map.get(\"version\") == 1);\n      offset += ATTR_MSG_HEADER_V1_SIZE;\n      padding_multiple = 8;\n    } else if (version == 3) {\n      attr_map = _unpack_struct_from(ATTR_MSG_HEADER_V3, this.fh, offset);\n      assert(attr_map.get(\"version\") == 3);\n      offset += ATTR_MSG_HEADER_V3_SIZE;\n      padding_multiple = 1;\n    } else {\n      throw \"unsupported attribute message version: \" + version;\n    }\n    let name_size = attr_map.get(\"name_size\");\n    let name = struct.unpack_from(\"<\" + name_size.toFixed() + \"s\", this.fh, offset)[0];\n    name = name.replace(/\\x00$/, \"\");\n    offset += _padded_size(name_size, padding_multiple);\n    var dtype;\n    try {\n      dtype = new DatatypeMessage(this.fh, offset).dtype;\n    } catch (e) {\n      console.log(\"Attribute \" + name + \" type not implemented, set to null.\");\n      return [name, null];\n    }\n    offset += _padded_size(attr_map.get(\"datatype_size\"), padding_multiple);\n    let shape = this.determine_data_shape(this.fh, offset);\n    let items = shape.reduce(function(a, b) {\n      return a * b;\n    }, 1);\n    offset += _padded_size(attr_map.get(\"dataspace_size\"), padding_multiple);\n    var value = this._attr_value(dtype, this.fh, items, offset);\n    if (shape.length == 0) {\n      value = value[0];\n    } else {\n    }\n    return [name, value];\n  }\n  determine_data_shape(buf, offset) {\n    let version = struct.unpack_from(\"<B\", buf, offset)[0];\n    var header;\n    if (version == 1) {\n      header = _unpack_struct_from(DATASPACE_MSG_HEADER_V1, buf, offset);\n      assert(header.get(\"version\") == 1);\n      offset += DATASPACE_MSG_HEADER_V1_SIZE;\n    } else if (version == 2) {\n      header = _unpack_struct_from(DATASPACE_MSG_HEADER_V2, buf, offset);\n      assert(header.get(\"version\") == 2);\n      offset += DATASPACE_MSG_HEADER_V2_SIZE;\n    } else {\n      throw \"unknown dataspace message version\";\n    }\n    let ndims = header.get(\"dimensionality\");\n    let dim_sizes = struct.unpack_from(\"<\" + ndims.toFixed() + \"Q\", buf, offset);\n    return dim_sizes;\n  }\n  _attr_value(dtype, buf, count, offset) {\n    var value = new Array(count);\n    if (dtype instanceof Array) {\n      let dtype_class = dtype[0];\n      for (var i = 0; i < count; i++) {\n        if (dtype_class == \"VLEN_STRING\") {\n          let character_set = dtype[2];\n          var [vlen, vlen_data] = this._vlen_size_and_data(buf, offset);\n          let fmt = \"<\" + vlen.toFixed() + \"s\";\n          let str_data = struct.unpack_from(fmt, vlen_data, 0)[0];\n          if (character_set == 0) {\n            value[i] = str_data;\n          } else {\n            value[i] = decodeURIComponent(escape(str_data));\n          }\n          offset += 16;\n        } else if (dtype_class == \"REFERENCE\") {\n          var address = struct.unpack_from(\"<Q\", buf, offset);\n          value[i] = address;\n          offset += 8;\n        } else if (dtype_class == \"VLEN_SEQUENCE\") {\n          let base_dtype = dtype[1];\n          var [vlen, vlen_data] = this._vlen_size_and_data(buf, offset);\n          value[i] = this._attr_value(base_dtype, vlen_data, vlen, 0);\n          offset += 16;\n        } else {\n          throw \"NotImplementedError\";\n        }\n      }\n    } else {\n      let [getter, big_endian, size] = dtype_getter(dtype);\n      let view = new DataView64(buf, 0);\n      for (var i = 0; i < count; i++) {\n        value[i] = view[getter](offset, !big_endian, size);\n        offset += size;\n      }\n    }\n    return value;\n  }\n  _vlen_size_and_data(buf, offset) {\n    let vlen_size = struct.unpack_from(\"<I\", buf, offset)[0];\n    let gheap_id = _unpack_struct_from(GLOBAL_HEAP_ID, buf, offset + 4);\n    let gheap_address = gheap_id.get(\"collection_address\");\n    assert(gheap_id.get(\"collection_address\") < Number.MAX_SAFE_INTEGER);\n    var gheap;\n    if (!(gheap_address in this._global_heaps)) {\n      gheap = new GlobalHeap(this.fh, gheap_address);\n      this._global_heaps[gheap_address] = gheap;\n    }\n    gheap = this._global_heaps[gheap_address];\n    let vlen_data = gheap.objects.get(gheap_id.get(\"object_index\"));\n    return [vlen_size, vlen_data];\n  }\n  _parse_v1_objects(buf, offset) {\n    let header = _unpack_struct_from(OBJECT_HEADER_V1, buf, offset);\n    assert(header.get(\"version\") == 1);\n    let total_header_messages = header.get(\"total_header_messages\");\n    var block_size = header.get(\"object_header_size\");\n    var block_offset = offset + _structure_size(OBJECT_HEADER_V1);\n    var msg_data = buf.slice(block_offset, block_offset + block_size);\n    var object_header_blocks = [[block_offset, block_size]];\n    var current_block = 0;\n    var local_offset = 0;\n    var msgs = new Array(total_header_messages);\n    for (var i = 0; i < total_header_messages; i++) {\n      if (local_offset >= block_size) {\n        [block_offset, block_size] = object_header_blocks[++current_block];\n        local_offset = 0;\n      }\n      let msg = _unpack_struct_from(HEADER_MSG_INFO_V1, buf, block_offset + local_offset);\n      let offset_to_message = block_offset + local_offset + HEADER_MSG_INFO_V1_SIZE;\n      msg.set(\"offset_to_message\", offset_to_message);\n      if (msg.get(\"type\") == OBJECT_CONTINUATION_MSG_TYPE) {\n        var [fh_off, size] = struct.unpack_from(\"<QQ\", buf, offset_to_message);\n        object_header_blocks.push([fh_off, size]);\n      }\n      local_offset += HEADER_MSG_INFO_V1_SIZE + msg.get(\"size\");\n      msgs[i] = msg;\n    }\n    return [msgs, msg_data, header];\n  }\n  _parse_v2_objects(buf, offset) {\n    var [header, creation_order_size, block_offset] = this._parse_v2_header(buf, offset);\n    offset = block_offset;\n    var msgs = [];\n    var block_size = header.get(\"size_of_chunk_0\");\n    var msg_data = buf.slice(offset, offset += block_size);\n    var object_header_blocks = [[block_offset, block_size]];\n    var current_block = 0;\n    var local_offset = 0;\n    while (true) {\n      if (local_offset >= block_size - HEADER_MSG_INFO_V2_SIZE) {\n        let next_block = object_header_blocks[++current_block];\n        if (next_block == null) {\n          break;\n        }\n        [block_offset, block_size] = next_block;\n        local_offset = 0;\n      }\n      let msg = _unpack_struct_from(HEADER_MSG_INFO_V2, buf, block_offset + local_offset);\n      let offset_to_message = block_offset + local_offset + HEADER_MSG_INFO_V2_SIZE + creation_order_size;\n      msg.set(\"offset_to_message\", offset_to_message);\n      if (msg.get(\"type\") == OBJECT_CONTINUATION_MSG_TYPE) {\n        var [fh_off, size] = struct.unpack_from(\"<QQ\", buf, offset_to_message);\n        object_header_blocks.push([fh_off + 4, size - 4]);\n      }\n      local_offset += HEADER_MSG_INFO_V2_SIZE + msg.get(\"size\") + creation_order_size;\n      msgs.push(msg);\n    }\n    return [msgs, msg_data, header];\n  }\n  _parse_v2_header(buf, offset) {\n    let header = _unpack_struct_from(OBJECT_HEADER_V2, buf, offset);\n    var creation_order_size;\n    offset += _structure_size(OBJECT_HEADER_V2);\n    assert(header.get(\"version\") == 2);\n    if (header.get(\"flags\") & 4) {\n      creation_order_size = 2;\n    } else {\n      creation_order_size = 0;\n    }\n    assert((header.get(\"flags\") & 16) == 0);\n    if (header.get(\"flags\") & 32) {\n      let times = struct.unpack_from(\"<4I\", buf, offset);\n      offset += 16;\n      header.set(\"access_time\", times[0]);\n      header.set(\"modification_time\", times[1]);\n      header.set(\"change_time\", times[2]);\n      header.set(\"birth_time\", times[3]);\n    }\n    let chunk_fmt = [\"<B\", \"<H\", \"<I\", \"<Q\"][header.get(\"flags\") & 3];\n    header.set(\"size_of_chunk_0\", struct.unpack_from(chunk_fmt, buf, offset)[0]);\n    offset += struct.calcsize(chunk_fmt);\n    return [header, creation_order_size, offset];\n  }\n  get_links() {\n    return Object.fromEntries(this.iter_links());\n  }\n  *iter_links() {\n    for (let msg of this.msgs) {\n      if (msg.get(\"type\") == SYMBOL_TABLE_MSG_TYPE) {\n        yield* this._iter_links_from_symbol_tables(msg);\n      } else if (msg.get(\"type\") == LINK_MSG_TYPE) {\n        yield this._get_link_from_link_msg(msg);\n      } else if (msg.get(\"type\") == LINK_INFO_MSG_TYPE) {\n        yield* this._iter_link_from_link_info_msg(msg);\n      }\n    }\n  }\n  *_iter_links_from_symbol_tables(sym_tbl_msg) {\n    assert(sym_tbl_msg.get(\"size\") == 16);\n    let data = _unpack_struct_from(SYMBOL_TABLE_MSG, this.fh, sym_tbl_msg.get(\"offset_to_message\"));\n    yield* this._iter_links_btree_v1(data.get(\"btree_address\"), data.get(\"heap_address\"));\n  }\n  *_iter_links_btree_v1(btree_address, heap_address) {\n    let btree = new BTreeV1Groups(this.fh, btree_address);\n    let heap = new Heap(this.fh, heap_address);\n    for (let symbol_table_address of btree.symbol_table_addresses()) {\n      let table = new SymbolTable(this.fh, symbol_table_address);\n      table.assign_name(heap);\n      yield* Object.entries(table.get_links(heap));\n    }\n  }\n  _get_link_from_link_msg(link_msg) {\n    let offset = link_msg.get(\"offset_to_message\");\n    return this._decode_link_msg(this.fh, offset)[1];\n    ;\n  }\n  _decode_link_msg(data, offset) {\n    let [version, flags] = struct.unpack_from(\"<BB\", data, offset);\n    offset += 2;\n    assert(version == 1);\n    let size_of_length_of_link_name = 2 ** (flags & 3);\n    let link_type_field_present = (flags & 2 ** 3) > 0;\n    let link_name_character_set_field_present = (flags & 2 ** 4) > 0;\n    let ordered = (flags & 2 ** 2) > 0;\n    let link_type;\n    if (link_type_field_present) {\n      link_type = struct.unpack_from(\"<B\", data, offset)[0];\n      offset += 1;\n    } else {\n      link_type = 0;\n    }\n    assert([0, 1].includes(link_type));\n    let creationorder;\n    if (ordered) {\n      creationorder = struct.unpack_from(\"<Q\", data, offset)[0];\n      offset += 8;\n    }\n    let link_name_character_set = 0;\n    if (link_name_character_set_field_present) {\n      link_name_character_set = struct.unpack_from(\"<B\", data, offset)[0];\n      offset += 1;\n    }\n    let encoding = link_name_character_set == 0 ? \"ascii\" : \"utf-8\";\n    let name_size_fmt = [\"<B\", \"<H\", \"<I\", \"<Q\"][flags & 3];\n    let name_size = struct.unpack_from(name_size_fmt, data, offset)[0];\n    offset += size_of_length_of_link_name;\n    let name = new TextDecoder(encoding).decode(data.slice(offset, offset + name_size));\n    offset += name_size;\n    let address;\n    if (link_type == 0) {\n      address = struct.unpack_from(\"<Q\", data, offset)[0];\n    } else if (link_type == 1) {\n      let length_of_soft_link_value = struct.unpack_from(\"<H\", data, offset)[0];\n      offset += 2;\n      address = new TextDecoder(encoding).decode(data.slice(offset, offset + length_of_soft_link_value));\n    }\n    return [creationorder, [name, address]];\n  }\n  *_iter_link_from_link_info_msg(info_msg) {\n    let offset = info_msg.get(\"offset_to_message\");\n    let data = this._decode_link_info_msg(this.fh, offset);\n    let heap_address = data.get(\"heap_address\");\n    let name_btree_address = data.get(\"name_btree_address\");\n    let order_btree_address = data.get(\"order_btree_address\");\n    if (name_btree_address != null) {\n      yield* this._iter_links_btree_v2(name_btree_address, order_btree_address, heap_address);\n    }\n  }\n  *_iter_links_btree_v2(name_btree_address, order_btree_address, heap_address) {\n    let heap = new FractalHeap(this.fh, heap_address);\n    let btree;\n    if (order_btree_address != UNDEFINED_ADDRESS2) {\n      btree = new BTreeV2GroupOrders(this.fh, order_btree_address);\n    } else {\n      btree = new BTreeV2GroupNames(this.fh, name_btree_address);\n    }\n    let items = /* @__PURE__ */ new Map();\n    for (let record of btree.iter_records()) {\n      let data = heap.get_data(record.get(\"heapid\"));\n      let [creationorder, item] = this._decode_link_msg(data, 0);\n      items.set(creationorder, item);\n    }\n    let sorted_keys = Array.from(items.keys()).sort();\n    for (let key of sorted_keys) {\n      yield items.get(key);\n    }\n  }\n  _decode_link_info_msg(data, offset) {\n    let [version, flags] = struct.unpack_from(\"<BB\", data, offset);\n    assert(version == 0);\n    offset += 2;\n    if ((flags & 1) > 0) {\n      offset += 8;\n    }\n    let fmt = (flags & 2) > 0 ? LINK_INFO_MSG2 : LINK_INFO_MSG1;\n    let link_info = _unpack_struct_from(fmt, data, offset);\n    let output = /* @__PURE__ */ new Map();\n    for (let [k, v] of link_info.entries()) {\n      output.set(k, v == UNDEFINED_ADDRESS2 ? null : v);\n    }\n    return output;\n  }\n  get is_dataset() {\n    return this.find_msg_type(DATASPACE_MSG_TYPE).length > 0;\n  }\n  get_data() {\n    let msg = this.find_msg_type(DATA_STORAGE_MSG_TYPE)[0];\n    let msg_offset = msg.get(\"offset_to_message\");\n    var [version, dims, layout_class, property_offset] = this._get_data_message_properties(msg_offset);\n    if (layout_class == 0) {\n      throw \"Compact storage of DataObject not implemented\";\n    } else if (layout_class == 1) {\n      return this._get_contiguous_data(property_offset);\n    } else if (layout_class == 2) {\n      return this._get_chunked_data(msg_offset);\n    }\n  }\n  _get_data_message_properties(msg_offset) {\n    let dims, layout_class, property_offset;\n    let [version, arg1, arg2] = struct.unpack_from(\"<BBB\", this.fh, msg_offset);\n    if (version == 1 || version == 2) {\n      dims = arg1;\n      layout_class = arg2;\n      property_offset = msg_offset;\n      property_offset += struct.calcsize(\"<BBB\");\n      property_offset += struct.calcsize(\"<BI\");\n      assert(layout_class == 1 || layout_class == 2);\n    } else if (version == 3 || version == 4) {\n      layout_class = arg1;\n      property_offset = msg_offset;\n      property_offset += struct.calcsize(\"<BB\");\n    }\n    assert(version >= 1 && version <= 4);\n    return [version, dims, layout_class, property_offset];\n  }\n  _get_contiguous_data(property_offset) {\n    let [data_offset] = struct.unpack_from(\"<Q\", this.fh, property_offset);\n    if (data_offset == UNDEFINED_ADDRESS2) {\n      let size = this.shape.reduce(function(a, b) {\n        return a * b;\n      }, 1);\n      return new Array(size);\n    }\n    var fullsize = this.shape.reduce(function(a, b) {\n      return a * b;\n    }, 1);\n    if (!(this.dtype instanceof Array)) {\n      let dtype = this.dtype;\n      if (/[<>=!@\\|]?(i|u|f|S)(\\d*)/.test(dtype)) {\n        let [item_getter, item_is_big_endian, item_size] = dtype_getter(dtype);\n        let output = new Array(fullsize);\n        let view = new DataView64(this.fh);\n        for (var i = 0; i < fullsize; i++) {\n          output[i] = view[item_getter](data_offset + i * item_size, !item_is_big_endian, item_size);\n        }\n        return output;\n      } else {\n        throw \"not Implemented - no proper dtype defined\";\n      }\n    } else {\n      let dtype_class = this.dtype[0];\n      if (dtype_class == \"REFERENCE\") {\n        let size = this.dtype[1];\n        if (size != 8) {\n          throw \"NotImplementedError('Unsupported Reference type')\";\n        }\n        let ref_addresses = this.fh.slice(data_offset, data_offset + fullsize);\n        return ref_addresses;\n      } else if (dtype_class == \"VLEN_STRING\") {\n        let character_set = this.dtype[2];\n        var value = [];\n        for (var i = 0; i < fullsize; i++) {\n          var [vlen, vlen_data] = this._vlen_size_and_data(this.fh, data_offset);\n          let fmt = \"<\" + vlen.toFixed() + \"s\";\n          let str_data = struct.unpack_from(fmt, vlen_data, 0)[0];\n          if (character_set == 0) {\n            value[i] = str_data;\n          } else {\n            value[i] = decodeURIComponent(escape(str_data));\n          }\n          data_offset += 16;\n        }\n        return value;\n      } else {\n        throw \"NotImplementedError('datatype not implemented')\";\n      }\n    }\n  }\n  _get_chunked_data(offset) {\n    this._get_chunk_params();\n    var chunk_btree = new BTreeV1RawDataChunks(this.fh, this._chunk_address, this._chunk_dims);\n    let data = chunk_btree.construct_data_from_chunks(this.chunks, this.shape, this.dtype, this.filter_pipeline);\n    if (this.dtype instanceof Array && /^VLEN/.test(this.dtype[0])) {\n      let dtype_class = this.dtype[0];\n      for (var i = 0; i < data.length; i++) {\n        let [item_size, gheap_address, object_index] = data[i];\n        var gheap;\n        if (!(gheap_address in this._global_heaps)) {\n          gheap = new GlobalHeap(this.fh, gheap_address);\n          this._global_heaps[gheap_address] = gheap;\n        } else {\n          gheap = this._global_heaps[gheap_address];\n        }\n        let vlen_data = gheap.objects.get(object_index);\n        if (dtype_class == \"VLEN_STRING\") {\n          let character_set = this.dtype[2];\n          let fmt = \"<\" + item_size.toFixed() + \"s\";\n          let str_data = struct.unpack_from(fmt, vlen_data, 0)[0];\n          if (character_set == 0) {\n            data[i] = str_data;\n          } else {\n            data[i] = decodeURIComponent(escape(str_data));\n          }\n        }\n      }\n    }\n    return data;\n  }\n  _get_chunk_params() {\n    if (this._chunk_params_set) {\n      return;\n    }\n    this._chunk_params_set = true;\n    var msg = this.find_msg_type(DATA_STORAGE_MSG_TYPE)[0];\n    var offset = msg.get(\"offset_to_message\");\n    var [version, dims, layout_class, property_offset] = this._get_data_message_properties(offset);\n    if (layout_class != 2) {\n      return;\n    }\n    var data_offset;\n    if (version == 1 || version == 2) {\n      var address = struct.unpack_from(\"<Q\", this.fh, property_offset)[0];\n      data_offset = property_offset + struct.calcsize(\"<Q\");\n    } else if (version == 3) {\n      var [dims, address] = struct.unpack_from(\"<BQ\", this.fh, property_offset);\n      data_offset = property_offset + struct.calcsize(\"<BQ\");\n    }\n    assert(version >= 1 && version <= 3);\n    var fmt = \"<\" + (dims - 1).toFixed() + \"I\";\n    var chunk_shape = struct.unpack_from(fmt, this.fh, data_offset);\n    this._chunks = chunk_shape;\n    this._chunk_dims = dims;\n    this._chunk_address = address;\n    return;\n  }\n};\nfunction determine_data_shape(buf, offset) {\n  let version = struct.unpack_from(\"<B\", buf, offset)[0];\n  var header;\n  if (version == 1) {\n    header = _unpack_struct_from(DATASPACE_MSG_HEADER_V1, buf, offset);\n    assert(header.get(\"version\") == 1);\n    offset += DATASPACE_MSG_HEADER_V1_SIZE;\n  } else if (version == 2) {\n    header = _unpack_struct_from(DATASPACE_MSG_HEADER_V2, buf, offset);\n    assert(header.get(\"version\") == 2);\n    offset += DATASPACE_MSG_HEADER_V2_SIZE;\n  } else {\n    throw \"InvalidHDF5File('unknown dataspace message version')\";\n  }\n  let ndims = header.get(\"dimensionality\");\n  let dim_sizes = struct.unpack_from(\"<\" + (ndims * 2).toFixed() + \"I\", buf, offset);\n  return dim_sizes.filter(function(s, i) {\n    return i % 2 == 0;\n  });\n}\nvar UNDEFINED_ADDRESS2 = struct.unpack_from(\"<Q\", new Uint8Array([255, 255, 255, 255, 255, 255, 255, 255]).buffer);\nvar GLOBAL_HEAP_ID = /* @__PURE__ */ new Map([\n  [\"collection_address\", \"Q\"],\n  [\"object_index\", \"I\"]\n]);\nvar GLOBAL_HEAP_ID_SIZE = _structure_size(GLOBAL_HEAP_ID);\nvar ATTR_MSG_HEADER_V1 = /* @__PURE__ */ new Map([\n  [\"version\", \"B\"],\n  [\"reserved\", \"B\"],\n  [\"name_size\", \"H\"],\n  [\"datatype_size\", \"H\"],\n  [\"dataspace_size\", \"H\"]\n]);\nvar ATTR_MSG_HEADER_V1_SIZE = _structure_size(ATTR_MSG_HEADER_V1);\nvar ATTR_MSG_HEADER_V3 = /* @__PURE__ */ new Map([\n  [\"version\", \"B\"],\n  [\"flags\", \"B\"],\n  [\"name_size\", \"H\"],\n  [\"datatype_size\", \"H\"],\n  [\"dataspace_size\", \"H\"],\n  [\"character_set_encoding\", \"B\"]\n]);\nvar ATTR_MSG_HEADER_V3_SIZE = _structure_size(ATTR_MSG_HEADER_V3);\nvar OBJECT_HEADER_V1 = /* @__PURE__ */ new Map([\n  [\"version\", \"B\"],\n  [\"reserved\", \"B\"],\n  [\"total_header_messages\", \"H\"],\n  [\"object_reference_count\", \"I\"],\n  [\"object_header_size\", \"I\"],\n  [\"padding\", \"I\"]\n]);\nvar OBJECT_HEADER_V2 = /* @__PURE__ */ new Map([\n  [\"signature\", \"4s\"],\n  [\"version\", \"B\"],\n  [\"flags\", \"B\"]\n]);\nvar DATASPACE_MSG_HEADER_V1 = /* @__PURE__ */ new Map([\n  [\"version\", \"B\"],\n  [\"dimensionality\", \"B\"],\n  [\"flags\", \"B\"],\n  [\"reserved_0\", \"B\"],\n  [\"reserved_1\", \"I\"]\n]);\nvar DATASPACE_MSG_HEADER_V1_SIZE = _structure_size(DATASPACE_MSG_HEADER_V1);\nvar DATASPACE_MSG_HEADER_V2 = /* @__PURE__ */ new Map([\n  [\"version\", \"B\"],\n  [\"dimensionality\", \"B\"],\n  [\"flags\", \"B\"],\n  [\"type\", \"B\"]\n]);\nvar DATASPACE_MSG_HEADER_V2_SIZE = _structure_size(DATASPACE_MSG_HEADER_V2);\nvar HEADER_MSG_INFO_V1 = /* @__PURE__ */ new Map([\n  [\"type\", \"H\"],\n  [\"size\", \"H\"],\n  [\"flags\", \"B\"],\n  [\"reserved\", \"3s\"]\n]);\nvar HEADER_MSG_INFO_V1_SIZE = _structure_size(HEADER_MSG_INFO_V1);\nvar HEADER_MSG_INFO_V2 = /* @__PURE__ */ new Map([\n  [\"type\", \"B\"],\n  [\"size\", \"H\"],\n  [\"flags\", \"B\"]\n]);\nvar HEADER_MSG_INFO_V2_SIZE = _structure_size(HEADER_MSG_INFO_V2);\nvar SYMBOL_TABLE_MSG = /* @__PURE__ */ new Map([\n  [\"btree_address\", \"Q\"],\n  [\"heap_address\", \"Q\"]\n]);\nvar LINK_INFO_MSG1 = /* @__PURE__ */ new Map([\n  [\"heap_address\", \"Q\"],\n  [\"name_btree_address\", \"Q\"]\n]);\nvar LINK_INFO_MSG2 = /* @__PURE__ */ new Map([\n  [\"heap_address\", \"Q\"],\n  [\"name_btree_address\", \"Q\"],\n  [\"order_btree_address\", \"Q\"]\n]);\nvar FILLVAL_MSG_V1V2 = /* @__PURE__ */ new Map([\n  [\"version\", \"B\"],\n  [\"space_allocation_time\", \"B\"],\n  [\"fillvalue_write_time\", \"B\"],\n  [\"fillvalue_defined\", \"B\"]\n]);\nvar FILLVAL_MSG_V1V2_SIZE = _structure_size(FILLVAL_MSG_V1V2);\nvar FILLVAL_MSG_V3 = /* @__PURE__ */ new Map([\n  [\"version\", \"B\"],\n  [\"flags\", \"B\"]\n]);\nvar FILLVAL_MSG_V3_SIZE = _structure_size(FILLVAL_MSG_V3);\nvar FILTER_PIPELINE_DESCR_V1 = /* @__PURE__ */ new Map([\n  [\"filter_id\", \"H\"],\n  [\"name_length\", \"H\"],\n  [\"flags\", \"H\"],\n  [\"client_data_values\", \"H\"]\n]);\nvar FILTER_PIPELINE_DESCR_V1_SIZE = _structure_size(FILTER_PIPELINE_DESCR_V1);\nvar DATASPACE_MSG_TYPE = 1;\nvar LINK_INFO_MSG_TYPE = 2;\nvar DATATYPE_MSG_TYPE = 3;\nvar FILLVALUE_MSG_TYPE = 5;\nvar LINK_MSG_TYPE = 6;\nvar DATA_STORAGE_MSG_TYPE = 8;\nvar DATA_STORAGE_FILTER_PIPELINE_MSG_TYPE = 11;\nvar ATTRIBUTE_MSG_TYPE = 12;\nvar OBJECT_CONTINUATION_MSG_TYPE = 16;\nvar SYMBOL_TABLE_MSG_TYPE = 17;\n\n// esm/high-level.js\nvar Group = class {\n  constructor(name, dataobjects, parent, getterProxy = false) {\n    if (parent == null) {\n      this.parent = this;\n      this.file = this;\n    } else {\n      this.parent = parent;\n      this.file = parent.file;\n    }\n    this.name = name;\n    this._links = dataobjects.get_links();\n    this._dataobjects = dataobjects;\n    this._attrs = null;\n    this._keys = null;\n    if (getterProxy) {\n      return new Proxy(this, groupGetHandler);\n    }\n  }\n  get keys() {\n    if (this._keys == null) {\n      this._keys = Object.keys(this._links);\n    }\n    return this._keys.slice();\n  }\n  get values() {\n    return this.keys.map((k) => this.get(k));\n  }\n  length() {\n    return this.keys.length;\n  }\n  _dereference(ref) {\n    if (!ref) {\n      throw \"cannot deference null reference\";\n    }\n    let obj = this.file._get_object_by_address(ref);\n    if (obj == null) {\n      throw \"reference not found in file\";\n    }\n    return obj;\n  }\n  get(y) {\n    if (typeof y == \"number\") {\n      return this._dereference(y);\n    }\n    var path = normpath(y);\n    if (path == \"/\") {\n      return this.file;\n    }\n    if (path == \".\") {\n      return this;\n    }\n    if (/^\\//.test(path)) {\n      return this.file.get(path.slice(1));\n    }\n    if (posix_dirname(path) != \"\") {\n      var [next_obj, additional_obj] = path.split(/\\/(.*)/);\n    } else {\n      var next_obj = path;\n      var additional_obj = \".\";\n    }\n    if (!(next_obj in this._links)) {\n      throw next_obj + \" not found in group\";\n    }\n    var obj_name = normpath(this.name + \"/\" + next_obj);\n    let link_target = this._links[next_obj];\n    if (typeof link_target == \"string\") {\n      try {\n        return this.get(link_target);\n      } catch (error) {\n        return null;\n      }\n    }\n    var dataobjs = new DataObjects(this.file._fh, link_target);\n    if (dataobjs.is_dataset) {\n      if (additional_obj != \".\") {\n        throw obj_name + \" is a dataset, not a group\";\n      }\n      return new Dataset(obj_name, dataobjs, this);\n    } else {\n      var new_group = new Group(obj_name, dataobjs, this);\n      return new_group.get(additional_obj);\n    }\n  }\n  visit(func) {\n    return this.visititems((name, obj) => func(name));\n  }\n  visititems(func) {\n    var root_name_length = this.name.length;\n    if (!/\\/$/.test(this.name)) {\n      root_name_length += 1;\n    }\n    var queue = this.values.slice();\n    while (queue) {\n      let obj = queue.shift();\n      if (queue.length == 1)\n        console.log(obj);\n      let name = obj.name.slice(root_name_length);\n      let ret = func(name, obj);\n      if (ret != null) {\n        return ret;\n      }\n      if (obj instanceof Group) {\n        queue = queue.concat(obj.values);\n      }\n    }\n    return null;\n  }\n  get attrs() {\n    if (this._attrs == null) {\n      this._attrs = this._dataobjects.get_attributes();\n    }\n    return this._attrs;\n  }\n};\nvar groupGetHandler = {\n  get: function(target, prop, receiver) {\n    if (prop in target) {\n      return target[prop];\n    }\n    return target.get(prop);\n  }\n};\nvar File = class extends Group {\n  constructor(fh, filename) {\n    var superblock = new SuperBlock(fh, 0);\n    var offset = superblock.offset_to_dataobjects;\n    var dataobjects = new DataObjects(fh, offset);\n    super(\"/\", dataobjects, null);\n    this.parent = this;\n    this._fh = fh;\n    this.filename = filename || \"\";\n    this.file = this;\n    this.mode = \"r\";\n    this.userblock_size = 0;\n  }\n  _get_object_by_address(obj_addr) {\n    if (this._dataobjects.offset == obj_addr) {\n      return this;\n    }\n    return this.visititems((y) => {\n      y._dataobjects.offset == obj_addr ? y : null;\n    });\n  }\n};\nvar Dataset = class extends Array {\n  constructor(name, dataobjects, parent) {\n    super();\n    this.parent = parent;\n    this.file = parent.file;\n    this.name = name;\n    this._dataobjects = dataobjects;\n    this._attrs = null;\n    this._astype = null;\n  }\n  get value() {\n    var data = this._dataobjects.get_data();\n    if (this._astype == null) {\n      return data;\n    }\n    return data.astype(this._astype);\n  }\n  get shape() {\n    return this._dataobjects.shape;\n  }\n  get attrs() {\n    return this._dataobjects.get_attributes();\n  }\n  get dtype() {\n    return this._dataobjects.dtype;\n  }\n  get fillvalue() {\n    return this._dataobjects.fillvalue;\n  }\n};\nfunction posix_dirname(p) {\n  let sep = \"/\";\n  let i = p.lastIndexOf(sep) + 1;\n  let head = p.slice(0, i);\n  let all_sep = new RegExp(\"^\" + sep + \"+$\");\n  let end_sep = new RegExp(sep + \"$\");\n  if (head && !all_sep.test(head)) {\n    head = head.replace(end_sep, \"\");\n  }\n  return head;\n}\nfunction normpath(path) {\n  return path.replace(/\\/(\\/)+/g, \"/\");\n}\nexport {\n  Dataset,\n  File,\n  Filters,\n  Group\n};\n/*! pako 2.0.4 https://github.com/nodeca/pako @license (MIT AND Zlib) */\n","import * as utils from \"./utils.js\";\nimport * as wasm from \"./wasm.js\";\nimport { Int32WasmArray, Float64WasmArray } from \"./WasmArray.js\";\nimport { PCAResults } from \"./runPCA.js\";\n\n/** \n * Wrapper for the neighbor search index on the Wasm heap.\n */\nexport class NeighborSearchIndex {\n    /**\n     * @param {Object} raw Search index on the Wasm heap.\n     *\n     * Not to be called directly by developers;\n     * use `buildNeighborSearchIndex()` instead.\n     */\n    constructor(raw) {\n        this.index = raw;\n        return;\n    }\n\n    /**\n     * @return Number of cells in the index.\n     */\n    numberOfCells() {\n        return this.index.num_obs();\n    }\n\n    /**\n     * @return Frees the memory allocated on the Wasm heap for this object.\n     * This invalidates this object and all references to it.\n     */\n    free() {\n        this.index.delete();\n        this.index = null;\n        return;\n    }\n}\n\n/**\n * Build the nearest neighbor search index.\n *\n * @param {(PCAResults|Float64WasmArray|Array|TypedArray)} x - Numeric coordinates of each cell in the dataset.\n * For array inputs, this is expected to be in column-major format where the rows are the variables and the columns are the cells.\n * For a `PCAResults` input, we extract the principal components.\n * @param {Object} [options] - Optional parameters.\n * @param {number} [options.numberOfDims] - Number of variables/dimensions per cell.\n * Only used (and required) for array-like `x`.\n * @param {number} [options.numberOfCells] - Number of cells.\n * Only used (and required) for array-like `x`.\n * @param {boolean} [options.approximate] - Whether to build an index for an approximate neighbor search.\n *\n * @return A `NeighborSearchIndex` object to use for neighbor searches.\n */\nexport function buildNeighborSearchIndex(x, { numberOfDims = null, numberOfCells = null, approximate = true } = {}) {\n    var buffer;\n    var raw;\n    var output;\n\n    try {\n        let pptr;\n\n        if (x instanceof PCAResults) {\n            numberOfDims = x.numberOfPCs();\n            numberOfCells = x.numberOfCells();\n            let pcs = x.principalComponents({ copy: false });\n            pptr = pcs.byteOffset;\n\n        } else {\n            if (numberOfDims === null || numberOfCells === null) {\n                throw \"'numberOfDims' and 'numberOfCells' must be specified when 'x' is an Array\";\n            }\n\n            buffer = utils.wasmifyArray(x, \"Float64WasmArray\");\n            if (buffer.length != numberOfDims * numberOfCells) {\n                throw \"length of 'x' must be the product of 'numberOfDims' and 'numberOfCells'\";\n            }\n\n            pptr = buffer.offset;\n        }\n\n        raw = wasm.call(module => module.build_neighbor_index(pptr, numberOfDims, numberOfCells, approximate)); \n        output = new NeighborSearchIndex(raw);\n\n    } catch (e) {\n        utils.free(raw);\n        throw e;\n\n    } finally {\n        utils.free(buffer);\n    }\n\n    return output;\n}\n\n/** \n * Wrapper for the neighbor search results on the Wasm heap.\n */\nexport class NeighborSearchResults {\n    /**\n     * @param {Object} raw Search results on the Wasm heap.\n     *\n     * Not to be called directly by developers;\n     * use `findNearestNeighbors()` or `unserialize()` instead.\n     */\n    constructor(raw) {\n        this.results = raw;\n        return;\n    }\n\n    /**\n     * @return The total number of neighbors across all cells.\n     * This is usually the product of the number of neighbors and the number of cells.\n     */\n    size() {\n        return this.results.size();\n    }\n\n    /**\n     * @return The number of cells used in the search.\n     */\n    numberOfCells() {\n        return this.results.num_obs();\n    }\n\n    /**\n     * @param {Object} [options] - Optional parameters.\n     * @param {?Int32WasmArray} [options.runs] - A Wasm-allocated array of length equal to `numberOfCells()`,\n     * to be used to store the number of neighbors per cell.\n     * @param {?Int32WasmArray} [options.indices] - A Wasm-allocated array of length equal to `size()`,\n     * to be used to store the indices of the neighbors of each cell.\n     * @param {?Float64WasmArray} [options.distances] - A Wasm-allocated array of length equal to `size()`,\n     * to be used to store the distances to the neighbors of each cell.\n     *\n     * @return \n     * If all of the arguments are non-`null`, the buffers in `runs`, `indices` and `distances` are filled with their respective contents, and nothing is returned.\n     * If all of the arguments are `null`, a object is returned with `TypedArray` entries for each component.\n     * Otherwise, an error is raised.\n     */\n    serialize({ runs = null, indices = null, distances = null } = {}) {\n        var copy = (runs === null) + (indices === null) + (distances === null);\n        if (copy != 3 && copy != 0) {\n            throw \"either all or none of 'runs', 'indices' and 'distances' can be 'null'\";\n        }\n\n        if (copy === 3) {\n            var run_data;\n            var ind_data;\n            var dist_data;\n            var output;\n            \n            try {\n                run_data = new Int32WasmArray(this.numberOfCells());\n                let s = this.size();\n                ind_data = new Int32WasmArray(s);\n                dist_data = new Float64WasmArray(s);\n                this.results.serialize(run_data.offset, ind_data.offset, dist_data.offset);\n\n                output = { \n                    \"runs\": run_data.slice(), \n                    \"indices\": ind_data.slice(), \n                    \"distances\": dist_data.slice() \n                };\n            } finally {\n                utils.free(run_data);\n                utils.free(ind_data);\n                utils.free(dist_data);\n            }\n\n            return output;\n        } else {\n            this.results.serialize(runs.offset, indices.offset, distances.offset);\n        }\n    }\n\n    /**\n     * @param {Int32WasmArray|Array|TypedArray} runs An array of length equal to `numberOfCells()`,\n     * containing the number of neighbors per cell.\n     * @param {Int32WasmArray|Array|TypedArray} indices An array of length equal to `size()`,\n     * containing the indices of the neighbors of each cell.\n     * @param {Float64WasmArray|Array|TypedArray} indices An array of length equal to `size()`,\n     * containing the distances to the neighbors of each cell.\n     *\n     * @return A new `NeighborSearchResults` object containing the unserialized search results.\n     */\n    static unserialize(runs, indices, distances) {\n        var raw;\n        var output;\n        var run_data;\n        var ind_data;\n        var dist_data;\n\n        try {\n            run_data = utils.wasmifyArray(runs, \"Int32WasmArray\");\n            ind_data = utils.wasmifyArray(indices, \"Int32WasmArray\");\n            dist_data = utils.wasmifyArray(distances, \"Float64WasmArray\");\n            raw = wasm.call(module => new module.NeighborResults(runs.length, run_data.offset, ind_data.offset, dist_data.offset));\n            output = new NeighborSearchResults(raw);\n        } catch (e) {\n            utils.free(raw);\n            throw e;\n        } finally { \n            utils.free(run_data);\n            utils.free(ind_data);\n            utils.free(dist_data);\n        }\n\n        return output;\n    }\n\n    /**\n     * @return Frees the memory allocated on the Wasm heap for this object.\n     * This invalidates this object and all references to it.\n     */\n    free() {\n        this.results.delete();\n        this.results = null;\n        return;\n    }\n}\n\n/**\n * Find the nearest neighbors for each cell.\n *\n * @param {NeighborSearchIndex} x The pre-build neighbor search index from `buildNeighborSearchIndex()`.\n * @param {number} k Number of neighbors to find.\n *\n * @return A `NeighborSearchResults` object containing the search results.\n */\nexport function findNearestNeighbors(x, k) {\n    var raw;\n    var output;\n\n    try {\n        raw = wasm.call(module => module.find_nearest_neighbors(x.index, k));\n        output = new NeighborSearchResults(raw);\n    } catch (e) {\n        utils.free(raw);\n        throw e;\n    }\n\n    return output;\n}\n","import { WasmArray, \n         Int8WasmArray,  Uint8WasmArray, \n         Int16WasmArray, Uint16WasmArray,\n         Int32WasmArray, Uint32WasmArray,\n         Float32WasmArray, Float64WasmArray } from \"./WasmArray.js\";\n\nexport function wasmifyArray(x, expected) {\n    if (x instanceof WasmArray) {\n        if (expected !== null && expected != x.constructor.className) {\n            throw \"expected '\" + expected + \"', got '\" + x.constructor.className + \"'\";\n        }\n        if (x.owner) {\n            return new x.constructor(x.length, x.offset); // when offset is supplied, this is a view.\n        } else {\n            return x; // it's already a view, so we just pass it along.\n        }\n    }\n\n    if (expected === null) {\n        if (ArrayBuffer.isView(x)) {\n            expected = x.constructor.name.replace(\"Array\", \"WasmArray\");\n        } else {\n            expected = \"Float64WasmArray\";\n        }\n    }\n\n    let y = null;\n    try {\n        switch (expected) {\n            case \"Uint8WasmArray\":\n                y = new Uint8WasmArray(x.length);\n                break;\n            case \"Int8WasmArray\":\n                y = new Int8WasmArray(x.length);\n                break;\n            case \"Uint16WasmArray\":\n                y = new Uint16WasmArray(x.length);\n                break;\n            case \"Int16WasmArray\":\n                y = new Int16WasmArray(x.length);\n                break;\n            case \"Uint32WasmArray\":\n                y = new Uint32WasmArray(x.length);\n                break;\n            case \"Int32WasmArray\":\n                y = new Int32WasmArray(x.length);\n                break;\n            case \"Float32WasmArray\":\n                y = new Float32WasmArray(x.length);\n                break;\n            case \"BigInt64WasmArray\":\n            case \"BigUint64WasmArray\":\n            case \"Float64WasmArray\":\n                y = new Float64WasmArray(x.length); // no HEAP64 as of time of writing.\n                break;\n            default:\n                throw \"unknown expected type '\" + expected + \"'\";\n        }\n\n        if (expected.startsWith(\"BigInt\") || expected.startsWith(\"BigUint\")) {\n            // Needs an explicit cast.\n            var v = y.array();\n            expected.forEach((x, i) => { v[i] = Number(x) });\n        } else {\n            y.set(x);\n        }\n    } catch(e) {\n        if (y !== null) {\n            y.free();\n        }\n        throw e;\n    }\n\n    return y;\n}\n\nexport function free(x) {\n    if (x !== null && x !== undefined) {\n        if (\"free\" in x) {\n            x.free();\n        } else if (\"delete\" in x) {\n            x.delete(); // i.e., one of the raw C++ classes.\n        }\n    }\n}\n\nexport function extractXY(ncells, coordinates) {\n    let x = new Float64Array(ncells);\n    let y = new Float64Array(ncells);\n\n    for (var i = 0; i < ncells; i++) {\n        x[i] = coordinates[2 * i];\n        y[i] = coordinates[2 * i + 1];\n    }\n\n    return { \"x\": x, \"y\": y };\n}\n\nexport function possibleCopy(x, copy) {\n    if (copy) {\n        return x.slice();\n    } else {\n        return x;\n    }\n}\n"],"names":["module","exports","_structure_size","structure","fmt","Array","from","values","join","struct","calcsize","this","big_endian","array","Uint8Array","Uint32Array","buffer","isBigEndian","getters","byte_lengths","all_formats","Object","keys","fmt_size_regex","match","size","regex","RegExp","exec","n","parseInt","f","test","offset","Number","view","DataView64","output","_is_big_endian","append_target","getter","sarray","i","push","reduce","a","b","String","fromCharCode","byteOffset","littleEndian","left","BigInt","getUint32","right","combined","low","high","getInt32","length","c","getUint8","decodeURIComponent","escape","getUint64","DataView","DATATYPE_MSG","Map","zero$1","buf","len","LITERALS$1","L_CODES$1","D_CODES$1","MAX_BITS$1","extra_lbits","extra_dbits","extra_blbits","bl_order","static_ltree","static_dtree","_dist_code","_length_code","MAX_MATCH$1","base_length","static_l_desc","static_d_desc","static_bl_desc","base_dist","StaticTreeDesc","static_tree","extra_bits","extra_base","elems","max_length","has_stree","TreeDesc","dyn_tree","stat_desc","max_code","d_code","dist","put_short","s","w","pending_buf","pending","send_bits","value","bi_valid","bi_buf","send_code","tree","bi_reverse","code","res","gen_codes","bl_count","bits","next_code","init_block","dyn_ltree","dyn_dtree","bl_tree","END_BLOCK","opt_len","static_len","last_lit","matches","bi_windup","smaller","m","depth","_n2","_m2","pqdownheap","k","v","heap","j","heap_len","compress_block","ltree","dtree","lc","extra","lx","d_buf","l_buf","build_tree","desc","node2","stree","heap_max","h","xbits","base","overflow","gen_bitlen","scan_tree","curlen","prevlen","nextlen","count","max_count","min_count","REP_3_6","REPZ_3_10","REPZ_11_138","send_tree","static_init_done","_tr_stored_block$1","stored_len","last","header","set","window","subarray","copy_block","trees","_tr_init","LENGTH_CODES$1","tr_static_init","l_desc","d_desc","bl_desc","_tr_stored_block","_tr_flush_block","opt_lenb","static_lenb","max_blindex","level","strm","data_type","black_mask","detect_data_type","BL_CODES$1","build_bl_tree","strategy","lcodes","dcodes","blcodes","rank2","send_all_trees","_tr_tally","lit_bufsize","_tr_align","STATIC_TREES","bi_flush","adler32_1","adler","pos","s1","s2","crcTable","table","makeTable","crc32_1","crc","t","end","messages","constants$2","Z_NO_FLUSH","Z_PARTIAL_FLUSH","Z_SYNC_FLUSH","Z_FULL_FLUSH","Z_FINISH","Z_BLOCK","Z_TREES","Z_OK","Z_STREAM_END","Z_NEED_DICT","Z_ERRNO","Z_STREAM_ERROR","Z_DATA_ERROR","Z_MEM_ERROR","Z_BUF_ERROR","Z_NO_COMPRESSION","Z_BEST_SPEED","Z_BEST_COMPRESSION","Z_DEFAULT_COMPRESSION","Z_FILTERED","Z_HUFFMAN_ONLY","Z_RLE","Z_FIXED","Z_DEFAULT_STRATEGY","Z_BINARY","Z_TEXT","Z_UNKNOWN","Z_DEFLATED","Z_NO_FLUSH$2","Z_FULL_FLUSH$1","Z_FINISH$3","Z_BLOCK$1","Z_OK$3","Z_STREAM_END$3","Z_STREAM_ERROR$2","Z_DATA_ERROR$2","Z_BUF_ERROR$1","Z_DEFAULT_COMPRESSION$1","Z_DEFAULT_STRATEGY$1","Z_DEFLATED$2","MAX_MATCH","MIN_LOOKAHEAD","HCRC_STATE","BUSY_STATE","FINISH_STATE","err","errorCode","msg","rank","zero","HASH","prev","data","hash_shift","hash_mask","flush_pending","state","avail_out","pending_out","next_out","total_out","flush_block_only","block_start","strstart","put_byte","putShortMSB","read_buf","start","avail_in","input","next_in","wrap","total_in","longest_match","cur_match","chain_length","max_chain_length","scan","best_len","prev_length","nice_match","limit","w_size","_win","wmask","w_mask","strend","scan_end1","scan_end","good_match","lookahead","match_start","fill_window","p","more","str","_w_size","window_size","hash_size","head","insert","ins_h","deflate_fast","flush","hash_head","bflush","match_length","max_lazy_match","MIN_MATCH","deflate_slow","max_insert","prev_match","match_available","Config","good_length","max_lazy","nice_length","max_chain","func","configuration_table","max_block_size","pending_buf_size","max_start","DeflateState","status","gzhead","gzindex","method","last_flush","w_bits","hash_bits","Uint16Array","HEAP_SIZE","MAX_BITS","deflateResetKeep","deflateReset","ret","deflateInit2","windowBits","memLevel","deflate_1$2","deflateInit","deflateSetHeader","deflate","beg","val","old_flush","text","hcrc","name","comment","time","os","charCodeAt","bstate","deflate_huff","deflate_rle","deflateEnd","deflateSetDictionary","dictionary","dictLength","tmpDict","avail","next","deflateInfo","_has","obj","key","prototype","hasOwnProperty","call","common","sources","slice","arguments","source","shift","TypeError","chunks","l","result","chunk","STR_APPLY_UIA_OK","apply","__","_utf8len","q","strings","TextEncoder","encode","c2","m_pos","str_len","buf_len","max","out","TextDecoder","decode","utf16buf","c_len","buf2binstring","zstream","toString$1","toString","Z_NO_FLUSH$1","Z_FINISH$2","Z_OK$2","Z_STREAM_END$2","Z_DEFLATED$1","Deflate$1","options","chunkSize","opt","raw","gzip","ended","Error","dict","_dict_set","flush_mode","_flush_mode","onData","onEnd","inffast","_in","_out","dmax","wsize","whave","wnext","s_window","hold","lcode","dcode","lmask","dmask","here","op","from_source","lencode","distcode","lenbits","distbits","top","dolen","mode","dodist","sane","MAXBITS","lbase","lext","dbase","dext","inftrees","type","lens","lens_index","codes","table_index","work","opts","incr","fill","mask","here_bits","here_op","here_val","sym","min","root","curr","drop","used","huff","base_index","offs","extra_index","Z_FINISH$1","Z_OK$1","Z_STREAM_END$1","Z_NEED_DICT$1","Z_STREAM_ERROR$1","Z_DATA_ERROR$1","Z_MEM_ERROR$1","TYPE","BAD","zswap32","InflateState","havedict","flags","check","total","wbits","ncode","nlen","ndist","have","lendyn","distdyn","back","was","lenfix","distfix","inflateResetKeep","Int32Array","inflateReset","inflateReset2","inflateInit2","virgin","fixedtables","updatewindow","src","copy","inflate_1$2","inflateInit","inflate","put","last_bits","last_op","last_val","hbuf","order","inf_leave","done","xflags","extra_len","inflateEnd","inflateGetHeader","inflateSetDictionary","inflateInfo","gzheader","Inflate$1","to","last_avail_out","next_out_utf8","tail","utf8str","unpack_from","SUPERBLOCK_V0","SUPERBLOCK_V2_V3","SYMBOL_TABLE_ENTRY","SYMBOL_TABLE_NODE","GLOBAL_HEAP_HEADER","GLOBAL_HEAP_OBJECT","GLOBAL_HEAP_ID","ATTR_MSG_HEADER_V1","ATTR_MSG_HEADER_V3","DATASPACE_MSG_HEADER_V1","DATASPACE_MSG_HEADER_V2","HEADER_MSG_INFO_V1","HEADER_MSG_INFO_V2","FILLVAL_MSG_V1V2","FILLVAL_MSG_V3","FILTER_PIPELINE_DESCR_V1","NeighborSearchIndex","index","num_obs","delete","NeighborSearchResults","results","runs","indices","distances","run_data","ind_data","dist_data","Int32WasmArray","numberOfCells","Float64WasmArray","serialize","utils","wasm","NeighborResults","e","findNearestNeighbors","x","find_nearest_neighbors","wasmifyArray","expected","WasmArray","constructor","className","owner","ArrayBuffer","isView","replace","y","Uint8WasmArray","Int8WasmArray","Uint16WasmArray","Int16WasmArray","Uint32WasmArray","Float32WasmArray","startsWith","forEach","free","undefined","extractXY","ncells","coordinates","Float64Array"],"sourceRoot":""}