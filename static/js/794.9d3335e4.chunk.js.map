{"version":3,"file":"static/js/794.9d3335e4.chunk.js","mappings":"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","sources":["workers/_utils.js","workers/_inputs.js","workers/mito.js","workers/_quality_control.js","workers/_normalization.js","workers/_model_gene_var.js","workers/_pca.js","workers/_neighbor_index.js","workers/_snn_cluster.js","workers/_kmeans_cluster.js","workers/_choose_clustering.js","workers/_utils_viz_parent.js","workers/_tsne_monitor.js","workers/_umap_monitor.js","workers/_utils_markers.js","workers/_score_markers.js","workers/DownloadsDBHandler.js","workers/_label_cells.js","workers/_custom_markers.js","workers/KanaDBHandler.js","workers/legacy/from_v0.js","workers/_utils_serialize.js","workers/scran.worker.js","../webpack/bootstrap","../webpack/runtime/chunk loaded","../webpack/runtime/compat get default export","../webpack/runtime/define property getters","../webpack/runtime/ensure chunk","../webpack/runtime/get javascript chunk filename","../webpack/runtime/get mini-css chunk filename","../webpack/runtime/global","../webpack/runtime/hasOwnProperty shorthand","../webpack/runtime/make namespace object","../webpack/runtime/publicPath","../webpack/runtime/importScripts chunk loading","../webpack/runtime/startup chunk dependencies","../webpack/startup"],"sourcesContent":["import * as scran from \"scran.js\";\nimport * as wa from \"wasmarrays.js\";\n\nexport function copyVectors(data, copy) {\n    if (copy) {\n        for (const k of Object.keys(data)) {\n            data[k] = data[k].slice();\n        }\n    }\n}\n\nexport function copyOrView(copy) {\n    if (!copy) {\n        return \"view\";\n    } else {\n        return copy;\n    }\n}\n\nexport function mimicGetter(value, copy) {\n    if (value instanceof wa.WasmArray) {\n        if (copy == \"view\") {\n            return value.view();\n        } else if (copy) {\n            return value.slice();\n        } else {\n            return value.array();\n        }\n    } else {\n        if (copy === true) {\n            return value.slice();\n        } else {\n            // Includes copy = \"view\"; we just provide a no-copy and assume\n            // that, if the caller actually wanted a WasmArray, they would\n            // have generated a WasmArray during the unserialization.\n            return value;\n        }\n    }\n}\n\nexport function freeCache(object) {\n    if (object !== undefined && object !== null) {\n        object.free();\n    }\n    return;\n}\n\nexport function changedParameters(x, y) {\n    return JSON.stringify(x) != JSON.stringify(y);\n}\n\nexport function allocateCachedArray(size, type, cache, name = \"buffer\") {\n    var reallocate = true;\n    if (name in cache) {\n        var candidate = cache[name];\n        if (candidate.size != size || candidate.constructor.className != type) {\n            candidate.free();\n        } else {\n            reallocate = false;\n        }\n    }\n  \n    if (reallocate) {\n        switch (type) {\n            case \"Uint8Array\":\n                cache[name] = scran.createUint8WasmArray(size);\n                break;\n            case \"Int32Array\":\n                cache[name] = scran.createInt32WasmArray(size);\n                break;\n            case \"Float64Array\":\n                cache[name] = scran.createFloat64WasmArray(size);\n                break;\n            default:\n                // We only ever use one of the three above types in our \n                // internal data stores, so no need to go all-out here.\n                throw \"allocating '\" + type + \"' not yet supported\";\n        }\n    }\n\n    return cache[name];\n}\n\nexport function extractBuffers(object, store) {\n    if (Array.isArray(object)) {\n        for (const element of object) {\n            extractBuffers(element, store);\n        }\n    } else if (object.constructor == Object) {\n        for (const [key, element] of Object.entries(object)) {\n            extractBuffers(element, store);\n        }\n    } else if (ArrayBuffer.isView(object)) {\n        if (! (object.buffer instanceof ArrayBuffer)) {\n            throw \"only ArrayBuffers should be in the message payload\";\n        }\n        store.push(object.buffer);\n    }\n}\n\nexport function isObject(object) {\n    return typeof object === 'object' && Array.isArray(object) === false;\n}\n","import * as scran from \"scran.js\";\nimport * as utils from \"./_utils.js\";\nimport * as d3 from \"d3-dsv\";\nimport * as pako from \"pako\";\n\nvar cache = {};\nvar parameters = {};\nvar abbreviated = {};\n\nexport var changed = false;\n\nfunction dummyGenes(numberOfRows) {\n    let genes = []\n    for (let i = 0; i < numberOfRows; i++) {\n        genes.push(`Gene ${i + 1}`);\n    }\n    return { \"id\": genes };\n}\n\nfunction readDSVFromBuffer(content, fname, delim = \"\\t\") {\n    var ext = fname.name.split('.').pop();\n\n    if (ext == \"gz\") {\n        content = pako.ungzip(content);\n    }\n\n    const dec = new TextDecoder();\n    let decoded = dec.decode(content);\n    const tsv = d3.dsvFormat(delim);\n    let parsed = tsv.parseRows(decoded);\n\n    return parsed;\n}\n\n/***********************************\n ****** Matrix Market loaders ******\n ***********************************/\n\nfunction loadMatrixMarketRaw(files) {\n    utils.freeCache(cache.matrix);\n\n    // In theory, this section may support multiple files (e.g., for multiple samples).\n    var mtx_files = files.filter(x => x.type == \"mtx\");\n    var first_mtx = mtx_files[0];\n    var contents = new Uint8Array(first_mtx.buffer);\n    var ext = first_mtx.name.split('.').pop();\n    var is_compressed = (ext == \"gz\");\n    cache.matrix = scran.initializeSparseMatrixFromMatrixMarketBuffer(contents, { \"compressed\": is_compressed });\n\n    var genes_file = files.filter(x => x.type == \"genes\");\n    if (genes_file.length == 1) {\n        var genes_file = genes_file[0]\n        var content = new Uint8Array(genes_file.buffer);\n\n        let parsed = readDSVFromBuffer(content, genes_file);\n\n        if (parsed.length != cache.matrix.numberOfRows()) {\n            throw \"number of matrix rows is not equal to the number of genes in '\" + genes_file.name + \"'\";\n        }\n\n        var ids = [], symb = [];\n        parsed.forEach(x => {\n            ids.push(x[0]);\n            symb.push(x[1]);\n        });\n\n        cache.genes = { \"id\": ids, \"symbol\": symb };\n    } else {\n        cache.genes = dummyGenes(cache.matrix.numberOfRows());\n    }\n\n    scran.permuteFeatures(cache.matrix, cache.genes);\n\n    var annotations_file = files.filter(x => x.type == \"annotations\");\n    if (annotations_file.length == 1) {\n        var annotations_file = annotations_file[0]\n        var content = new Uint8Array(annotations_file.buffer);\n\n        let parsed = readDSVFromBuffer(content, annotations_file);\n\n        let diff = cache.matrix.numberOfColumns() - parsed.length;\n        // check if a header is present or not\n        let headerFlag = false;\n        if (diff === 0) {\n            headerFlag = false;\n        } else if (diff === -1) {\n            headerFlag = true;\n        } else {\n            throw \"number of annotations rows is not equal to the number of cells in '\" + annotations_file.name + \"'\";\n        }\n\n        let headers = [];\n        if (headerFlag) {\n            headers = parsed.shift();\n        } else {\n            parsed[0].forEach((x, i) => {\n                headers.push(`Column_${i + 1}`);\n            })\n        }\n\n        cache.annotations = {}\n        headers.forEach((x, i) => {\n            cache.annotations[x] = parsed.map(y => y[i]);\n        });\n\n    } else {\n        cache.annotations = null;\n    }\n\n    return;\n}\n\nfunction loadMatrixMarket(args) {\n    var reader = new FileReaderSync();\n\n    // First pass computes an abbreviated version to quickly check for changes.\n    // Second pass does the actual readArrayBuffer.\n    for (var it = 0; it < 2; it++) {\n        var formatted = { \"format\": \"MatrixMarket\", \"files\": [] };\n\n        var bufferFun;\n        if (it == 0) {\n            bufferFun = (f) => f.size;\n        } else {\n            bufferFun = (f) => reader.readAsArrayBuffer(f);\n        }\n\n        for (const f of args.mtx) {\n            formatted.files.push({ \"type\": \"mtx\", \"name\": f.name, \"buffer\": bufferFun(f) });\n        }\n\n        if (args.gene !== null) {\n            if (args.gene.length !== 1) {\n                throw \"expected no more than one gene file\";\n            }\n            var genes_file = args.gene[0];\n            formatted.files.push({ \"type\": \"genes\", \"name\": genes_file.name, \"buffer\": bufferFun(genes_file) });\n        }\n\n        if (args.barcode !== null) {\n            if (args.barcode.length !== 1) {\n                throw \"expected no more than one cell annotation file\";\n            }\n            var annotations_file = args.barcode[0];\n            formatted.files.push({ \"type\": \"annotations\", \"name\": annotations_file.name, \"buffer\": bufferFun(annotations_file) });\n        }\n\n        if (it == 0) {\n            if (!utils.changedParameters(abbreviated, formatted)) {\n                changed = false;\n                return;\n            } else {\n                abbreviated = formatted;\n                changed = true;\n            }\n        } else {\n            parameters = formatted;\n            loadMatrixMarketRaw(formatted.files);\n        }\n    }\n\n    return;\n}\n\n/**************************\n ****** HDF5 loaders ******\n **************************/\n\nfunction load10XRaw(files) {\n    utils.freeCache(cache.matrix);\n\n    // In theory, we could support multiple HDF5 buffers.\n    var first_file = files[0];\n    var tmppath = first_file.name;\n    scran.writeFile(tmppath, new Uint8Array(first_file.buffer));\n\n    try {\n        cache.matrix = scran.initializeSparseMatrixFromHDF5(tmppath, \"matrix\");\n\n        // Fetching the gene IDs and names.\n        cache.genes = null;\n        let objects = scran.extractHDF5ObjectNames(tmppath);\n        if (\"features\" in objects[\"matrix\"]) {\n            let fobjects = objects[\"matrix\"][\"features\"];\n            if (\"id\" in fobjects && fobjects[\"id\"] === \"string dataset\") {\n                cache.genes = { id: scran.loadHDF5Dataset(tmppath, \"matrix/features/id\").contents };\n                if (\"name\" in fobjects && fobjects[\"name\"] === \"string dataset\") {\n                    cache.genes.names = scran.loadHDF5Dataset(tmppath, \"matrix/features/name\").contents;\n                }\n            }\n        }\n\n        // TODO: pull out sample IDs from the HDF5 file, if they exist.\n        cache.annotations = null;\n\n    } finally {\n        scran.removeFile(tmppath);\n    }\n\n    if (cache.genes === null) {\n        cache.genes = dummyGenes(cache.matrix.numberOfRows());\n    }\n    scran.permuteFeatures(cache.matrix, cache.genes);\n\n    return;\n}\n\nfunction loadH5ADRaw(files, name) {\n    utils.freeCache(cache.matrix);\n\n    // In theory, we could support multiple HDF5 buffers.\n    var first_file = files[0];\n    var tmppath = first_file.name;\n    scran.writeFile(tmppath, new Uint8Array(first_file.buffer));\n\n    try {\n        cache.matrix = scran.initializeSparseMatrixFromHDF5(tmppath, \"X\");\n        let objects = scran.extractHDF5ObjectNames(tmppath);\n\n        // Trying to guess the gene names.\n        cache.genes = null;\n        if (\"var\" in objects) {\n            let vobjects = objects[\"var\"];\n            if (utils.isObject(vobjects)) {\n                if (\"_index\" in vobjects && vobjects[\"_index\"] == \"string dataset\") {\n                    cache.genes = { \"_index\": scran.loadHDF5Dataset(tmppath, \"var/_index\").contents };\n                    for (const [key, val] of Object.entries(vobjects)) {\n                        if (val === \"string dataset\" && (key.match(/name/i) || key.match(/symb/i))) {\n                            cache.genes[key] = scran.loadHDF5Dataset(tmppath, `var/${key}`).contents;\n                        }\n                    }\n                }\n            }\n        }\n\n        // Adding the annotations.\n        cache.annotations = null;\n        if (\"obs\" in objects) {\n            let bobjects = objects[\"obs\"];\n            cache.annotations = {};\n\n            if (utils.isObject(bobjects)) {\n                // Maybe it has names, maybe not, who knows; let's just add what's there.\n                if (\"_index\" in bobjects && bobjects[\"_index\"] == \"string dataset\") {\n                    cache.annotations[\"_index\"] = scran.loadHDF5Dataset(tmppath, \"obs/_index\").contents;\n                }\n\n                for (const [key, val] of Object.entries(bobjects)) {\n                    if (val === \"string dataset\" || val === \"integer dataset\" || val === \"float dataset\") {\n                        let bobj_factors = scran.loadHDF5Dataset(tmppath, `obs/${key}`).contents;\n\n                        if (\"__categories\" in bobjects && bobjects[\"__categories\"][key] == \"string dataset\") {\n                            let bobj_index = scran.loadHDF5Dataset(tmppath, `obs/__categories/${key}`).contents;\n                            cache.annotations[key] = {\n                                \"type\": \"factor\",\n                                \"index\": bobj_index,\n                                \"factor\": bobj_factors\n                            }\n                        } else {\n                            cache.annotations[key] = bobj_factors;\n                        }\n                    }\n                }\n            }\n        }\n\n    } finally {\n        scran.removeFile(tmppath);\n    }\n\n    if (cache.genes === null) {\n        cache.genes = dummyGenes(cache.matrix.numberOfRows());\n    }\n    scran.permuteFeatures(cache.matrix, cache.genes);\n\n    return;\n}\n\nfunction loadHDF5(args, format) {\n    var reader = new FileReaderSync();\n\n    // First pass computes an abbreviated version to quickly check for changes.\n    // Second pass does the actual readArrayBuffer.\n    for (var it = 0; it < 2; it++) {\n        var formatted = { \"format\": format, \"files\": [] };\n\n        var bufferFun;\n        if (it == 0) {\n            bufferFun = (f) => f.size;\n        } else {\n            bufferFun = (f) => reader.readAsArrayBuffer(f);\n        }\n\n        for (const f of args.file) {\n            formatted.files.push({ \"type\": \"h5\", \"name\": f.name, \"buffer\": bufferFun(f) });\n        }\n\n        if (it == 0) {\n            if (!utils.changedParameters(abbreviated, formatted)) {\n                changed = false;\n                return;\n            } else {\n                abbreviated = formatted;\n                changed = true;\n            }\n        } else {\n            parameters = formatted;\n            if (format == \"10X\") {\n                load10XRaw(formatted.files);\n            } else {\n                loadH5ADRaw(formatted.files);\n            }\n        }\n    }\n\n    return;\n}\n\n/******************************\n ****** Standard exports ******\n ******************************/\n\nexport function compute(format, files) {\n    switch (format) {\n        case \"mtx\":\n            loadMatrixMarket(files);\n            break;\n        case \"hdf5\":\n        case \"tenx\":\n            loadHDF5(files, \"10X\");\n            break;\n        case \"h5ad\":\n            loadHDF5(files, \"H5AD\");\n            break;\n        case \"kana\":\n            // do nothing, this is handled by unserialize.\n            break;\n        default:\n            throw \"unknown matrix file extension: '\" + format + \"'\";\n    }\n    return;\n}\n\nexport function results() {\n    var output = { \n        \"dimensions\": {\n            \"num_genes\": cache.matrix.numberOfRows(),\n            \"num_cells\": cache.matrix.numberOfColumns()\n        },\n        \"genes\": { ...cache.genes }\n    };\n    if (cache.annotations) {\n        output.annotations = Object.keys(cache.annotations);\n    }\n    return output;\n}\n\nexport async function serialize(handle, saver, embedded) {\n    let ghandle = handle.createGroup(\"inputs\");\n\n    {\n        let phandle = ghandle.createGroup(\"parameters\"); \n        phandle.writeDataSet(\"format\", \"String\", [], parameters.format);\n        let fihandle = phandle.createGroup(\"files\");\n\n        let sofar = 0;\n        for (const [index, obj] of parameters.files.entries()) {\n            let curhandle = fihandle.createGroup(String(index));\n            curhandle.writeDataSet(\"type\", \"String\", [], obj.type);\n            curhandle.writeDataSet(\"name\", \"String\", [], obj.name);\n\n            let res = await saver(obj);\n            if (embedded) {\n                curhandle.writeDataSet(\"offset\", \"Uint32\", [], res.offset);\n                curhandle.writeDataSet(\"size\", \"Uint32\", [], res.size);\n            } else {\n                curhandle.writeDataSet(\"id\", \"String\", [], res);\n            }\n        }\n    }\n\n    {\n        let perm = cache.matrix.permutation({ copy: \"view\" });\n        let dims = [\n            cache.matrix.numberOfRows(),\n            cache.matrix.numberOfColumns()\n        ];\n\n        let rhandle = ghandle.createGroup(\"results\"); \n        rhandle.writeDataSet(\"dimensions\", \"Int32\", null, dims);\n        rhandle.writeDataSet(\"permutation\", \"Int32\", null, perm);\n    }\n\n    return;\n}\n\nexport async function unserialize(handle, loader, embedded) {\n    let ghandle = handle.open(\"inputs\");\n    let phandle = ghandle.open(\"parameters\"); \n\n    // Extracting the files.\n    let fihandle = phandle.open(\"files\");\n    let kids = fihandle.children;\n    let files = new Array(kids.length);\n    \n    for (const x of Object.keys(kids)) {\n        let current = fihandle.open(x);\n\n        let curfile = {};\n        for (const field of [\"type\", \"name\"]) {\n            let dhandle = current.open(field, { load: true });\n            curfile[field] = dhandle.values[0];\n        }\n\n        if (!embedded) {\n            let dhandle = current.open(\"id\", { load: true });\n            curfile.buffer = await loader(dhandle.values[0]);\n        } else {\n            let buffer_deets = {};\n            for (const field of [\"offset\", \"size\"]) {\n                let dhandle = current.open(field, { load: true });\n                buffer_deets[field] = dhandle.values[0];\n            }\n            curfile.buffer = await loader(buffer_deets.offset, buffer_deets.size);\n        }\n\n        let idx = Number(x);\n        files[idx] = curfile;\n    }\n\n    // Run the reloaders now.\n    let format = phandle.open(\"format\", { load: true }).values[0];\n    if (format == \"MatrixMarket\") {\n        loadMatrixMarketRaw(files);\n\n    } else if (format == \"H5AD\") {\n        loadH5ADRaw(files);\n\n    } else if (format == \"10X\") {\n        load10XRaw(files);\n\n    } else if (format == \"HDF5\") {\n        // legacy support: trying to guess what it is based on its extension.\n        if (files[0].name.match(/h5ad$/i)) {\n            loadH5ADRaw(files);\n        } else {\n            load10XRaw(files);\n        }\n\n    } else {\n        throw `unrecognized count matrix format \"${format}\"`;\n    }\n\n    parameters = { \n        format: format, \n        files: files \n    };\n\n    // We need to do something if the permutation is not the same.\n    let rhandle = ghandle.open(\"results\"); \n\n    let perm = null;\n    if (\"permutation\" in rhandle.children) {\n        let dhandle = rhandle.open(\"permutation\", { load: true });\n        perm = scran.updatePermutation(cache.matrix, dhandle.values);\n    } else {\n        // Otherwise, we're dealing with v0 states. We'll just\n        // assume it was the same, I guess. Should be fine as we didn't change\n        // the permutation code in v0.\n    }\n\n    let permuter;\n    if (perm !== null) {\n        // Adding a permuter function for all per-gene vectors.\n        permuter = (x) => {\n            let temp = x.slice();\n            x.forEach((y, i) => {\n                temp[i] = x[perm[i]];\n            });\n            x.set(temp);\n            return;\n        };\n    } else {\n        permuter = (x) => {}; \n    }\n\n    return permuter;\n}\n\n/****************************\n ****** Custom exports ******\n ****************************/\n\nexport function fetchCountMatrix() {\n    return cache.matrix;\n}\n\nexport function fetchGenes() {\n    return cache.genes;\n}\n\nexport function fetchGeneTypes() {\n    if (!(\"gene_types\" in cache)) {\n        var gene_info_type = {};\n        var gene_info = fetchGenes();\n        for (const [key, val] of Object.entries(gene_info)) {\n            gene_info_type[key] = scran.guessFeatures(val);\n        }\n        cache.gene_types = gene_info_type;\n    }\n    return cache.gene_types;\n}\n\nexport function fetchAnnotations(col) {\n    let annots = cache.annotations;\n    let size = cache.matrix.numberOfColumns();\n\n    if (!(col in annots)) {\n        throw `column ${col} does not exist in col.tsv`;\n    }\n\n    if (utils.isObject(annots[col]) && \"type\" in annots[col]) {\n        return annots[col];\n    }\n\n    let uvals = {};\n    let uTypedAray = new Uint8Array(asize);\n    annots[col].map((x, i) => {\n        if (!(x in uvals)) {\n            uvals[x] = Object.keys(uvals).length;\n        }\n\n        uTypedAray[i] = uvals[x];\n    });\n\n    return {\n        \"index\": Object.keys(uvals),\n        \"factor\": uTypedAray\n    }\n}\n","/* Derived from scran.js's blacklists.js.R. */\n\nexport var mito = {};\nmito.ensembl = new Set([\"ENSMUSG00000064336\",\"ENSMUSG00000064337\",\"ENSMUSG00000064338\",\"ENSMUSG00000064339\",\"ENSMUSG00000064340\",\"ENSMUSG00000064341\",\"ENSMUSG00000064342\",\"ENSMUSG00000064343\",\"ENSMUSG00000064344\",\"ENSMUSG00000064345\",\"ENSMUSG00000064346\",\"ENSMUSG00000064347\",\"ENSMUSG00000064348\",\"ENSMUSG00000064349\",\"ENSMUSG00000064350\",\"ENSMUSG00000064351\",\"ENSMUSG00000064352\",\"ENSMUSG00000064353\",\"ENSMUSG00000064354\",\"ENSMUSG00000064355\",\"ENSMUSG00000064356\",\"ENSMUSG00000064357\",\"ENSMUSG00000064358\",\"ENSMUSG00000064359\",\"ENSMUSG00000064360\",\"ENSMUSG00000064361\",\"ENSMUSG00000064363\",\"ENSMUSG00000064364\",\"ENSMUSG00000064365\",\"ENSMUSG00000064366\",\"ENSMUSG00000064367\",\"ENSMUSG00000064368\",\"ENSMUSG00000064369\",\"ENSMUSG00000064370\",\"ENSMUSG00000064371\",\"ENSMUSG00000064372\",\"ENSMUSG00000065947\",\"ENSG00000198695\",\"ENSG00000198712\",\"ENSG00000198727\",\"ENSG00000198763\",\"ENSG00000198786\",\"ENSG00000198804\",\"ENSG00000198840\",\"ENSG00000198886\",\"ENSG00000198888\",\"ENSG00000198899\",\"ENSG00000198938\",\"ENSG00000209082\",\"ENSG00000210049\",\"ENSG00000210077\",\"ENSG00000210082\",\"ENSG00000210100\",\"ENSG00000210107\",\"ENSG00000210112\",\"ENSG00000210117\",\"ENSG00000210127\",\"ENSG00000210135\",\"ENSG00000210140\",\"ENSG00000210144\",\"ENSG00000210151\",\"ENSG00000210154\",\"ENSG00000210156\",\"ENSG00000210164\",\"ENSG00000210174\",\"ENSG00000210176\",\"ENSG00000210184\",\"ENSG00000210191\",\"ENSG00000210194\",\"ENSG00000210195\",\"ENSG00000210196\",\"ENSG00000211459\",\"ENSG00000212907\",\"ENSG00000228253\"]);\nmito.symbol = new Set([\"mt-Tf\",\"mt-Rnr1\",\"mt-Tv\",\"mt-Rnr2\",\"mt-Tl1\",\"mt-Nd1\",\"mt-Ti\",\"mt-Tq\",\"mt-Tm\",\"mt-Nd2\",\"mt-Tw\",\"mt-Ta\",\"mt-Tn\",\"mt-Tc\",\"mt-Ty\",\"mt-Co1\",\"mt-Ts1\",\"mt-Td\",\"mt-Co2\",\"mt-Tk\",\"mt-Atp8\",\"mt-Atp6\",\"mt-Co3\",\"mt-Tg\",\"mt-Nd3\",\"mt-Tr\",\"mt-Nd4\",\"mt-Th\",\"mt-Ts2\",\"mt-Tl2\",\"mt-Nd5\",\"mt-Nd6\",\"mt-Te\",\"mt-Cytb\",\"mt-Tt\",\"mt-Tp\",\"mt-Nd4l\",\"MT-ND6\",\"MT-CO2\",\"MT-CYB\",\"MT-ND2\",\"MT-ND5\",\"MT-CO1\",\"MT-ND3\",\"MT-ND4\",\"MT-ND1\",\"MT-ATP6\",\"MT-CO3\",\"MT-TL1\",\"MT-TF\",\"MT-TV\",\"MT-RNR2\",\"MT-TI\",\"MT-TQ\",\"MT-TM\",\"MT-TW\",\"MT-TA\",\"MT-TN\",\"MT-TC\",\"MT-TY\",\"MT-TS1\",\"MT-TD\",\"MT-TK\",\"MT-TG\",\"MT-TR\",\"MT-TH\",\"MT-TS2\",\"MT-TL2\",\"MT-TE\",\"MT-TT\",\"MT-TP\",\"MT-RNR1\",\"MT-ND4L\",\"MT-ATP8\"]);\n","import * as scran from \"scran.js\"; \nimport * as utils from \"./_utils.js\";\nimport * as inputs from \"./_inputs.js\";\nimport { mito } from \"./mito.js\";\n\nvar cache = {};\nvar parameters = {};\n\nexport var changed = false;\n\n/***************************\n ******** Compute **********\n ***************************/\n\nfunction computeMetrics(use_mito_default, mito_prefix) {\n    var mat = inputs.fetchCountMatrix();\n\n    // TODO: add more choices.\n    var nsubsets = 1;\n    var subsets = utils.allocateCachedArray(mat.numberOfRows() * nsubsets, \"Uint8Array\", cache, \"metrics_buffer\");\n    subsets.fill(0);\n\n    // Finding the prefix.\n    // TODO: use the guessed features to narrow the Ensembl/symbol search.\n    var gene_info = inputs.fetchGenes();\n    var sub_arr = subsets.array();\n    for (const [key, val] of Object.entries(gene_info)) {\n        if (use_mito_default) {\n            val.forEach((x, i) => {\n                if (mito.symbol.has(x) || mito.ensembl.has(x)) {\n                    sub_arr[i] = 1;\n                }\n            });\n        } else {\n            var lower_mito = mito_prefix.toLowerCase();\n            val.forEach((x, i) => {\n                if(x.toLowerCase().startsWith(lower_mito)) {\n                    sub_arr[i] = 1;\n                }\n            });\n        }\n    }\n\n    utils.freeCache(cache.metrics);\n    cache.metrics = scran.computePerCellQCMetrics(mat, subsets);\n    return;\n}\n\nfunction computeFilters(nmads) {\n    utils.freeCache(cache.filters);\n    cache.filters = scran.computePerCellQCFilters(cache.metrics, { numberOfMADs: nmads });\n    return;\n}\n\nfunction applyFilters() {\n    var mat = inputs.fetchCountMatrix();\n    var disc = fetchDiscards();\n    utils.freeCache(cache.matrix);\n    cache.matrix = scran.filterCells(mat, disc);\n    return;\n}\n\nexport function compute(use_mito_default, mito_prefix, nmads) {\n    let run_metrics = (inputs.changed || use_mito_default !== parameters.use_mito_default || mito_prefix !== parameters.mito_prefix);\n    let run_filters = (run_metrics || nmads !== parameters.nmads);\n    let run_apply = (run_filters);\n\n    // Checking whether each step needs content from the preceding steps.\n    // This is necessary when working with reloaded states and we want to rerun\n    // some later steps but still need to generate their prerequisites.\n    if (cache.filters instanceof QCFiltersMimic) {\n        if (run_apply) {\n            run_filters = true;\n        }\n    }\n    if (cache.metrics instanceof QCMetricsMimic) {\n        if (run_apply || run_filters) {\n            run_metrics = true;\n        }\n    }\n\n    // Running the steps.\n    if (run_metrics) {\n        computeMetrics(use_mito_default, mito_prefix);\n        parameters.use_mito_default = use_mito_default;\n        parameters.mito_prefix = mito_prefix;\n    }\n\n    if (run_filters) {\n        computeFilters(nmads);\n        parameters.nmads = nmads;\n    }\n\n    if (run_apply) {\n        applyFilters();\n        changed = true;\n    }\n\n    return;\n}\n\n/***************************\n ******** Results **********\n ***************************/\n\nfunction getData(copy = true) {\n    copy = utils.copyOrView(copy);\n    return {\n        sums: cache.metrics.sums({ copy: copy }),\n        detected: cache.metrics.detected({ copy: copy }),\n        proportion: cache.metrics.subsetProportions(0, { copy: copy })\n    };\n}\n\nfunction getThresholds(copy = true) {\n    copy = utils.copyOrView(copy);\n    return {\n        sums: cache.filters.thresholdsSums({ copy: copy }),\n        detected: cache.filters.thresholdsDetected({ copy: copy }),\n        proportion: cache.filters.thresholdsSubsetProportions(0, { copy: copy })\n    }\n}\n\nexport function results() {\n    var data = getData();\n    var thresholds = getThresholds();\n\n    var ranges = {};\n    for (const k of Object.keys(data)) {\n        var max = -Infinity, min = Infinity;\n        data[k].forEach(function (x) {\n            if (max < x) {\n                max = x;\n            }\n            if (min > x) {\n                min = x;\n            }\n        });\n        ranges[k] = [min, max];\n    }\n\n    let remaining = 0;\n    if (\"matrix\" in cache) {\n        remaining = cache.matrix.numberOfColumns();\n    } else {\n        fetchDiscards().array().forEach(x => {\n            if (x == 0) {\n                remaining++;\n            }\n        });\n    }\n\n    return { \n        \"data\": data, \n        \"ranges\": ranges,\n        \"thresholds\": thresholds,\n        \"retained\": remaining\n    };\n}\n\n/**********************************\n ******** Saving/loading **********\n **********************************/\n\nexport function serialize(handle) {\n    let ghandle = handle.createGroup(\"quality_control\");\n\n    {\n        let phandle = ghandle.createGroup(\"parameters\"); \n        phandle.writeDataSet(\"use_mito_default\", \"Uint8\", [], Number(parameters.use_mito_default));\n        phandle.writeDataSet(\"mito_prefix\", \"String\", [], parameters.mito_prefix);\n        phandle.writeDataSet(\"nmads\", \"Float64\", [], parameters.nmads);\n    }\n\n    {\n        let rhandle = ghandle.createGroup(\"results\"); \n\n        {\n            let mhandle = rhandle.createGroup(\"metrics\");\n            let data = getData(false);\n            mhandle.writeDataSet(\"sums\", \"Float64\", null, data.sums)\n            mhandle.writeDataSet(\"detected\", \"Int32\", null, data.detected);\n            mhandle.writeDataSet(\"proportion\", \"Float64\", null, data.proportion);\n        }\n\n        {\n            let thandle = rhandle.createGroup(\"thresholds\");\n            let thresholds = getThresholds(false);\n            for (const x of [ \"sums\", \"detected\", \"proportion\" ]) {\n                let current = thresholds[x];\n                thandle.writeDataSet(x, \"Float64\", null, current);\n            }\n        }\n\n        let disc = fetchDiscards();\n        rhandle.writeDataSet(\"discards\", \"Uint8\", null, disc);\n    }\n}\n\nclass QCMetricsMimic {\n    constructor(sums, detected, proportion) {\n        this.sums_ = sums;\n        this.detected_ = detected;\n        this.proportion_ = proportion;\n    }\n\n    sums({ copy }) {\n        return utils.mimicGetter(this.sums_, copy);\n    }\n\n    detected({ copy }) {\n        return utils.mimicGetter(this.detected_, copy);\n    }\n\n    subsetProportions(index, { copy }) {\n        if (index != 0) {\n            throw \"only 'index = 0' is supported for mimics\";\n        }\n        return utils.mimicGetter(this.proportion_, copy);\n    }\n\n    free() {}\n}\n\nclass QCFiltersMimic {\n    constructor(sums, detected, proportion, discards) {\n        this.sums_ = sums;\n        this.detected_ = detected;\n        this.proportion_ = proportion;\n        this.discards = scran.createUint8WasmArray(discards.length);\n        this.discards.set(discards);\n    }\n\n    thresholdsSums({ copy }) {\n        return utils.mimicGetter(this.sums_, copy);\n    }\n\n    thresholdsDetected({ copy }) {\n        return utils.mimicGetter(this.detected_, copy);\n    }\n\n    thresholdsSubsetProportions(index, { copy }) {\n        if (index != 0) {\n            throw \"only 'index = 0' is supported for mimics\";\n        }\n        return utils.mimicGetter(this.proportion_, copy);\n    }\n\n    discardOverall({ copy }) {\n        return utils.mimicGetter(this.discards, copy);\n    }\n\n    free() {\n        this.discards.free();\n    }\n}\n\nexport function unserialize(handle) {\n    let ghandle = handle.open(\"quality_control\");\n\n    {\n        let phandle = ghandle.open(\"parameters\"); \n        parameters = {\n            use_mito_default: phandle.open(\"use_mito_default\", { load: true }).values[0] > 0,\n            mito_prefix: phandle.open(\"mito_prefix\", { load: true }).values[0],\n            nmads: phandle.open(\"nmads\", { load: true }).values[0]\n        }\n    }\n\n    {\n        let rhandle = ghandle.open(\"results\");\n\n        let mhandle = rhandle.open(\"metrics\");\n        cache.metrics = new QCMetricsMimic(\n            mhandle.open(\"sums\", { load: true }).values,\n            mhandle.open(\"detected\", { load: true }).values,\n            mhandle.open(\"proportion\", { load: true }).values\n        );\n\n        let thandle = rhandle.open(\"thresholds\");\n        let thresholds_sums = thandle.open(\"sums\", { load: true }).values;\n        let thresholds_detected = thandle.open(\"detected\", { load: true }).values;\n        let thresholds_proportion = thandle.open(\"proportion\", { load: true }).values;\n\n        let discards = rhandle.open(\"discards\", { load: true }).values; \n        cache.filters = new QCFiltersMimic(\n            thresholds_sums, \n            thresholds_detected,\n            thresholds_proportion,\n            discards\n        );\n    }\n\n    return { ...parameters };\n}\n\n/***************************\n ******** Getters **********\n ***************************/\n\nexport function fetchSums({ unsafe = false } = {}) {\n    // Unsafe, because we're returning a raw view into the Wasm heap,\n    // which might be invalidated upon further allocations.\n    return cache.metrics.sums({ copy: !unsafe });\n}\n\nexport function fetchDiscards() {\n    return cache.filters.discardOverall({ copy: \"view\" });\n}\n\nexport function fetchFilteredMatrix() {\n    if (!(\"matrix\" in cache)) {\n        applyFilters();\n    }\n    return cache.matrix;\n}\n","import * as scran from \"scran.js\"; \nimport * as utils from \"./_utils.js\";\nimport * as qc from \"./_quality_control.js\";\n\nvar cache = {};\nvar parameters = {};\n\nexport var changed = false;\n\nfunction rawCompute() {\n    var mat = qc.fetchFilteredMatrix();\n    var buffer = utils.allocateCachedArray(mat.numberOfColumns(), \"Float64Array\", cache);\n\n    var discards = qc.fetchDiscards();\n    var sums = qc.fetchSums({ unsafe: true }); // Better not have any more allocations in between now and filling of size_factors!\n\n    // Reusing the totals computed earlier.\n    var size_factors = buffer.array();\n    var j = 0;\n    discards.array().forEach((x, i) => {\n        if (!x) {\n            size_factors[j] = sums[i];\n            j++;\n        }\n    });\n\n    if (j != mat.numberOfColumns()) {\n        throw \"normalization and filtering are not in sync\";\n    }\n\n    utils.freeCache(cache.matrix);\n    cache.matrix = scran.logNormCounts(mat, { sizeFactors: buffer });\n    return;\n}\n\nexport function compute() {\n    changed = false;\n    if (qc.changed) {\n        changed = true;\n    } \n\n    if (changed) {\n        rawCompute();\n    }\n    return;\n}\n\nexport function results() {\n    return {};\n}\n\nexport function serialize(handle) {\n    // Token effort.\n    let ghandle = handle.createGroup(\"normalization\");\n    ghandle.createGroup(\"parameters\"); \n    ghandle.createGroup(\"results\"); \n}\n\nexport function unserialize(path) {\n    // Nothing to do here.\n    return;\n}\n\nexport function fetchNormalizedMatrix() {\n    if (!(\"matrix\" in cache)) {\n        rawCompute();\n    }\n    return cache.matrix;\n}\n\nexport function fetchExpression(index) {\n    var mat = fetchNormalizedMatrix();\n    var buffer = utils.allocateCachedArray(mat.numberOfColumns(), \"Float64Array\", cache); // re-using the buffer.\n    mat.row(index, { buffer: buffer });\n    return buffer.slice();\n}\n","import * as scran from \"scran.js\"; \nimport * as utils from \"./_utils.js\";\nimport * as normalization from \"./_normalization.js\";\n  \nvar cache = {};\nvar parameters = {};\n\nexport var changed = false;\n\nexport function compute(span) {\n    changed = false;\n    \n    if (normalization.changed || span != parameters.span) {\n        utils.freeCache(cache.results);\n\n        let mat = normalization.fetchNormalizedMatrix();\n        cache.results = scran.modelGeneVar(mat, { span: span });\n\n        cache.sorted_residuals = cache.results.residuals().slice(); // a separate copy.\n        cache.sorted_residuals.sort();\n\n        parameters.span = span;\n        changed = true;\n    }\n\n    return;\n}\n\nfunction getResults(copy = true) {\n    copy = utils.copyOrView(copy);\n    return {\n        \"means\": cache.results.means({ copy: copy }),\n        \"vars\": cache.results.variances({ copy: copy }),\n        \"fitted\": cache.results.fitted({ copy: copy }),\n        \"resids\": cache.results.residuals({copy: copy })\n    };\n}\n\nexport function results() {\n    return getResults();\n}\n\nexport function serialize(handle) {\n    let ghandle = handle.createGroup(\"feature_selection\");\n\n    {\n        let phandle = ghandle.createGroup(\"parameters\"); \n        phandle.writeDataSet(\"span\", \"Float64\", [], parameters.span);\n    }\n\n    {\n        let res = getResults(false);\n        let rhandle = ghandle.createGroup(\"results\"); \n        for (const x of [ \"means\", \"vars\", \"fitted\", \"resids\" ]) {\n            rhandle.writeDataSet(x, \"Float64\", null, res[x]);\n        }\n    }\n}\n\nclass ModelGeneVarMimic {\n    constructor(means, vars, fitted, resids) {\n        this.means_ = means;\n        this.vars_ = vars;\n        this.fitted_ = fitted;\n        this.resids_ = resids;\n    }\n\n    means({copy}) {\n        return utils.mimicGetter(this.means_, copy);\n    }\n\n    variances({copy}) {\n        return utils.mimicGetter(this.vars_, copy);\n    }\n\n    fitted({copy}) {\n        return utils.mimicGetter(this.fitted_, copy);\n    }\n\n    residuals({copy}) {\n        return utils.mimicGetter(this.resids_, copy);\n    }\n\n    free() {}\n}\n\nexport function unserialize(handle, permuter) {\n    let ghandle = handle.open(\"feature_selection\");\n\n    {\n        let phandle = ghandle.open(\"parameters\");\n        parameters = {\n            span: phandle.open(\"span\", { load: true }).values[0]\n        };\n    }\n\n    {\n        let rhandle = ghandle.open(\"results\");\n        let reloaded = {};\n\n        // Possibly permuting it to match the new permutation order;\n        // see 'unserialize' in './_inputs.js'.\n        for (const key of [ \"means\", \"vars\", \"fitted\", \"resids\" ]) {\n            let value = rhandle.open(key, { load: true }).values;\n            permuter(value);\n            reloaded[key] = value;\n        }\n\n        cache.results = new ModelGeneVarMimic(reloaded.means, reloaded.vars, reloaded.fitted, reloaded.resids);\n    }\n\n    cache.sorted_residuals = cache.results.residuals({ copy: true });\n    cache.sorted_residuals.sort();\n\n    return { ...parameters };\n}\n\nexport function fetchSortedResiduals() {\n    return cache.sorted_residuals;\n}\n\nexport function fetchResiduals({ unsafe = false } = {}) {\n    return cache.results.residuals({ copy: !unsafe });\n}\n","import * as scran from \"scran.js\";\nimport * as utils from \"./_utils.js\";\nimport * as normalization from \"./_normalization.js\";\nimport * as variance from \"./_model_gene_var.js\";\nimport * as wa from \"wasmarrays.js\";\n\nvar cache = {};\nvar parameters = {};\n\nexport var changed = false;\n\nfunction fetchPCsAsWasmArray() {\n    return cache.pcs.principalComponents({ copy: \"view\" });\n}\n\nfunction chooseFeatures(num_hvgs) {\n    var sorted_resids = variance.fetchSortedResiduals();\n    var threshold_at = sorted_resids[sorted_resids.length - num_hvgs];\n    var sub = utils.allocateCachedArray(sorted_resids.length, \"Uint8Array\", cache, \"hvg_buffer\");\n    var unsorted_resids = variance.fetchResiduals({ unsafe: true });\n    sub.array().forEach((element, index, array) => {\n        array[index] = unsorted_resids[index] >= threshold_at;\n    });\n}\n\nexport function compute(num_hvgs, num_pcs) {\n    changed = false;\n    \n    if (variance.changed || num_hvgs !== parameters.num_hvgs) {\n        chooseFeatures(num_hvgs);\n        parameters.num_hvgs = num_hvgs;\n        changed = true;\n    }\n\n    if (changed || normalization.changed || num_pcs !== parameters.num_pcs) { \n        // Need to check this in case we never ran a chooseFeatures\n        // call, e.g., because we're running from a reloaded analysis\n        // where the user only changed the number of PCs.\n        if (!(\"hvg_buffer\" in cache)) {\n            chooseFeatures(parameters.num_hvgs);\n        }\n        let sub = cache.hvg_buffer;\n\n        var mat = normalization.fetchNormalizedMatrix();\n        utils.freeCache(cache.pcs);\n        cache.pcs = scran.runPCA(mat, { features: sub, numberOfPCs: num_pcs });\n\n        parameters.num_pcs = num_pcs;\n        changed = true;\n    }\n\n    return;\n}\n\nexport function results() {\n    var pca_output = cache.pcs;\n    var var_exp = pca_output.varianceExplained();\n    var total_var = pca_output.totalVariance();\n    var_exp.forEach((x, i) => {\n        var_exp[i] = x/total_var;\n    });\n    return { \"var_exp\": var_exp };\n}\n\nexport function serialize(handle) {\n    let ghandle = handle.createGroup(\"pca\");\n\n    {\n        let phandle = ghandle.createGroup(\"parameters\"); \n        phandle.writeDataSet(\"num_hvgs\", \"Int32\", [], parameters.num_hvgs);\n        phandle.writeDataSet(\"num_pcs\", \"Int32\", [], parameters.num_pcs);\n    }\n\n    {\n        let rhandle = ghandle.createGroup(\"results\");\n\n        let ve = results().var_exp;\n        rhandle.writeDataSet(\"var_exp\", \"Float64\", null, ve);\n\n        let pcs = fetchPCs();\n        rhandle.writeDataSet(\"pcs\", \"Float64\", [pcs.num_obs, pcs.num_pcs], pcs.pcs); // remember, it's transposed.\n    }\n}\n\nclass PCAMimic { \n    constructor(pcs, var_exp) {\n        this.var_exp = var_exp;\n        this.pcs = scran.createFloat64WasmArray(pcs.length);\n        this.pcs.set(pcs);\n    }\n\n    principalComponents({ copy }) {\n        return utils.mimicGetter(this.pcs, copy);\n    }\n\n    varianceExplained({ copy = true } = {}) {\n        return utils.mimicGetter(this.var_exp, copy);\n    }\n\n    totalVariance () {\n        return 1;\n    }\n\n    free() {\n        this.pcs.free();\n    }\n}\n\nexport function unserialize(handle) {\n    let ghandle = handle.open(\"pca\");\n\n    {\n        let phandle = ghandle.open(\"parameters\"); \n        parameters = { \n            num_hvgs: phandle.open(\"num_hvgs\", { load: true }).values[0],\n            num_pcs: phandle.open(\"num_pcs\", { load: true }).values[0]\n        };\n    }\n\n    {\n        let rhandle = ghandle.open(\"results\");\n        let var_exp = rhandle.open(\"var_exp\", { load: true }).values;\n        let pcs = rhandle.open(\"pcs\", { load: true }).values\n        cache.pcs = new PCAMimic(pcs, var_exp);\n    }\n\n    return { ...parameters };\n}\n\nexport function fetchPCs() {\n    var pcs = fetchPCsAsWasmArray();\n    return {\n        \"pcs\": pcs,\n        \"num_pcs\": parameters.num_pcs,\n        \"num_obs\": pcs.length / parameters.num_pcs\n    };\n}\n","import * as scran from \"scran.js\";\nimport * as utils from \"./_utils.js\";\nimport * as pca from \"./_pca.js\";\n\nvar cache = {};\nvar parameters = {};\n\nexport var changed = false;\n\nexport function rawCompute(approximate) {\n    var pcs = pca.fetchPCs();\n    cache.raw = scran.buildNeighborSearchIndex(pcs.pcs, { approximate: approximate, numberOfDims: pcs.num_pcs, numberOfCells: pcs.num_obs });\n    return;\n}\n\nexport function compute(approximate) {\n    changed = false;\n\n    if (pca.changed || approximate != parameters.approximate) {\n        rawCompute(approximate);\n        parameters.approximate = approximate;\n        changed = true;\n    }\n\n    return;\n}\n\nexport function results() {\n    return {};\n}\n\nexport function serialize(handle) {\n    let ghandle = handle.createGroup(\"neighbor_index\");\n\n    {\n        let phandle = ghandle.createGroup(\"parameters\");\n        phandle.writeDataSet(\"approximate\", \"Uint8\", [], Number(parameters.approximate));\n    }\n\n    ghandle.createGroup(\"results\");\n    return;\n}\n\nexport function unserialize(handle) {\n    let ghandle = handle.open(\"neighbor_index\");\n\n    {\n        let phandle = ghandle.open(\"parameters\");\n        parameters = {\n            approximate: phandle.open(\"approximate\", { load: true }).value > 0\n        };\n    }\n\n    return { ...parameters };\n}\n\nexport function fetchIndex() {\n    if (!(\"raw\" in cache)) {\n        rawCompute(parameters.approximate);\n    }\n    return cache.raw;\n}\n","import * as scran from \"scran.js\"; \nimport * as utils from \"./_utils.js\";\nimport * as index from \"./_neighbor_index.js\";\n\nvar cache = {};\nvar parameters = {};\n\nexport var changed = false;\n\nexport function valid() {\n    return (\"clusters\" in cache);\n}\n\nexport function fetchClustersAsWasmArray() {\n    if (!valid()) {\n        throw \"cannot fetch SNN clusters from an invalid state\";\n    } else {\n        return cache.clusters.membership({ copy: \"view\" });\n    }\n}\n\nexport function compute(run_me, k, scheme, resolution) {\n    changed = false;\n\n    let rerun_neighbors = (index.changed || k !== parameters.k);\n    let rerun_graph = (rerun_neighbors || scheme !== parameters.scheme);\n    let rerun_clusters = (rerun_graph || resolution !== parameters.resolution);\n    if (run_me && !valid()) {\n        rerun_clusters = true;\n    }\n\n    // Checking whether each step needs content from the preceding step(s).\n    // This is necessary when working with reloaded states and we want to rerun\n    // some later steps but still need to generate their prerequisites.\n    if (!(\"graph\" in cache)) {\n        if (rerun_clusters) {\n            rerun_graph = true;\n        }\n    }\n    if (!(\"neighbors\" in cache)) {\n        if (rerun_graph || rerun_clusters) {\n            rerun_neighbors = true;\n        }\n    }\n\n    if (rerun_neighbors) {\n        utils.freeCache(cache.neighbors);\n        if (run_me) {\n            cache.neighbors = scran.findNearestNeighbors(index.fetchIndex(), k);\n        } else {\n            delete cache.neighbors; // ensuring that this is re-run on future calls to compute() with run_me = true.\n        }\n        parameters.k = k;\n    }\n\n    if (rerun_graph) {\n        utils.freeCache(cache.graph);\n        if (run_me) {\n            cache.graph = scran.buildSNNGraph(cache.neighbors, { scheme: scheme });\n        } else {\n            delete cache.graph;\n        }\n        parameters.scheme = scheme;\n    }\n\n    if (rerun_clusters) {\n        utils.freeCache(cache.clusters);\n        if (run_me) {\n            cache.clusters = scran.clusterSNNGraph(cache.graph, { resolution: resolution });\n        } else {\n            delete cache.clusters;\n        }\n        parameters.resolution = resolution;\n        changed = true;\n    }\n\n    return;\n}\n\nexport function results() {\n    // Cluster IDs will be passed to main thread in \n    // choose_clustering, so no need to do it here.\n    return {};\n}\n\nexport function serialize(handle) {\n    let ghandle = handle.createGroup(\"snn_graph_cluster\");\n\n    {\n        let phandle = ghandle.createGroup(\"parameters\");\n        phandle.writeDataSet(\"k\", \"Int32\", [], parameters.k);\n        phandle.writeDataSet(\"scheme\", \"Scheme\", [], [\"rank\", \"number\", \"jaccard\"][parameters.scheme]); // TODO: scheme should just directly be the string.\n        phandle.writeDataSet(\"resolution\", \"Float64\", [], parameters.resolution);\n    }\n\n    {\n        let rhandle = ghandle.createGroup(\"results\");\n        if (valid()) {\n            let clusters = fetchClustersAsWasmArray();\n            rhandle.writeDataSet(\"clusters\", \"Int32\", null, clusters);\n        }\n    }\n\n    return;\n}\n\nclass SNNClusterMimic {\n    constructor(clusters) {\n        this.buffer = scran.createInt32WasmArray(clusters.length);\n        this.buffer.set(clusters);\n    }\n\n    membership({ copy }) {\n        return utils.mimicGetter(this.buffer, copy);\n    }\n\n    free() {\n        this.buffer.free();\n    }\n}\n\nexport function unserialize(handle) {\n    let ghandle = handle.open(\"snn_graph_cluster\");\n\n    {\n        let phandle = ghandle.open(\"parameters\");\n        parameters = {\n            k: phandle.open(\"k\", { load: true }).values[0],\n            scheme: phandle.open(\"scheme\", { load: true }).values[0],\n            resolution: phandle.open(\"resolution\", { load: true }).values[0]\n        };\n        parameters.scheme = { \"rank\": 0, \"number\": 1, \"jaccard\": 2 }[parameters.scheme];\n    }\n\n    {\n        let rhandle = ghandle.open(\"results\");\n        if (\"clusters\" in rhandle.children) {\n            let clusters = rhandle.open(\"clusters\", { load: true }).values;\n            cache.clusters = new SNNClusterMimic(clusters);\n        }\n    }\n\n    return { ...parameters };\n}\n","import * as scran from \"scran.js\"; \nimport * as utils from \"./_utils.js\";\nimport * as pca from \"./_pca.js\";\n\nvar cache = {};\nvar parameters = {};\n\nexport var changed = false;\n\nexport function valid() {\n    return (\"raw\" in cache);\n}\n\nexport function fetchClustersAsWasmArray() {\n    if (!valid()) {\n        throw \"cannot fetch k-means clusters from an invalid state\";\n    } else {\n        return cache.raw.clusters({ copy: \"view\" });\n    }\n}\n\nexport function compute(run_me, k) {\n    changed = false;\n\n    let run_k = (pca.changed || k != parameters.k);\n    if (run_me && !valid()) {\n        run_k = true;\n    }\n\n    if (run_k) {\n        utils.freeCache(cache.raw);\n        if (run_me) {\n            var pcs = pca.fetchPCs();\n            cache.raw = scran.clusterKmeans(pcs.pcs, k, { numberOfDims: pcs.num_pcs, numberOfCells: pcs.num_obs, initMethod: \"pca-part\" });\n        } else {\n            delete cache.raw; // ensure this step gets re-run later when run_me = true. \n        }\n        parameters.k = k;\n        changed = true;\n    }\n\n    return;\n}\n\nexport function results() {\n    // Cluster IDs will be passed to main thread in \n    // choose_clustering, so no need to do it here.\n    return {};\n}\n\nexport function serialize(handle) {\n    let ghandle = handle.createGroup(\"kmeans_cluster\");\n\n    {\n        let phandle = ghandle.createGroup(\"parameters\");\n        phandle.writeDataSet(\"k\", \"Int32\", [], parameters.k);\n    }\n\n    {\n        let rhandle = ghandle.createGroup(\"results\");\n        if (valid()) {\n            let clusters = fetchClustersAsWasmArray();\n            rhandle.writeDataSet(\"clusters\", \"Int32\", null, clusters);\n         }\n    }\n\n    return;\n}\n\nclass KmeansMimic {\n    constructor(clusters) {\n        this.buffer = scran.createInt32WasmArray(clusters.length);\n        this.buffer.set(clusters);\n    }\n\n    clusters({ copy }) {\n        return utils.mimicGetter(this.buffer, copy);\n    }\n\n    free() {\n        this.buffer.free();\n    }\n}\n\nexport function unserialize(handle) {\n    parameters = {\n        k: 10\n    };\n\n    // Protect against old analysis states that don't have kmeans_cluster.\n    if (\"kmeans_cluster\" in handle.children) {\n        let ghandle = handle.open(\"kmeans_cluster\");\n\n        {\n            let phandle = ghandle.open(\"parameters\");\n            parameters.k = phandle.open(\"k\", { load: true }).values[0];\n        }\n\n        {\n            let rhandle = ghandle.open(\"results\");\n            if (\"clusters\" in rhandle.children) {\n                let clusters = rhandle.open(\"clusters\", { load: true }).values;\n                cache.raw = new KmeansMimic(clusters);\n            }\n        }\n    }\n\n    return { ...parameters };\n}\n","import * as scran from \"scran.js\";\nimport * as utils from \"./_utils.js\";\nimport * as snn_cluster from \"./_snn_cluster.js\";\nimport * as kmeans_cluster from \"./_kmeans_cluster.js\";\n\nvar cache = {};\nvar parameters = {};\n\nexport var changed = false;\n\nexport function compute(method) {\n    changed = true;\n    \n    if (method == parameters.method) {\n        if (method == \"snn_graph\") {\n            if (!snn_cluster.changed) {\n                changed = false;\n            }\n        } else if (method == \"kmeans\") {\n            if (!kmeans_cluster.changed) {\n                changed = false;\n            }\n        }\n    }\n\n    parameters.method = method;\n    return;\n}\n\nexport function results() {\n    var clusters = fetchClustersAsWasmArray();\n    return { \"clusters\": clusters.slice() };\n}\n\nexport function serialize(handle) {\n    let ghandle = handle.createGroup(\"choose_clustering\");\n\n    {\n        let phandle = ghandle.createGroup(\"parameters\");\n        phandle.writeDataSet(\"method\", \"String\", [], parameters.method);\n    }\n\n    // No need to serialize the cluster IDs as this is done for each step.\n    ghandle.createGroup(\"results\");\n    return;\n}\n\nexport function unserialize(handle) {\n    let ghandle = handle.open(\"choose_clustering\");\n\n    {\n        let phandle = ghandle.open(\"parameters\");\n        parameters = {\n            method: phandle.open(\"method\", { load: true }).values[0]\n        };\n    }\n\n    return { ...parameters };\n}\n\nexport function fetchClustersAsWasmArray() {\n    if (parameters.method == \"snn_graph\") {\n        return snn_cluster.fetchClustersAsWasmArray();\n    } else if (parameters.method == \"kmeans\") {\n        return kmeans_cluster.fetchClustersAsWasmArray();\n    }\n}\n","import * as scran from \"scran.js\";\nimport * as index from \"./_neighbor_index.js\";\nimport * as utils from \"./_utils.js\";\n\nexport function computeNeighbors(k) {\n    var nn_index = index.fetchIndex();\n\n    var output = { \"num_obs\": nn_index.numberOfCells() };\n    var results = null, rbuf = null, ibuf = null, dbuf = null;\n    try {\n        results = scran.findNearestNeighbors(nn_index, k);\n\n        rbuf = scran.createInt32WasmArray(results.numberOfCells());\n        ibuf = scran.createInt32WasmArray(results.size());\n        dbuf = scran.createFloat64WasmArray(results.size());\n\n        results.serialize({ runs: rbuf, indices: ibuf, distances: dbuf });\n        output[\"size\"] = results.size();\n        output[\"runs\"] = rbuf.array().slice();\n        output[\"indices\"] = ibuf.array().slice();\n        output[\"distances\"] = dbuf.array().slice();\n\n    } finally {\n        if (results !== null) {\n            results.free();\n        }\n        if (rbuf !== null) {\n            rbuf.free();\n        }\n        if (ibuf !== null) {\n            ibuf.free();\n        }\n        if (dbuf !== null) {\n            dbuf.free();\n        }\n    }\n\n    return output;\n}\n\nexport function sendTask(worker, payload, cache, transferrable = []) {\n    var i = cache.counter;\n    var p = new Promise((resolve, reject) => {\n        cache.promises[i] = { \"resolve\": resolve, \"reject\": reject };\n    });\n    cache.counter++;\n    payload.id = i;\n    worker.postMessage(payload, transferrable);\n    return p;\n}\n\nexport function initializeWorker(worker, cache) {\n    worker.onmessage = function (msg) {\n        var type = msg.data.type;\n        if (type.endsWith(\"_iter\")) {\n            postMessage({\n                \"type\": type,\n                \"resp\": {\n                    \"x\": msg.data.x,\n                    \"y\": msg.data.y,\n                    \"iteration\": msg.data.iteration\n                },\n            }, [msg.data.x.buffer, msg.data.y.buffer]);\n            return;\n        }\n  \n        var id = msg.data.id;\n        var fun = cache.promises[id];\n        if (type == \"error\") {\n            fun.reject(msg.data.error);\n        } else {\n            fun.resolve(msg.data.data);\n        }\n        delete cache.promises[id];\n    };\n    return sendTask(worker, { \"cmd\": \"INIT\" }, cache);\n}\n\nexport function runWithNeighbors(worker, args, nn_out, cache) {\n    var run_msg = {\n        \"cmd\": \"RUN\",\n        \"params\": args \n    };\n\n    var transferrable = [];\n    if (nn_out !== null) {\n        run_msg.neighbors = nn_out;\n        utils.extractBuffers(nn_out, transferrable);\n    }\n\n    return sendTask(worker, run_msg, cache, transferrable);\n}\n","import * as scran from \"scran.js\";\nimport * as vizutils from \"./_utils_viz_parent.js\";\nimport * as index from \"./_neighbor_index.js\";\nimport * as utils from \"./_utils.js\";\n\nvar cache = { \"counter\": 0, \"promises\": {} };\nvar parameters = {};\nvar worker = null;\n\nexport function initialize() {\n    worker = new Worker(new URL(\"./tsne.worker.js\", import.meta.url), { type: \"module\" });\n    return vizutils.initializeWorker(worker, cache);\n}\n\nexport var changed = false;\n\nfunction core(perplexity, iterations, animate, reneighbor) {\n    var nn_out = null;\n    if (reneighbor) {\n        var k = scran.perplexityToNeighbors(perplexity);\n        nn_out = vizutils.computeNeighbors(k);\n    }\n\n    let args = {\n        \"perplexity\": perplexity,\n        \"iterations\": iterations,\n        \"animate\": animate\n    };\n\n    // This returns a promise but the message itself is sent synchronously,\n    // which is important to ensure that the t-SNE runs in its worker in\n    // parallel with other analysis steps. Do NOT put the runWithNeighbors\n    // call in a .then() as this may defer the message sending until \n    // the current thread is completely done processing.\n    cache.run = vizutils.runWithNeighbors(worker, args, nn_out, cache);\n    return;\n}\n\nexport function compute(perplexity, iterations, animate) {\n    let reneighbor = (index.changed || perplexity != parameters.perplexity || \"reloaded\" in cache);\n    changed = (reneighbor || iterations != parameters.iterations);\n\n    if (changed) {\n        core(perplexity, iterations, animate, reneighbor);\n\n        parameters.perplexity = perplexity;\n        parameters.iterations = iterations;\n        parameters.animate = animate;\n\n        delete cache.reloaded;\n    }\n\n    return;\n}\n\nasync function getResults(copy)  {\n    if (\"reloaded\" in cache) {\n        let output = {\n            x: cache.reloaded.x,\n            y: cache.reloaded.y\n        };\n        utils.copyVectors(output, copy);\n        output.iterations = parameters.iterations;\n        return output;\n    } else {\n        // Vectors that we get from the worker are inherently\n        // copied, so no need to do anything extra here.\n        await cache.run;\n        return vizutils.sendTask(worker, { \"cmd\": \"FETCH\" }, cache);\n    }\n}\n\nexport function results() {\n    return getResults(true);\n}\n\nexport async function serialize(handle) {\n    let ghandle = handle.createGroup(\"tsne\");\n\n    {\n        let phandle = ghandle.createGroup(\"parameters\");\n        phandle.writeDataSet(\"perplexity\", \"Float64\", [], parameters.perplexity);\n        phandle.writeDataSet(\"iterations\", \"Int32\", [], parameters.iterations);\n        phandle.writeDataSet(\"animate\", \"Uint8\", [], Number(parameters.animate));\n    }\n\n    {\n        let res = await getResults(false);\n        let rhandle = ghandle.createGroup(\"results\");\n        rhandle.writeDataSet(\"x\", \"Float64\", null, res.x);\n        rhandle.writeDataSet(\"y\", \"Float64\", null, res.y);\n    }\n\n    return;\n}\n\nexport function unserialize(handle) {\n    let ghandle = handle.open(\"tsne\");\n\n    {\n        let phandle = ghandle.open(\"parameters\");\n        parameters = {\n            perplexity: phandle.open(\"perplexity\", { load: true }).values[0],\n            iterations: phandle.open(\"iterations\", { load: true }).values[0],\n            animate: phandle.open(\"animate\", { load: true }).values[0] > 0\n        };\n    }\n\n    {\n        let rhandle = ghandle.open(\"results\");\n        cache.reloaded = {\n            x: rhandle.open(\"x\", { load: true }).values,\n            y: rhandle.open(\"y\", { load: true }).values\n        };\n    }\n\n    return { ...parameters };\n}\n\nexport function animate() {\n    if (\"reloaded\" in cache) {\n        // We need to reneighbor because we haven't sent the neighbors across yet.\n        core(parameters.perplexity, parameters.iterations, true, true);\n\n        // Mimicking the response from the re-run.\n        return cache.run\n            .then(contents => {\n                return {\n                    \"type\": \"tsne_rerun\",\n                    \"data\": { \"status\": \"SUCCESS\" }\n                };\n            });\n    } else {\n        return vizutils.sendTask(worker, { \"cmd\": \"RERUN\" }, cache);\n    }\n}\n","import * as scran from \"scran.js\";\nimport * as vizutils from \"./_utils_viz_parent.js\";\nimport * as index from \"./_neighbor_index.js\";\nimport * as utils from \"./_utils.js\";\n\nvar cache = { \"counter\": 0, \"promises\": {} };\nvar parameters = {};\nvar worker = null;\n\nexport function initialize() {\n    worker = new Worker(new URL(\"./umap.worker.js\", import.meta.url), { type: \"module\" });\n    cache.initialized = vizutils.initializeWorker(worker, cache);\n}\n\nexport var changed = false;\n\nfunction core(num_neighbors, num_epochs, min_dist, animate, reneighbor) {\n    var nn_out = null;\n    if (reneighbor) {\n        nn_out = vizutils.computeNeighbors(num_neighbors);\n    }\n\n    let args = {\n        \"num_neighbors\": num_neighbors,\n        \"num_epochs\": num_epochs,\n        \"min_dist\": min_dist,\n        \"animate\": animate\n    };\n\n    // This returns a promise but the message itself is sent synchronously,\n    // which is important to ensure that the UMAP runs in its worker in\n    // parallel with other analysis steps. Do NOT put the runWithNeighbors\n    // call in a .then() as this may defer the message sending until \n    // the current thread is completely done processing.\n    cache.run = vizutils.runWithNeighbors(worker, args, nn_out, cache);\n    return;\n}\n\nexport function compute(num_neighbors, num_epochs, min_dist, animate) {\n    let reneighbor = (index.changed || parameters.num_neighbors != num_neighbors || \"reloaded\" in cache);\n    changed = (reneighbor || num_epochs != parameters.num_epochs || min_dist != parameters.min_dist);\n\n    if (changed) {\n        core(num_neighbors, num_epochs, min_dist, animate, reneighbor);\n\n        parameters.num_neighbors = num_neighbors;\n        parameters.num_epochs = num_epochs;\n        parameters.min_dist = min_dist;\n        parameters.animate = animate;\n\n        delete cache.reloaded;\n    }\n\n    return;\n}\n\nasync function getResults(copy)  {\n    if (\"reloaded\" in cache) {\n        let output = {\n            x: cache.reloaded.x,\n            y: cache.reloaded.y\n        };\n        utils.copyVectors(output, copy);\n        output.iterations = parameters.num_epochs;\n        return output;\n    } else {\n        // Vectors that we get from the worker are inherently\n        // copied, so no need to do anything extra here.\n        await cache.run;\n        return vizutils.sendTask(worker, { \"cmd\": \"FETCH\" }, cache);\n    }\n}\n\nexport function results() {\n    return getResults(true);\n}\n\nexport async function serialize(handle) {\n    let ghandle = handle.createGroup(\"umap\");\n\n    {\n        let phandle = ghandle.createGroup(\"parameters\");\n        phandle.writeDataSet(\"num_neighbors\", \"Int32\", [], parameters.num_neighbors);\n        phandle.writeDataSet(\"num_epochs\", \"Int32\", [], parameters.num_epochs);\n        phandle.writeDataSet(\"min_dist\", \"Float64\", [], parameters.min_dist);\n        phandle.writeDataSet(\"animate\", \"Uint8\", [], Number(parameters.animate));\n    }\n\n    {\n        let res = await getResults(false);\n        let rhandle = ghandle.createGroup(\"results\");\n        rhandle.writeDataSet(\"x\", \"Float64\", null, res.x);\n        rhandle.writeDataSet(\"y\", \"Float64\", null, res.y);\n    }\n\n    return;\n}\n\nexport function unserialize(handle) {\n    let ghandle = handle.open(\"umap\");\n\n    {\n        let phandle = ghandle.open(\"parameters\");\n        parameters = {\n            num_neighbors: phandle.open(\"num_neighbors\", { load: true }).values[0],\n            num_epochs: phandle.open(\"num_epochs\", { load: true }).values[0],\n            min_dist: phandle.open(\"min_dist\", { load: true }).values[0],\n            animate: phandle.open(\"animate\", { load: true }).values[0] > 0\n        };\n    }\n\n    {\n        let rhandle = ghandle.open(\"results\");\n        cache.reloaded = {\n            x: rhandle.open(\"x\", { load: true }).values,\n            y: rhandle.open(\"y\", { load: true }).values\n        };\n    }\n\n    return { ...parameters };\n}\n\nexport function animate() {\n    if (\"reloaded\" in cache) {\n        // We need to reneighbor because we haven't sent the neighbors across yet.\n        core(parameters.num_neighbors, parameters.num_epochs, parameters.min_dist, true, true);\n  \n        // Mimicking the response from the re-run.\n        return cache.run\n            .then(contents => { \n                return {\n                    \"type\": \"umap_rerun\",\n                    \"data\": { \"status\": \"SUCCESS\" }\n                };\n            });\n    } else {\n        return vizutils.sendTask(worker, { \"cmd\": \"RERUN\" }, cache);\n    }\n}\n","import * as scran from \"scran.js\";\n\nexport const summaries2int = { \"min\": 0, \"mean\": 1, \"min_rank\": 4 };\nexport const int2summaries = { 0: \"min\", 1: \"mean\", 4: \"min_rank\" };\n\nexport function serializeGroupStats(handle, obj, group, { no_summaries = false } = {}) {\n    let ihandle = handle.createGroup(String(group));\n\n    for (const x of [ \"means\", \"detected\" ]) {\n        let y= obj[x](group, { copy: \"view\" });\n        ihandle.writeDataSet(x, \"Float64\", null, y);\n    }\n\n    for (const i of [ \"lfc\", \"delta_detected\", \"auc\", \"cohen\" ]) {\n        let i0 = i;\n        if (i == \"delta_detected\") {\n            i0 = \"deltaDetected\";\n        }\n\n        let extractor = (index) => obj[i0](group, { summary: index, copy: \"view\" });\n        if (no_summaries) {\n            let y = extractor(summaries2int[\"mean\"]);\n            ihandle.writeDataSet(i, \"Float64\", null, y);\n        } else {\n            let curhandle = ihandle.createGroup(i);\n            for (const [j, k] of Object.entries(summaries2int)) {\n                let y = extractor(k);\n                curhandle.writeDataSet(j, \"Float64\", null, y);\n            }\n        }\n    }\n}\n\nexport function unserializeGroupStats(handle, permuter, { no_summaries = false } = {}) {\n    let output = {};\n    for (const x of [ \"means\", \"detected\" ]) {\n        output[x] = handle.open(x, { load: true }).values;\n        permuter(output[x]);\n    }\n\n    for (const i of [ \"lfc\", \"delta_detected\", \"auc\", \"cohen\" ]) {\n        if (no_summaries) {\n            output[i] = handle.open(i, { load: true }).values;\n        } else {\n            let rhandle = handle.open(i);\n            let current = {};\n            for (const j of Object.keys(summaries2int)) {\n                current[j] = rhandle.open(j, { load: true }).values;\n                permuter(current[j]);\n            }\n            output[i] = current;\n        }\n    }\n\n    return output;\n}\n\n/*\n * Helper function to retrieve marker statistics for plotting.\n * This is used both for cluster-specific markers as well as the\n * DE genes that are computed for a custom selection vs the rest.\n */\nexport function fetchGroupResults(results, rank_type, group) {\n    if (!rank_type || rank_type === undefined) {\n        rank_type = \"cohen-min-rank\";\n    }\n\n    var ordering;\n    {\n        // Choosing the ranking statistic. Do NOT do any Wasm allocations\n        // until 'ranking' is fully consumed!\n        let ranking;\n        let increasing = false;\n      \n        let index = 1;\n        if (rank_type.match(/-min$/)) {\n            index = 0;\n        } else if (rank_type.match(/-min-rank$/)) {\n            increasing = true;\n            index = 4;\n        }\n\n        if (rank_type.match(/^cohen-/)) {\n            ranking = results.cohen(group, { summary: index, copy: false });\n        } else if (rank_type.match(/^auc-/)) {\n            ranking = results.auc(group, { summary: index, copy: false });\n        } else if (rank_type.match(/^lfc-/)) {\n            ranking = results.lfc(group, { summary: index, copy: false });\n        } else if (rank_type.match(/^delta-d-/)) {\n            ranking = results.deltaDetected(group, { summary: index, copy: false });\n        } else {\n            throw \"unknown rank type '\" + rank_type + \"'\";\n        }\n  \n        // Computing the ordering based on the ranking statistic.\n        ordering = new Int32Array(ranking.length);\n        for (var i = 0; i < ordering.length; i++) {\n            ordering[i] = i;\n        }\n        if (increasing) {\n            ordering.sort((f, s) => (ranking[f] - ranking[s]));\n        } else {\n            ordering.sort((f, s) => (ranking[s] - ranking[f]));\n        }\n    }\n  \n    // Apply that ordering to each statistic of interest.\n    var reorder = function(stats) {\n        var thing = new Float64Array(stats.length);\n        for (var i = 0; i < ordering.length; i++) {\n            thing[i] = stats[ordering[i]];\n        }\n        return thing;\n    };\n  \n    var stat_detected = reorder(results.detected(group, { copy: false }));\n    var stat_mean = reorder(results.means(group, { copy: false }));\n    var stat_lfc = reorder(results.lfc(group, { summary: 1, copy: false }));\n    var stat_delta_d = reorder(results.deltaDetected(group, { summary: 1, copy: false }));\n\n    return {\n        \"ordering\": ordering,\n        \"means\": stat_mean,\n        \"detected\": stat_detected,\n        \"lfc\": stat_lfc,\n        \"delta_detected\": stat_delta_d\n    };\n}\n\n","import * as scran from \"scran.js\"; \nimport * as utils from \"./_utils.js\";\nimport * as normalization from \"./_normalization.js\";\nimport * as choice from \"./_choose_clustering.js\";\nimport * as markers from \"./_utils_markers.js\";\n\nvar cache = {};\nvar parameters = {};\n\nexport var changed = false;\n\nexport function compute() {\n    changed = false;\n\n    if (normalization.changed || choice.changed) {\n        var mat = normalization.fetchNormalizedMatrix();\n        var clusters = choice.fetchClustersAsWasmArray();\n        \n        utils.freeCache(cache.raw);\n        cache.raw = scran.scoreMarkers(mat, clusters);\n\n        // No parameters to set.\n        changed = true;\n    }\n\n    return;\n}\n\nexport function results() {\n    return {};\n}\n\nexport function serialize(handle) {\n    let ghandle = handle.createGroup(\"marker_detection\");\n    ghandle.createGroup(\"parameters\");\n\n    {\n        let chandle = ghandle.createGroup(\"results\");\n        let rhandle = chandle.createGroup(\"clusters\");\n\n        var num = cache.raw.numberOfGroups();\n        for (var i = 0; i < num; i++) {\n            markers.serializeGroupStats(rhandle, cache.raw, i);\n        }\n    }\n}\n\nclass ScoreMarkersMimic {\n    constructor(clusters) {\n        this.clusters = clusters;\n    }\n\n    effect_grabber(key, group, summary, copy) {\n        let sidx = markers.int2summaries[summary];\n        let chosen = this.clusters[group][key][sidx];\n        return utils.mimicGetter(chosen, copy);\n    }\n\n    lfc(group, { summary, copy }) {\n        return this.effect_grabber(\"lfc\", group, summary, copy);\n    }\n\n    deltaDetected(group, { summary, copy }) {\n        return this.effect_grabber(\"delta_detected\", group, summary, copy);\n    }\n\n    cohen(group, { summary, copy }) {\n        return this.effect_grabber(\"cohen\", group, summary, copy);\n    }\n\n    auc(group, { summary, copy }) {\n        return this.effect_grabber(\"auc\", group, summary, copy);\n    }\n\n    stat_grabber(key, group, copy) {\n        let chosen = this.clusters[group][key];\n        return utils.mimicGetter(chosen, copy);\n    }\n\n    means(group, { copy }) {\n        return this.stat_grabber(\"means\", group, copy);\n    }\n\n    detected(group, { copy }) {\n        return this.stat_grabber(\"detected\", group, copy);\n    }\n\n    numberOfGroups() {\n        return Object.keys(this.clusters).length;\n    }\n\n    free() {}\n}\n\nexport function unserialize(handle, permuter) {\n    let ghandle = handle.open(\"marker_detection\");\n\n    // No parameters to unserialize.\n\n    {\n        let chandle = ghandle.open(\"results\");\n        let rhandle = chandle.open(\"clusters\");\n        let clusters = {};\n        for (const cl of Object.keys(rhandle.children)) {\n            clusters[Number(cl)] = markers.unserializeGroupStats(rhandle.open(cl), permuter);\n        }\n        cache.raw = new ScoreMarkersMimic(clusters);\n    }\n\n    return;\n}\n\nexport function fetchGroupResults(rank_type, group) {\n    return markers.fetchGroupResults(cache.raw, rank_type, group); \n}\n\nexport function numberOfGroups() {\n    return cache.raw.numberOfGroups();\n}\n\nexport function fetchGroupMeans(group, { copy = true }) {\n    return cache.raw.means(group, { copy: copy });\n}\n","var DownloadsDB;\nvar init = null;\n\nexport function initialize() {\n    if (init === null) {\n        init = new Promise((resolve, reject) => {\n            // initialize database on worker creation\n            DownloadsDB = indexedDB.open(\"DownloadsDB\", 3);\n\n            DownloadsDB.onupgradeneeded = (e) => {\n                var DownloadsDBClient = e.target.result;\n\n                // Currently purging all existing stores when the version is updated.\n                // At some point we may add a more sophisticated upgrade mechanism.\n                try {\n                    DownloadsDBClient.deleteObjectStore(\"downloads\");\n                } catch (e) {}\n\n                DownloadsDBClient.createObjectStore(\"downloads\", { keyPath: 'url' });\n            };\n\n            DownloadsDB.onsuccess = () => {\n                resolve(null);\n            };\n\n            DownloadsDB.onerror = () => {\n                reject(\"failed to initialize DownloadsDB\");\n            };\n        });\n    }\n\n    return init;\n}\n\nexport async function list() {\n    await init;\n    let trans = DownloadsDB.result.transaction([\"downloads\"], \"readonly\");\n    let download_store = trans.objectStore(\"downloads\");\n    return download_store.getAllKeys();\n}\n\nexport async function get(url, params = null, force = false) {\n    await init;\n\n    if (!force) {\n        let trans = DownloadsDB.result.transaction([\"downloads\"], \"readonly\");\n        let download_store = trans.objectStore(\"downloads\");\n        var data_check = new Promise(resolve => {\n            var already = download_store.get(url);\n            already.onsuccess = function (event) {\n                if (already.result !== undefined) {\n                    resolve(already.result.payload);\n                } else {\n                    resolve(null);\n                }\n            };\n            already.onerror = function (event) {\n                resolve(null);\n            };\n        });\n\n        var found = await data_check;\n        if (found !== null) {\n            return found;\n        }\n    }\n\n    var req;\n    if (params == null) {\n        req = fetch(url);\n    } else {\n        req = fetch(url, params);\n    }\n\n    var res = await req;\n    if (!res.ok) {\n        throw \"failed to download '\" + url + \"' (\" + res.status + \")\";\n    }\n    var buffer = await res.arrayBuffer();\n\n    // Technically, this isn't quite right, because we need to close the read\n    // transaction before opening the write transaction; multiple queries to\n    // the same URL from different workers could cause multiple downloads if\n    // they each miss each other's read check. But oh well; the auto-commit\n    // of IDB transactions means that it's hard to do any better. (Specifically,\n    // we can't do an async fetch while the transaction is still open, because\n    // it just closes before the fetch is done.)\n    let trans = DownloadsDB.result.transaction([\"downloads\"], \"readwrite\");\n    let download_store = trans.objectStore(\"downloads\");\n    var data_saving = new Promise(resolve => {\n        var putrequest = download_store.put({ \"url\": url, \"payload\": buffer });\n        putrequest.onsuccess = function (event) {\n            resolve(true);\n        };\n        putrequest.onerror = function (event) {\n            resolve(false);\n        };\n    });\n\n    let success = await data_saving;\n    if (!success) {\n        throw \"failed to download resources for '\" + url + \"'\";\n    }\n\n    return buffer;\n}\n\nexport async function remove(url) {\n    await init;\n    let trans = DownloadsDB.result.transaction([\"downloads\"], \"readwrite\")\n    let download_store = trans.objectStore(\"downloads\");\n\n    var removal = new Promise(resolve => {\n        let request = download_store.delete(url);\n        request.onsuccess = function (event) {\n            resolve(true);\n        };\n        request.onerror = function (event) {\n            resolve(false);\n        };\n    });\n\n    return await removal;\n}\n","import * as scran from \"scran.js\";\nimport * as utils from \"./_utils.js\";\nimport * as inputs from \"./_inputs.js\";\nimport * as markers from \"./_score_markers.js\";\nimport * as downloads from \"./DownloadsDBHandler.js\";\nimport * as pako from \"pako\";\n\nvar cache = {};\nvar parameters = {};\n\nexport var changed = false;\n\nvar hs_loaded = {};\nvar mm_loaded = {};\nvar hs_references = {};\nvar mm_references = {};\n\nconst proxy = \"https://cors-proxy.aaron-lun.workers.dev\";\nconst hs_base = \"https://github.com/clusterfork/singlepp-references/releases/download/hs-latest\";\nconst mm_base = \"https://github.com/clusterfork/singlepp-references/releases/download/mm-latest\";\n\n// Try to figure out the best feature identifiers to use,\n// based on the highest confidence annotation.\nfunction chooseFeatures() {\n    let genes = inputs.fetchGenes();\n    let types = inputs.fetchGeneTypes();\n\n    let best_feature = null;\n    let best = null;\n    for (const [key, val] of Object.entries(types)) {\n        if (best === null) {\n            best_feature = key;\n            best = val;\n        } else if (val.confidence > best.confidence) {\n            best_feature = key;\n            best = val;\n        }\n    }\n\n    cache.features = genes[best_feature];\n    cache.feature_details = best;\n    return;\n}\n\n// TODO: consolidate this with _inputs.readDSVFromBuffer to eliminate the D3 dependency.\nfunction quickLineReader(buffer, compression = \"gz\") {\n    let txt = buffer;\n    if (compression == \"gz\") {\n        txt = pako.ungzip(buffer);\n    }\n\n    const dec = new TextDecoder();\n    let decoded = dec.decode(txt);\n\n    let lines = decoded.split(\"\\n\");\n    if (lines.length > 0 && lines[lines.length - 1] == \"\") { // ignoring the trailing newline.\n        lines.pop();\n    }\n\n    return lines;    \n}\n\nasync function getBuiltReference(name, species, rebuild) {\n    let base;\n    let references;\n    let preloaded;\n    if (species == \"human\") {\n        base = hs_base;\n        preloaded = hs_loaded;\n        references = hs_references;\n    } else {\n        base = mm_base;\n        preloaded = mm_loaded;\n        references = mm_references;\n    }\n\n    downloads.initialize();\n\n    if (!(name in preloaded)) {\n        let buffers = await Promise.all([\n            downloads.get(proxy + \"/\" + encodeURIComponent(base + \"/\" + name + \"_genes.csv.gz\")),\n            downloads.get(proxy + \"/\" + encodeURIComponent(base + \"/\" + name + \"_labels_fine.csv.gz\")),\n            downloads.get(proxy + \"/\" + encodeURIComponent(base + \"/\" + name + \"_label_names_fine.csv.gz\")),\n            downloads.get(proxy + \"/\" + encodeURIComponent(base + \"/\" + name + \"_markers_fine.gmt.gz\")),\n            downloads.get(proxy + \"/\" + encodeURIComponent(base + \"/\" + name + \"_matrix.csv.gz\"))\n        ]);\n\n        let loaded;\n        try {\n            loaded = scran.loadLabelledReferenceFromBuffers(\n                new Uint8Array(buffers[4]), // rank matrix\n                new Uint8Array(buffers[3]), // markers\n                new Uint8Array(buffers[1])) // label per sample\n\n            let gene_lines = quickLineReader(new Uint8Array(buffers[0])); // gene names\n            let ensembl = [];\n            let symbol = [];\n            gene_lines.forEach(x => {\n                let fields = x.split(\",\");\n                ensembl.push(fields[0]);\n                symbol.push(fields[1]);\n            });\n\n            let labels = quickLineReader(new Uint8Array(buffers[2])); // full label names\n            preloaded[name] = { \n                \"raw\": loaded, \n                \"genes\": {\n                    \"ensembl\": ensembl,\n                    \"symbol\": symbol\n                },\n                \"labels\": labels\n            };\n\n        } catch (e) {\n            utils.freeCache(loaded);\n            throw e;\n        }\n    }\n\n\n    if (!(name in references) || rebuild) {\n        let built;\n        try {\n            if (name in references) {\n                utils.freeCache(references[name].raw);\n            }\n\n            let current = preloaded[name];\n            let loaded = current.raw;\n\n            let chosen_ids;\n            if (cache.feature_details.type === \"ensembl\") {\n                chosen_ids = current.genes.ensembl;\n            } else {\n                chosen_ids = current.genes.symbol;\n            }\n\n            let built = scran.buildLabelledReference(cache.features, loaded, chosen_ids); \n            references[name] = {\n                \"features\": chosen_ids,\n                \"raw\": built\n            };\n\n        } catch (e) {\n            utils.freeCache(built);\n            throw e;\n        }\n    }\n\n    return {\n        \"loaded\": preloaded[name],\n        \"built\": references[name]\n    };\n}\n\nfunction compareArrays(x, y) {\n    if (typeof x === \"undefined\" || typeof y === \"undefined\") {\n        return false;\n    }\n    if (x.length != y.length) {\n        return false;\n    }\n    for (var i = 0; i < x.length; i++) {\n        if (x[i] != y[i]) {\n            return false;\n        }\n    }\n    return true;\n}\n\nexport function compute(human_references, mouse_references) {\n    changed = false;\n\n    let rebuild = false;\n    if (inputs.changed || !(\"feature_space\" in cache)) {\n        rebuild = true;\n        changed = true;\n        chooseFeatures();\n    }\n    let species = cache.feature_details.species;\n        \n    // Fetching all of the references. This is effectively a no-op\n    // if rebuild = false, so we do it to fill up 'valid'.\n    let init = downloads.initialize();\n    let valid = {};\n    if (species == \"human\") {\n        for (const ref of human_references) {\n            valid[ref] = getBuiltReference(ref, \"human\", rebuild);\n        }\n    } else if (species == \"mouse\") {\n        for (const ref of mouse_references) {\n            valid[ref] = getBuiltReference(ref, \"mouse\", rebuild);\n        }\n    }\n\n    if (!compareArrays(human_references, parameters.human_references) || !compareArrays(mouse_references, parameters.mouse_references)) {\n        parameters.human_references = human_references;\n        parameters.mouse_references = mouse_references;\n        changed = true;\n    }\n\n    if (changed) {\n        // Creating a column-major array of mean vectors.\n        let ngenes = cache.features.length;\n        let ngroups = markers.numberOfGroups(); \n        let cluster_means = utils.allocateCachedArray(ngroups * ngenes, \"Float64Array\", cache);\n        for (var g = 0; g < ngroups; g++) {\n            let means = markers.fetchGroupMeans(g, { copy: false }); // Warning: direct view in wasm space - be careful.\n            let cluster_array = cluster_means.array();\n            cluster_array.set(means, g * ngenes);\n        }\n\n        // Running classifications on the cluster means. Note that compute() itself\n        // cannot be async, as we need to make sure 'changed' is set and available for\n        // downstream steps; hence the explicit then().\n        cache.results = {};\n        for (const [key, val] of Object.entries(valid)) {\n            cache.results[key] = val.then(ref => {\n                let output = scran.labelCells(cluster_means, ref.built.raw, { numberOfFeatures: ngenes, numberOfCells: ngroups });\n                let labels = [];\n                for (const o of output) {\n                    labels.push(ref.loaded.labels[o]);\n                }\n                return labels;\n            });\n        }\n\n        // Performing additional integration, if necessary. We don't really \n        // need this if there's only one reference.\n        let used_refs = Object.keys(valid);\n        if (used_refs.length > 1) {\n            if (rebuild || !compareArrays(used_refs, cache.used)) {\n                let used_vals = Object.values(valid);\n\n                cache.integrated = Promise.all(used_vals)\n                    .then(arr => {\n                        let loaded = arr.map(x => x.loaded.raw);\n                        let feats = arr.map(x => x.built.features);\n                        let built = arr.map(x => x.built.raw);\n                        return scran.integrateLabelledReferences(cache.features, loaded, feats, built);\n                    }\n                );\n            }\n\n            cache.integrated_results = cache.integrated\n                .then(async (integrated) => {\n                    let results = [];\n                    for (const key of used_refs) {\n                        results.push(await cache.results[key]);\n                    }\n\n                    let out = scran.integrateCellLabels(cluster_means, results, integrated, { numberOfFeatures: ngenes, numberOfCells: ngroups });\n                    let as_names = [];\n                    out.forEach(i => {\n                        as_names.push(used_refs[i]);\n                    });\n                    return as_names;\n                }\n            );\n        } else {\n            delete cache.integrated_results;\n        }\n\n        cache.used = used_refs;\n        changed = true;\n    }\n\n    return;\n}\n\nexport async function results() {\n    // No real need to clone these, they're string arrays\n    // so they can't be transferred anyway.\n    let perref = {};\n    for (const [key, val] of Object.entries(cache.results)) {\n        perref[key] = await val;\n    }\n\n    let output = { \"per_reference\": perref };\n    if (\"integrated_results\" in cache) {\n        output.integrated = await cache.integrated_results;\n    }\n\n    return output;\n}\n\nexport async function serialize(handle) {\n    let ghandle = handle.createGroup(\"cell_labelling\");\n    \n    {\n        let phandle = ghandle.createGroup(\"parameters\");\n        phandle.writeDataSet(\"mouse_references\", \"String\", null, parameters.mouse_references);\n        phandle.writeDataSet(\"human_references\", \"String\", null, parameters.human_references);\n    }\n\n    {\n        let rhandle = ghandle.createGroup(\"results\");\n        let res = await results();\n\n        let perhandle = rhandle.createGroup(\"per_reference\");\n        for (const [key, val] of Object.entries(res.per_reference)) {\n            perhandle.writeDataSet(key, \"String\", null, val);\n        }\n\n        if (\"integrated\" in res) {\n            rhandle.writeDataSet(\"integrated\", \"String\", null, res.integrated);\n        }\n    }\n\n    return;\n}\n\nexport function unserialize(handle) {\n    parameters =  {\n        mouse_references: [],\n        human_references: []\n    };\n    cache.results = {};\n\n    // Protect against old analysis states that don't have cell_labelling.\n    if (\"cell_labelling\" in handle.children) {\n        let ghandle = handle.open(\"cell_labelling\");\n        \n        {\n            let phandle = ghandle.open(\"parameters\");\n            parameters.mouse_references = phandle.open(\"mouse_references\", { load: true }).values;\n            parameters.human_references = phandle.open(\"human_references\", { load: true }).values;\n        }\n\n        {\n            let rhandle = ghandle.open(\"results\");\n            let perhandle = rhandle.open(\"per_reference\");\n            for (const key of Object.keys(perhandle.children)) {\n                cache.results[key] = perhandle.open(key, { load: true }).values;\n            }\n            if (\"integrated\" in rhandle.children) {\n                cache.integrated_results = rhandle.open(\"integrated\", { load: true }).values;\n            }\n        }\n    }\n\n    return { ...parameters };\n}\n","import * as scran from \"scran.js\";\nimport * as utils from \"./_utils.js\";\nimport * as qc from \"./_quality_control.js\";\nimport * as normalization from \"./_normalization.js\";\nimport * as markers from \"./_utils_markers.js\";\n\nvar cache = { \"results\": {} };\nvar parameters = { \"selections\": {} };\n\nexport var changed = false;\n\nexport function compute(args) {\n    /* If the QC filter was re-run, all of the selections are invalidated as\n     * the identity of the indices may have changed.\n     */\n    if (qc.changed) {\n        parameters.selections = {};\n        for (const [key, val] of Object.entries(cache.results)) {\n            utils.freeCache(val.raw);                    \n        }\n        cache.results = {};\n    }\n\n    /*\n     * Technically we would need to re-run detection on the existing selections\n     * if the normalization changed but the QC was the same. In practice, this\n     * never happens, so we'll deal with it later.\n     */\n    \n    changed = true;\n    return;\n}\n\nexport function results() {\n    return {};\n}\n\nexport function serialize(handle) {\n    let ghandle = handle.createGroup(\"custom_selections\");\n\n    {\n        let phandle = ghandle.createGroup(\"parameters\");\n        let rhandle = phandle.createGroup(\"selections\");\n        for (const [key, val] of Object.entries(parameters.selections)) {\n            rhandle.writeDataSet(String(key), \"Uint8\", null, val);\n        }\n    }\n\n    {\n        let chandle = ghandle.createGroup(\"results\");\n        let rhandle = chandle.createGroup(\"markers\");\n        for (const [key, val] of Object.entries(cache.results)) {\n            markers.serializeGroupStats(rhandle, val, 1, { no_summaries: true });\n        }\n    }\n}\n\nclass CustomMarkersMimic {\n    constructor(results) {\n        this.results = results;\n    }\n\n    effect_grabber(key, group, summary, copy) {\n        if (group != 1) {\n            throw \"only group 1 is supported for custom marker mimics\";\n        }\n        if (summary != 1) {\n            throw \"only the mean effect size is supported for custom marker mimics\";\n        }\n        let chosen = this.results[group][key];\n        return utils.mimicGetter(chosen, copy);\n    }\n\n    lfc(group, { summary, copy }) {\n        return effect_grabber(\"lfc\", group, summary, copy);\n    }\n\n    deltaDetected(group, { summary, copy }) {\n        return effect_grabber(\"delta_detected\", group, summary, copy);\n    }\n\n    cohen(group, { summary, copy }) {\n        return effect_grabber(\"cohen\", group, summary, copy);\n    }\n\n    auc(group, { summary, copy }) {\n        return effect_grabber(\"auc\", group, summary, copy);\n    }\n\n    stat_grabber(key, group, copy) {\n        let chosen = this.results[group][key];\n        return utils.mimicGetter(chosen, copy);\n    }\n\n    means(group, { copy }) {\n        return stat_grabber(\"means\", group, copy);\n    }\n\n    detected(group, { copy }) {\n        return stat_grabber(\"detected\", group, copy);\n    }\n\n    free() {}\n}\n\nexport function unserialize(handle, permuter) {\n    let ghandle = handle.open(\"custom_selections\");\n\n    {\n        let phandle = ghandle.open(\"parameters\");\n        let rhandle = phandle.open(\"selections\");\n        parameters = { selections: {} };\n        for (const key of Object.keys(rhandle.children)) {\n            parameters.selections[key] = rhandle.open(key, { load: true }).values;\n        }\n    }\n\n    {\n        let chandle = ghandle.open(\"results\");\n        let rhandle = chandle.open(\"markers\");\n        cache.results = {};\n        for (const sel of Object.keys(rhandle.children)) {\n            let current = markers.unserializeGroupStats(rhandle.open(sel), permuter, { no_summaries: true });\n            cache.results[sel] = new CustomMarkersMimic(current);\n        }\n    }\n\n    // Need to make a copy to avoid moving the buffers.\n    let output = { selections: {} };\n    for (const [k, v] of Object.entries(parameters.selections)) {\n        output.selections[k] = v.slice();        \n    }\n    return output;\n}\n\nexport function addSelection(id, selection) {\n    var mat = normalization.fetchNormalizedMatrix();\n\n    var buffer = utils.allocateCachedArray(mat.numberOfColumns(), \"Int32Array\", cache);\n    buffer.fill(0);\n    var tmp = buffer.array();\n    selection.forEach(element => { tmp[element] = 1; });\n\n    // Assumes that we have at least one cell in and outside the selection!\n    var res = scran.scoreMarkers(mat, buffer); \n  \n    // Removing previous results, if there were any.\n    if (id in cache.results) {\n        utils.freeCache(cache.results[id].raw);\n        delete cache.results[id];\n    }\n  \n    cache.results[id] = { \"raw\": res };\n    parameters.selections[id] = selection;\n}\n\nexport function removeSelection(id) {\n    utils.freeCache(cache.results[id].raw);\n    delete cache.results[id];\n    delete parameters.selections[id];\n    return;\n}\n\nexport function fetchResults(id, rank_type) {\n    var current = cache.results[id];\n    return markers.fetchGroupResults(current, rank_type, 1); \n}\n","var kanaDB;\nvar init = null;\n\nexport function initialize() {\n    init = new Promise(resolve => {\n        // initialize database on worker creation\n        kanaDB = indexedDB.open(\"KanaDB\", 2);\n\n        kanaDB.onupgradeneeded = (e) => {\n            var kanaDBClient = e.target.result;\n\n            // Currently purging all existing stores when the version is updated.\n            // At some point we may add a more sophisticated upgrade mechanism.\n            try {\n                kanaDBClient.deleteObjectStore(\"analysis\");\n            } catch (e) {}\n            try {\n                kanaDBClient.deleteObjectStore(\"analysis_meta\");\n            } catch (e) {}\n            try {\n                kanaDBClient.deleteObjectStore(\"file\");\n            } catch (e) {}\n            try {\n                kanaDBClient.deleteObjectStore(\"file_meta\");\n            } catch (e) {}\n\n            kanaDBClient.createObjectStore(\"analysis\", { keyPath: 'id' });\n            kanaDBClient.createObjectStore(\"analysis_meta\", { keyPath: 'id' });\n            kanaDBClient.createObjectStore(\"file\", { keyPath: 'id' });\n            kanaDBClient.createObjectStore(\"file_meta\", { keyPath: 'id' });\n        };\n\n        // Send existing stored analyses, if available.\n        kanaDB.onsuccess = () => {\n            getRecordsResolver(resolve);\n        };\n\n        kanaDB.onerror = () => {\n            resolve(null);\n        };\n    });\n\n    return init;\n}\n\nfunction getRecordsResolver(resolve, store = null) {\n    if (store === null) {\n        store = kanaDB.result\n            .transaction([\"analysis_meta\"], \"readonly\")\n            .objectStore(\"analysis_meta\")\n    }\n\n    var allAnalysis = store.getAll();\n\n    allAnalysis.onsuccess = function () {\n        let vals = allAnalysis.result;\n        vals.forEach(x => { delete x.files }); // no need to transfer that.\n        resolve(vals);\n    };\n    allAnalysis.onerror = function () {\n        resolve(null);\n    };\n}\n\n/** Helper functions **/\nasync function loadContent(id, store) {\n    return new Promise(resolve => {\n        let request = store.get(id);\n        request.onsuccess = function () {\n            if (request.result !== undefined) {\n                resolve(request.result);\n            } else {\n                resolve(null);\n            }\n        };\n        request.onerror = function () {\n            resolve(null);\n        };\n    });\n}\n\nfunction allOK(promises) {\n    return Promise.allSettled(promises)\n        .then(vals => {\n            for (const x of vals) {\n                if (!x) {\n                    return false;\n                }\n            }\n            return true;\n        });\n}\n\nexport async function getRecords() {\n    await init;\n    return new Promise(resolve => {\n        getRecordsResolver(resolve);\n    });\n}\n\n/** Functions to save content **/\nexport async function saveFile(id, buffer) {\n    await init;\n    let trans = kanaDB.result.transaction([\"file\", \"file_meta\"], \"readwrite\");\n    let file_store = trans.objectStore(\"file\");\n    let meta_store = trans.objectStore(\"file_meta\");\n\n    var meta = await loadContent(id, meta_store);\n    var refcount;\n    if (meta === null) {\n        refcount = 0;\n    } else {\n        refcount = meta[\"count\"];\n    }\n    refcount++;\n\n    var data_saving = new Promise(resolve => {\n        var putrequest = file_store.put({ \"id\": id, \"payload\": buffer });\n        putrequest.onsuccess = function (event) {\n            resolve(true);\n        };\n        putrequest.onerror = function (event) {\n            resolve(false);\n        };\n    });\n\n    var ref_saving = new Promise(resolve => {\n        meta.count = refcount;\n        var putrequest = meta_store.put(meta);\n        putrequest.onsuccess = function (event) {\n            resolve(true);\n        };\n        putrequest.onerror = function (event) {\n            resolve(false);\n        };\n    });\n\n    return allOK([data_saving, ref_saving])\n};\n\nexport async function saveAnalysis(id, state, files, title) { \n    await init;\n    let trans = kanaDB.result.transaction([\"analysis\", \"analysis_meta\"], \"readwrite\")\n    let analysis_store = trans.objectStore(\"analysis\");\n    let meta_store = trans.objectStore(\"analysis_meta\");\n\n    if (id == null) {\n        let already = await new Promise(resolve => getRecordsResolver(resolve, meta_store));\n        id = String(already.length);\n    }\n\n    var data_saving = new Promise(resolve => {\n        var putrequest = analysis_store.put({ \"id\": id, \"payload\": state });\n        putrequest.onsuccess = function (event) {\n            resolve(true);\n        };\n        putrequest.onerror = function (event) {\n            resolve(false);\n        };\n    });\n\n    var id_saving = new Promise(resolve => {\n        var putrequest = meta_store.put({ \"id\": id, \"files\": files, \"time\": Number(new Date()), \"title\": title });\n        putrequest.onsuccess = function (event) {\n            resolve(true);\n        };\n        putrequest.onerror = function (event) {\n            resolve(false);\n        };\n    });\n\n    if (await allOK([data_saving, id_saving])) {\n        return id;\n    } else {\n        return null;\n    }\n};\n\n/** Functions to load content **/\nexport async function loadFile(id) {\n    await init;\n    let file_store = kanaDB.result\n        .transaction([\"file\"], \"readonly\")\n        .objectStore(\"file\");\n\n    var meta = await loadContent(id, file_store);\n    return meta[\"payload\"];\n}\n\nexport async function loadAnalysis(id) {\n    await init;\n    let analysis_store = kanaDB.result\n        .transaction([\"analysis\"], \"readonly\")\n        .objectStore(\"analysis\");\n    var meta = await loadContent(id, analysis_store);\n    return meta[\"payload\"];\n}\n\n/** Functions to load content **/\nexport async function removeFile(id) {\n    await init;\n    let trans = kanaDB.result.transaction([\"file\", \"file_meta\"], \"readwrite\");\n    let file_store = trans.objectStore(\"file\");\n    let meta_store = trans.objectStore(\"file_meta\");\n\n    var meta = await loadContent(id, meta_store);\n    var refcount = meta[\"count\"];\n    refcount--;\n    var promises = [];\n\n    if (refcount == 0) {\n        promises.push(new Promise(resolve => {\n            let request = file_store.remove(id);\n            request.onerror = function (event) {\n                resolve(false);\n            };\n            request.onsuccess = function (event) {\n                resolve(true);\n            };\n        }));\n        promises.push(new Promise(resolve => {\n            let request = meta_store.delete(id);\n            request.onerror = function (event) {\n                resolve(false);\n            };\n            request.onsuccess = function (event) {\n                resolve(true);\n            };\n        }))\n    } else {\n        promises.push(new Promise(resolve => {\n            meta.count = refcount;\n            let request = meta_store.put(meta);\n            request.onsuccess = function (event) {\n                resolve(true);\n            };\n            request.onerror = function (event) {\n                resolve(false);\n            };\n        }));\n    }\n\n    return allOK(promises);\n}\n\nexport async function removeAnalysis(id) {\n    await init;\n    let trans = kanaDB.result.transaction([\"analysis\", \"analysis_meta\"], \"readwrite\")\n    let analysis_store = trans.objectStore(\"analysis\");\n    let meta_store = trans.objectStore(\"analysis_meta\");\n\n    var promises = [];\n\n    promises.push(new Promise(resolve => {\n        let request = analysis_store.delete(id);\n        request.onsuccess = function (event) {\n            resolve(true);\n        };\n        request.onerror = function (event) {\n            resolve(false);\n        };\n    }));\n\n    // Removing all files as well.\n    var meta = await loadContent(id, meta_store);\n    for (const f of meta[\"files\"]) {\n        promises.push(removeFile(f));\n    }\n\n    promises.push(new Promise(resolve => {\n        let request = meta_store.delete(id);\n        request.onsuccess = function (event) {\n            resolve(true);\n        };\n        request.onerror = function (event) {\n            resolve(false);\n        };\n    }));\n\n    return allOK(promises);\n}\n","import * as scran from \"scran.js\";\n\nfunction recoverTypedArrays(object) {\n    if (Array.isArray(object)) {\n        for (var i = 0; i < object.length; i++) {\n            object[i] = recoverTypedArrays(object[i]);\n        }\n    } else if (object instanceof Object) {\n        if (\"_TypedArray_class\" in object) {\n            var cls = object[[\"_TypedArray_class\"]];\n            var vals = object[[\"_TypedArray_values\"]];\n            switch (cls) {\n                case \"Uint8Array\":\n                    object = new Uint8Array(vals.length);\n                    break;\n                case \"Int8Array\":\n                    object = new Int8Array(vals.length);\n                    break;\n                case \"Uint8Array\":\n                    object = new Uint8Array(vals.length);\n                    break;\n                case \"Uint16Array\":\n                    object = new Uint16Array(vals.length);\n                    break;\n                case \"Int16Array\":\n                    object = new Int16Array(vals.length);\n                    break;\n                case \"Uint32Array\":\n                    object = new Uint32Array(vals.length);\n                    break;\n                case \"Int32Array\":\n                    object = new Int32Array(vals.length);\n                    break;\n                case \"Uint64Array\":\n                    object = new Uint64Array(vals.length);\n                    break;\n                case \"Int64Array\":\n                    object = new Int64Array(vals.length);\n                    break;\n                case \"Float32Array\":\n                    object = new Float32Array(vals.length);\n                    break;\n                case \"Float64Array\":\n                    object = new Float64Array(vals.length);\n                    break;\n                default:\n                    throw \"unrecognized TypedArray class '\" + cls;\n            }\n            object.set(vals);\n        } else {\n            for (const [key, element] of Object.entries(object)) {\n                object[key] = recoverTypedArrays(element);\n            }\n        }\n    } \n    return object;\n}\n\nexport function convertFromVersion0(state, newfile) {\n    let fhandle = scran.createNewHDF5File(newfile);\n\n    // Storing inputs.\n    {\n        let ghandle = fhandle.createGroup(\"inputs\");\n        let params = state.inputs.parameters;\n        let phandle = ghandle.createGroup(\"parameters\");\n        phandle.writeDataSet(\"format\", \"String\", [], params.type);\n\n        let fihandle = phandle.createGroup(\"files\")\n        for (const [index, info] of params.files.entries()) {\n            let xhandle = fihandle.createGroup(String(index));\n            xhandle.writeDataSet(\"type\", \"String\", [], info.type);\n            xhandle.writeDataSet(\"name\", \"String\", [], info.name);\n\n            if (info.buffer instanceof Object) { // i.e., embedded\n                xhandle.writeDataSet(\"offset\", \"Uint32\", [], info.buffer.offset);\n                xhandle.writeDataSet(\"size\", \"Uint32\", [], info.buffer.size);\n            } else { // i.e. KanaDB links.\n                xhandle.writeDataSet(\"id\", \"String\", [], info.buffer);\n            }\n        }\n\n        // Only storing the number of cells and genes. If we want the \n        // barcode annotations, we might as well just read from the source.\n        let chandle = ghandle.createGroup(\"results\");\n        let contents = state.inputs.contents;\n        let ngenes = Object.values(contents.genes)[0].length;\n        chandle.writeDataSet(\"dimensions\", \"Int32\", null, [ngenes, contents.num_cells]);\n\n        // Unfortunately the v0 didn't contain enough information to \n        // easily reproduce the permutations, so we just save the already-permuted genes here.\n        let gehandle = chandle.createGroup(\"genes\");\n        for (const [key, val] of Object.entries(contents.genes)) {\n            gehandle.writeDataSet(key, \"String\", null, val);\n        }\n    }\n\n    // Storing quality control. This consolidates elements from \n    // several steps in v0 for simplicity.\n    {\n        let ghandle = fhandle.createGroup(\"quality_control\");\n        let phandle = ghandle.createGroup(\"parameters\");\n\n        let mparams = state.quality_control_metrics.parameters;\n        phandle.writeDataSet(\"use_mito_default\", \"Uint8\", [], Number(mparams.use_mito_default));\n        phandle.writeDataSet(\"mito_prefix\", \"String\", [], mparams.mito_prefix);\n\n        let tparams = state.quality_control_thresholds.parameters;\n        phandle.writeDataSet(\"nmads\", \"Float64\", [], tparams.nmads);\n\n        // Saving all the contents.\n        let chandle = ghandle.createGroup(\"results\");\n\n        let mhandle = chandle.createGroup(\"metrics\");\n        let mcontents = recoverTypedArrays(state.quality_control_metrics.contents);\n        mhandle.writeDataSet(\"sums\", \"Float64\", null, mcontents.sums);\n        mhandle.writeDataSet(\"detected\", \"Int32\", null, mcontents.detected);\n        mhandle.writeDataSet(\"proportion\", \"Float64\", null, mcontents.proportion);\n\n        // Converting the thresholds into arrays to handle multi-batch analyses.\n        let thandle = chandle.createGroup(\"thresholds\");\n        let tcontents = recoverTypedArrays(state.quality_control_thresholds.contents);\n        for (const x of [ \"sums\", \"detected\", \"proportion\" ]) {\n            thandle.writeDataSet(x, \"Float64\", null, [tcontents[x]]);\n        }\n\n        let disc = tcontents.discards;\n        chandle.writeDataSet(\"discards\", \"Uint8\", null, disc);\n\n        // Don't bother saving 'retained', we'll get that from 'discards'.\n    }\n\n    // Normalization just needs a group but it doesn't actually have any information right now.\n    {\n        let ghandle = fhandle.createGroup(\"normalization\");\n        ghandle.createGroup(\"parameters\");\n        ghandle.createGroup(\"results\");\n    }\n\n    // Feature selection.\n    {\n        let ghandle = fhandle.createGroup(\"feature_selection\");\n\n        let phandle = ghandle.createGroup(\"parameters\");\n        phandle.writeDataSet(\"span\", \"Float64\", [], state.feature_selection.parameters.span);\n\n        let chandle = ghandle.createGroup(\"results\");\n        let contents = recoverTypedArrays(state.feature_selection.contents);\n        for (const x of [ \"means\", \"vars\", \"fitted\", \"resids\" ]) {\n            chandle.writeDataSet(x, \"Float64\", null, contents[x]);\n        }\n    }\n\n    // PCA.\n    {\n        let ghandle = fhandle.createGroup(\"pca\");\n\n        let phandle = ghandle.createGroup(\"parameters\");\n        let params = state.pca.parameters;\n        for (const x of [ \"num_hvgs\", \"num_pcs\" ]) {\n            phandle.writeDataSet(x, \"Int32\", null, params[x]);\n        }\n\n        let chandle = ghandle.createGroup(\"results\");\n        let contents = recoverTypedArrays(state.pca.contents);\n\n        let ve = contents.var_exp;\n        chandle.writeDataSet(\"var_exp\", \"Float64\", null, ve);\n\n        // Save as a matrix.\n        let npcs = ve.length;\n        let ncells = contents.pcs.length / npcs;\n        chandle.writeDataSet(\"pcs\", \"Float64\", [ncells, npcs], contents.pcs); // transposed in HDF5.\n    }\n\n    // Neighbor index.\n    {\n        let ghandle = fhandle.createGroup(\"neighbor_index\");\n        let phandle = ghandle.createGroup(\"parameters\");\n        let params = state.pca.parameters;\n        phandle.writeDataSet(\"approximate\", \"Uint8\", [], Number(params.approximate));\n\n        ghandle.createGroup(\"results\");\n    }\n\n    // t-SNE details.\n    {\n        let ghandle = fhandle.createGroup(\"tsne\");\n\n        let phandle = ghandle.createGroup(\"parameters\");\n        let params = state.tsne.parameters;\n        phandle.writeDataSet(\"perplexity\", \"Float64\", [], params.perplexity);\n        phandle.writeDataSet(\"iterations\", \"Int32\", [], params.iterations);\n        phandle.writeDataSet(\"animate\", \"Uint8\", [], params.animate);\n\n        let chandle = ghandle.createGroup(\"results\");\n        let contents = recoverTypedArrays(state.tsne.contents);\n        chandle.writeDataSet(\"x\", \"Float64\", null, contents.x);\n        chandle.writeDataSet(\"y\", \"Float64\", null, contents.y);\n\n        // Don't bother saving the number of iterations.\n    }\n\n    // UMAP details.\n    {\n        let ghandle = fhandle.createGroup(\"umap\");\n\n        let phandle = ghandle.createGroup(\"parameters\");\n        let params = state.umap.parameters;\n        phandle.writeDataSet(\"num_neighbors\", \"Int32\", [], params.num_neighbors);\n        phandle.writeDataSet(\"num_epochs\", \"Int32\", [], params.num_epochs);\n        phandle.writeDataSet(\"min_dist\", \"Float64\", [], params.min_dist);\n        phandle.writeDataSet(\"animate\", \"Uint8\", [], Number(params.animate));\n\n        let chandle = ghandle.createGroup(\"results\");\n        let contents = recoverTypedArrays(state.umap.contents);\n        chandle.writeDataSet(\"x\", \"Float64\", null, contents.x);\n        chandle.writeDataSet(\"y\", \"Float64\", null, contents.y);\n\n        // Don't bother saving the number of iterations.\n    }\n\n    // K-means.\n    {\n        let ghandle = fhandle.createGroup(\"kmeans_cluster\");\n        let phandle = ghandle.createGroup(\"parameters\");\n\n        let dhandle = phandle.createDataSet(\"k\", \"Int32\", []);\n        if (\"kmeans_cluster\" in state) {\n            let params = state.kmeans_cluster.parameters;\n            dhandle.write(params.k);\n        } else {\n            dhandle.write(10);\n        }\n\n        let chandle = ghandle.createGroup(\"results\");\n        let contents = recoverTypedArrays(state.kmeans_cluster.contents);\n        if (\"kmeans_cluster\" in state) {\n            chandle.writeDataSet(\"clusters\", \"Int32\", null, contents.clusters);\n        }\n    }\n\n    // SNN graph clustering. This consolidates details from several steps in v0.\n    {\n        let ghandle = fhandle.createGroup(\"snn_graph_cluster\");\n\n        let phandle = ghandle.createGroup(\"parameters\");\n        let find_params = state.snn_find_neighbors.parameters;\n        phandle.writeDataSet(\"k\", \"Int32\", [], find_params.k);\n\n        let build_params = state.snn_build_graph.parameters;\n        phandle.writeDataSet(\"scheme\", \"String\", [], [\"rank\", \"number\", \"jaccard\"][build_params.scheme]);\n\n        let cluster_params = state.snn_cluster_graph.parameters;\n        phandle.writeDataSet(\"resolution\", \"Float64\", [], cluster_params.resolution);\n\n        let chandle = ghandle.createGroup(\"results\");\n        let contents = recoverTypedArrays(state.snn_cluster_graph.contents);\n        chandle.writeDataSet(\"clusters\", \"Int32\", null, contents.clusters);\n    }\n\n    // Choose clustering.\n    {\n        let ghandle = fhandle.createGroup(\"choose_clustering\");\n        let phandle = ghandle.createGroup(\"parameters\");\n        phandle.writeDataSet(\"method\", \"String\", [], state.choose_clustering.parameters.method);\n    }\n\n    // Marker detection.\n    {\n        let ghandle = fhandle.createGroup(\"marker_detection\");\n        ghandle.createGroup(\"parameters\");\n\n        let chandle = ghandle.createGroup(\"results\");\n        let rhandle = chandle.createGroup(\"clusters\");\n        let results = state.marker_detection.contents;\n        for (const [index, val] of results.entries()) {\n            let ihandle = rhandle.createGroup(String(index));\n            let current = recoverTypedArrays(val);\n\n            for (const x of [ \"means\", \"detected\" ]) {\n                ihandle.writeDataSet(x, \"Float64\", null, current[x]);\n            }\n\n            for (const i of [ \"lfc\", \"delta_detected\", \"auc\", \"cohen\" ]) {\n                let rankings = current[i];\n                let rhandle = ihandle.createGroup(i);\n\n                for (const j of [ \"min\", \"mean\", \"min-rank\" ]) {\n                    let name = (j == \"min-rank\" ? \"min_rank\" : j);\n                    rhandle.writeDataSet(name, \"Float64\", null, rankings[j]);\n                }\n            }\n        }\n    }\n\n    // Custom markers.\n    {\n        let ghandle = fhandle.createGroup(\"custom_selections\");\n\n        let phandle = ghandle.createGroup(\"parameters\");\n        let shandle = phandle.createGroup(\"selections\");\n        let params = state.custom_marker_management.parameters;\n        for (const [key, val] of Object.entries(params.selections)) {\n            shandle.writeDataSet(String(key), \"Int32\", null, val);\n        }\n\n        let chandle = ghandle.createGroup(\"results\");\n        let rhandle = chandle.createGroup(\"markers\");\n        for (const [key, val] of Object.entries(state.custom_marker_management.contents.results)) {\n            let ihandle = rhandle.createGroup(String(key));\n            let current = recoverTypedArrays(val);\n\n            for (const x of [ \"means\", \"detected\" ]) {\n                ihandle.writeDataSet(x, \"Float64\", null, current[x]);\n            }\n\n            for (const i of [ \"lfc\", \"delta_detected\", \"auc\", \"cohen\" ]) {\n                ihandle.writeDataSet(i, \"Float64\", null, current[i][\"mean\"]);\n            }\n        }\n    }\n\n}\n","import * as hashwasm from \"hash-wasm\";\nimport * as kana_db from \"./KanaDBHandler.js\";\nimport * as from_v0 from \"./legacy/from_v0.js\";\nimport * as scran from \"scran.js\";\nimport * as pako from \"pako\";\n\n// Must be integers!\nconst FORMAT_EMBEDDED_FILES = 0;\nconst FORMAT_EXTERNAL_KANADB = 1;\nconst FORMAT_VERSION = 1000000;\n\nfunction numberToBuffer(number) {\n    // Store as little-endian. Probably safer\n    // than trying to cast it from a Uint64Array;\n    // not sure that endianness is strictly defined.\n    var output = new Uint8Array(8);\n\n    var i = 0;\n    while (number > 0) {\n        output[i] = number % 256;\n        number = Math.floor(number / 256);\n        i++;\n    }\n\n    return output;\n}\n\nfunction bufferToNumber(buffer) {\n    var output = 0;\n    var multiplier = 1;\n    for (const x of buffer) {\n        output += multiplier * x;\n        multiplier *= 256;\n    }\n    return output;\n}\n\nexport function createSaver(embedded) {\n    let output = {\n        collected: []\n    };\n\n    if (embedded) {\n        output.sofar = 0;\n        output.saver = (obj) => {\n            output.collected.push(obj.buffer);\n            let current = output.sofar;\n            let size = obj.buffer.byteLength;\n            output.sofar += size;\n            return {\n                \"offset\": current,\n                \"size\": size\n            };\n        };\n    } else {\n        output.saver = async (obj) => {\n            var md5 = await hashwasm.md5(new Uint8Array(obj.buffer));\n            var id = obj.type + \"_\" + obj.name + \"_\" + obj.buffer.byteLength + \"_\" + md5;\n            var ok = await kana_db.saveFile(id, obj.buffer);\n            if (!ok) {\n                throw \"failed to save file '\" + id + \"' to KanaDB\";\n            }\n            output.collected.push(id);\n            return id;\n        };\n    }\n\n    return output;\n}\n\nfunction save_internal(format_type, state, extras) {\n    var combined = new ArrayBuffer(24 + state.length + extras);\n    var combined_arr = new Uint8Array(combined);\n    var offset = 0;\n\n    let format = numberToBuffer(format_type);\n    combined_arr.set(format, offset); \n    offset += format.length;\n\n    let version = numberToBuffer(FORMAT_VERSION);\n    combined_arr.set(version, offset); \n    offset += version.length;\n\n    let state_len = numberToBuffer(state.length);\n    combined_arr.set(state_len, offset); \n    offset += state_len.length;\n\n    if (offset != 24) {\n        throw \"oops - accounting error in the serialization code!\";\n    }\n\n    combined_arr.set(state, offset);\n    offset += state.length;\n\n    return {\n        \"offset\": offset,\n        \"combined\": combined                \n    }\n}\n\nexport function saveEmbedded(state, collected) {\n    let total_len = 0;\n    for (const buf of collected) {\n        total_len += buf.byteLength;\n    }\n\n    let saved = save_internal(FORMAT_EMBEDDED_FILES, state, total_len);\n    let offset = saved.offset;\n    let combined_arr = new Uint8Array(saved.combined);\n\n    for (const buf of collected) {\n        const tmp = new Uint8Array(buf);\n        combined_arr.set(tmp, offset);\n        offset += tmp.length;\n    }\n\n    return saved.combined;\n}\n\nexport async function saveLinked(state, collected, title) {\n    let saved = save_internal(FORMAT_EXTERNAL_KANADB, state, 0);\n    let id = await kana_db.saveAnalysis(null, saved.combined, collected, title);\n    return id;\n}\n\nexport async function load(buffer, state_path) {\n    var offset = 0;\n    var format = bufferToNumber(new Uint8Array(buffer, offset, 8));\n    offset += 8;\n\n    var version = bufferToNumber(new Uint8Array(buffer, offset, 8));\n    offset += 8;\n\n    var state_len = bufferToNumber(new Uint8Array(buffer, offset, 8));\n    offset += 8;\n\n    let state = new Uint8Array(buffer, offset, state_len);\n    offset += state_len;\n    if (version < 1000000) {\n        let contents = pako.ungzip(state, { \"to\": \"string\" });\n        let values = JSON.parse(contents);\n        from_v0.convertFromVersion0(values, state_path);\n    } else {\n        scran.writeFile(state_path, state);\n    }\n\n    let bundle = {};\n    if (format == FORMAT_EMBEDDED_FILES) {\n        bundle.remaining = new Uint8Array(buffer, offset, buffer.byteLength - offset);\n        bundle.loader = (start, size) => bundle.remaining.slice(start, start + size);\n        bundle.embedded = true;\n    } else if (format == FORMAT_EXTERNAL_KANADB) {\n        bundle.loader = kana_db.loadFile;\n        bundle.embedded = false;\n    } else {\n        throw \"unsupported format type\";\n    }\n\n    return bundle;\n}\n","import * as scran from \"scran.js\";\nimport * as inputs from \"./_inputs.js\";\nimport * as qc from \"./_quality_control.js\";\nimport * as normalization from \"./_normalization.js\";\nimport * as variance from \"./_model_gene_var.js\";\nimport * as pca from \"./_pca.js\";\nimport * as index from \"./_neighbor_index.js\";\nimport * as cluster_choice from \"./_choose_clustering.js\";\nimport * as kmeans_cluster from \"./_kmeans_cluster.js\";\nimport * as snn_cluster from \"./_snn_cluster.js\";\nimport * as tsne from \"./_tsne_monitor.js\";\nimport * as umap from \"./_umap_monitor.js\";\nimport * as cluster_markers from \"./_score_markers.js\";\nimport * as label_cells from \"./_label_cells.js\";\nimport * as custom_markers from \"./_custom_markers.js\";\nimport * as kana_db from \"./KanaDBHandler.js\";\nimport * as utils from \"./_utils.js\";\nimport * as serialize_utils from \"./_utils_serialize.js\";\n\n/***************************************/\n\nfunction postSuccess_(info, step, message) {\n    var transferable = [];\n    utils.extractBuffers(info, transferable);\n    postMessage({\n        type: `${step}_DATA`,\n        resp: info,\n        msg: \"Success: \" + message\n    }, transferable);\n}\n\n/***************************************/\n\nconst step_inputs = \"inputs\";\nconst step_qc = \"quality_control\";\nconst step_norm = \"normalizaton\";\nconst step_feat = \"feature_selecton\";\nconst step_pca = \"pca\";\nconst step_neighbors = \"neighbor_index\";\nconst step_tsne = \"tsne\";\nconst step_umap = \"umap\";\nconst step_kmeans = \"kmeans_cluster\";\nconst step_snn = \"snn_cluster_graph\";\nconst step_choice = \"choose_clustering\";\nconst step_markers = \"marker_detection\";\nconst step_labels = \"cell_labelling\";\nconst step_custom = \"custom_marker_management\";\n\nfunction runAllSteps(state) {\n    var postSuccess = function (namespace, step, message) {\n        if (namespace.changed) {\n            postSuccess_(namespace.results(), step, message);\n        }\n    }\n\n    var postSuccessAsync = function (namespace, step, message) {\n        if (namespace.changed) {\n            namespace.results()\n                .then(res => {\n                    postSuccess_(res, step, message);\n                });\n        }\n    }\n\n    inputs.compute(state.files.format, state.files.files);\n    postSuccess(inputs, step_inputs, \"Count matrix loaded\");\n\n    qc.compute(\n        state.params.qc[\"qc-usemitodefault\"], \n        state.params.qc[\"qc-mito\"], \n        state.params.qc[\"qc-nmads\"]\n    );\n    postSuccess(qc, step_qc, \"Applying quality control filters\");\n \n    normalization.compute();\n    postSuccess(normalization, step_norm, \"Log-normalization completed\");\n\n    variance.compute(state.params.fSelection[\"fsel-span\"]);\n    postSuccess(variance, step_feat, \"Variance modelling completed\");\n\n    pca.compute(\n        state.params.pca[\"pca-hvg\"], \n        state.params.pca[\"pca-npc\"]\n    );\n    postSuccess(pca, step_pca, \"Principal components analysis completed\");\n\n    index.compute(state.params.cluster[\"clus-approx\"]);\n    postSuccess(index, step_neighbors, \"Neighbor search index constructed\");\n\n    tsne.compute(\n        state.params.tsne[\"tsne-perp\"], \n        state.params.tsne[\"tsne-iter\"], \n        state.params.tsne[\"animate\"]\n    );\n    postSuccessAsync(tsne, step_tsne, \"t-SNE completed\");\n\n    umap.compute(\n        state.params.umap[\"umap-nn\"], \n        state.params.umap[\"umap-epochs\"], \n        state.params.umap[\"umap-min_dist\"], \n        state.params.umap[\"animate\"]\n    );\n    postSuccessAsync(umap, step_umap, \"UMAP completed\");\n\n    let method = state.params.cluster[\"clus-method\"];\n    kmeans_cluster.compute(\n        method == \"kmeans\", \n        state.params.cluster[\"kmeans-k\"]\n    );\n    postSuccess(kmeans_cluster, step_kmeans, \"K-means clustering completed\");\n\n    snn_cluster.compute(\n        method == \"snn_graph\", \n        state.params.cluster[\"clus-k\"], \n        state.params.cluster[\"clus-scheme\"], \n        state.params.cluster[\"clus-res\"]\n    );\n    postSuccess(snn_cluster, step_snn, \"SNN graph clustering completed\");\n  \n    cluster_choice.compute(state.params.cluster[\"clus-method\"]);\n    postSuccess(cluster_choice, step_choice, \"Clustering of interest chosen\");\n\n    cluster_markers.compute();\n    postSuccess(cluster_markers, step_markers, \"Marker detection complete\");\n\n    label_cells.compute(\n        state.params.annotateCells[\"annotateCells-human_references\"],\n        state.params.annotateCells[\"annotateCells-mouse_references\"]\n    );\n    postSuccessAsync(label_cells, step_labels, \"Cell type labelling complete\");\n\n    custom_markers.compute();\n    postSuccess(custom_markers, step_custom, \"Pruning of custom markers finished\");\n\n    return;\n}\n \n/***************************************/\n \nasync function serializeAllSteps(saver, embedded) {\n    const path = \"temp.h5\";\n\n    let output;\n    try {\n        let handle = scran.createNewHDF5File(path);\n\n        await inputs.serialize(handle, saver, embedded);\n        qc.serialize(handle);\n        normalization.serialize(handle);\n        variance.serialize(handle);\n        pca.serialize(handle);\n        index.serialize(handle);\n        await tsne.serialize(handle);\n        await umap.serialize(handle);\n        kmeans_cluster.serialize(handle);\n        snn_cluster.serialize(handle);\n        cluster_choice.serialize(handle);\n        cluster_markers.serialize(handle);\n        await label_cells.serialize(handle);\n        custom_markers.serialize(handle);\n\n        output = scran.readFile(path);\n    } finally {\n        if (scran.fileExists(path)) {\n            scran.removeFile(path);\n        }\n    }\n\n    return output;\n}\n\nasync function unserializeAllSteps(path, loader, embedded) {\n    var postSuccess = function (namespace, step, message) {\n        postSuccess_(namespace.results(), step, message);\n    }\n\n    var postSuccessAsync = function (namespace, step, message) {\n        namespace.results()\n            .then(res => {\n                postSuccess_(res, step, message);\n            });\n    }\n\n    let response = {};\n    let handle = new scran.H5File(path);\n\n    let permuter = await inputs.unserialize(handle, loader, embedded);\n    response[\"files\"] = {\n        \"format\": \"kana\",\n        \"files\": []\n    };\n    postSuccess(inputs, step_inputs, \"Reloaded count matrix\");\n\n    {\n        let params = qc.unserialize(handle);\n        postSuccess(qc, step_qc, \"Reloaded QC metrics\");\n        response[\"qc\"] = {\n            \"qc-usemitodefault\": params.use_mito_default,\n            \"qc-mito\": params.mito_prefix,\n            \"qc-nmads\": params.nmads\n        };\n    }\n\n    normalization.unserialize(handle);\n    postSuccess(normalization, step_norm, \"Reloaded log-normalization\");\n\n    {\n        let params = variance.unserialize(handle, permuter);\n        postSuccess(variance, step_feat, \"Reloaded variance modelling statistics\");\n        response[\"fSelection\"] = {\n            \"fsel-span\": params.span\n        };\n    }\n\n    {\n        let params = pca.unserialize(handle);\n        postSuccess(pca, step_pca, \"Reloaded principal components\");\n        response[\"pca\"] = {\n            \"pca-hvg\": params.num_hvgs,\n            \"pca-npc\": params.num_pcs\n        };\n    }\n\n    {\n        let params = index.unserialize(handle);\n        postSuccess(index, step_neighbors, \"Reloaded neighbor search index\");\n        response[\"cluster\"] = {\n            \"clus-approx\": params.approximate\n        };\n    }\n\n    {\n        let params = tsne.unserialize(handle);\n        postSuccessAsync(tsne, step_tsne, \"t-SNE reloaded\");\n        response[\"tsne\"] = {\n            \"tsne-perp\": params.perplexity,\n            \"tsne-iter\": params.iterations,\n            \"animate\": params.animate\n        };\n    }\n\n    {\n        let params = umap.unserialize(handle);\n        postSuccessAsync(umap, step_umap, \"UMAP reloaded\");\n        response[\"umap\"] = {\n            \"umap-epochs\": params.num_epochs,\n            \"umap-nn\": params.num_neighbors,\n            \"umap-min_dist\": params.min_dist,\n            \"animate\": params.animate\n        };\n    }\n\n    {\n        let params = kmeans_cluster.unserialize(handle);\n        postSuccess(kmeans_cluster, step_kmeans, \"K-means clustering reloaded\");\n        response[\"cluster\"][\"kmeans-k\"] = params.k; // 'cluster' already added above.\n    }\n\n    {\n        let params = snn_cluster.unserialize(handle);\n        postSuccess(snn_cluster, step_snn, \"SNN graph clustering reloaded\");\n        response[\"cluster\"][\"clus-k\"] = params.k;\n        response[\"cluster\"][\"clus-scheme\"] = params.scheme;\n        response[\"cluster\"][\"clus-res\"] = params.resolution;\n    }\n\n    {\n        let params = cluster_choice.unserialize(handle);\n        postSuccess(cluster_choice, step_choice, \"Clustering of interest chosen\");\n        response[\"cluster\"][\"clus-method\"] = params.method;\n    }\n\n    cluster_markers.unserialize(handle, permuter);\n    postSuccess(cluster_markers, step_markers, \"Reloaded per-cluster markers\");\n\n    {\n        let params = label_cells.unserialize(handle);    \n        postSuccessAsync(label_cells, step_labels, \"Reloaded cell type labels\");\n        response[\"annotateCells\"] = {\n            \"annotateCells-human_references\": params.human_references,\n            \"annotateCells-mouse_references\": params.mouse_references\n        };\n    }\n\n    {\n        let params = custom_markers.unserialize(handle, permuter);\n        postSuccess(custom_markers, step_custom, \"Pruning of custom markers finished\");\n        response[\"custom-selections\"] = params;\n    }\n\n    return response;\n}\n\n/***************************************/\n\nvar loaded;\nonmessage = function (msg) {\n    const payload = msg.data;\n    if (payload.type == \"INIT\") {\n        let nthreads = Math.round(navigator.hardwareConcurrency * 2 / 3);\n        let scran_init = scran.initialize({ numberOfThreads: nthreads });\n        scran_init \n            .then(x => {\n                postMessage({\n                    type: payload.type,\n                    msg: `Success: ScranJS/WASM initialized`\n                });\n            });\n\n        let kana_init = kana_db.initialize();\n        kana_init\n            .then(result => {\n                if (result !== null) {\n                    postMessage({\n                        type: \"KanaDB_store\",\n                        resp: result,\n                        msg: \"Success\"\n                    });\n                } else {\n                    console.error(error);\n                    postMessage({\n                        type: \"KanaDB_ERROR\",\n                        msg: `Fail: Cannot initialize DB`\n                    });\n                }\n            });\n\n        let tsne_init = tsne.initialize();\n        let umap_init = umap.initialize();\n\n        loaded = Promise.all([\n            scran_init,\n            kana_init,\n            tsne_init,\n            umap_init\n        ]);\n\n    } else if (payload.type == \"RUN\") {\n        loaded\n            .then(x => {\n                runAllSteps(payload.payload)\n            })\n            .catch(error => {\n                console.error(error);\n                postMessage({\n                    type: \"run_ERROR\",\n                    msg: error.toString()\n                });\n            });\n\n    /**************** LOADING EXISTING ANALYSES *******************/\n    } else if (payload.type == \"LOAD\") {\n        const path = \"temp.h5\";\n\n        if (payload.payload.files.format == \"kana\") {\n            let f = payload.payload.files.files.file[0];\n            loaded\n                .then(async (x) => {\n                    const reader = new FileReaderSync();\n                    let res = reader.readAsArrayBuffer(f);\n                    try {\n                        let loaders = await serialize_utils.load(res, path);\n                        let response = await unserializeAllSteps(path, loaders.loader, loaders.embedded);\n                        postMessage({\n                            type: \"loadedParameters\",\n                            resp: response\n                        });\n                    } finally {\n                        if (scran.fileExists(path)) {\n                            scran.removeFile(path);\n                        }\n                    }\n                })\n                .catch(error => {\n                    console.error(error);\n                    postMessage({\n                        type: \"load_ERROR\",\n                        msg: error.toString()\n                    });\n                });\n\n        } else if (payload.payload.files.format == \"kanadb\") {\n            var id = payload.payload.files.files.file;\n            kana_db.loadAnalysis(id)\n                .then(async (res) => {\n                    if (res == null) {\n                        postMessage({\n                            type: \"KanaDB_ERROR\",\n                            msg: `Fail: cannot load analysis ID '${id}'`\n                        });\n                    } else {\n                        try {\n                            let loaders = await serialize_utils.load(res, path);\n                            let response = await unserializeAllSteps(path, loaders.loader, loaders.embedded);\n                            postMessage({\n                                type: \"loadedParameters\",\n                                resp: response\n                            });\n                        } finally {\n                            if (scran.fileExists(path)) {\n                                scran.removeFile(path);\n                            }\n                        }\n                    }\n                })\n                .catch(error => {\n                    console.error(error);\n                    postMessage({\n                        type: \"load_ERROR\",\n                        msg: error.toString()\n                    });\n                });\n        }\n  \n    /**************** SAVING EXISTING ANALYSES *******************/\n    } else if (payload.type == \"EXPORT\") { \n        loaded\n            .then(async (x) => {\n                var savers = await serialize_utils.createSaver(true);\n                var state = await serializeAllSteps(savers.saver, true);\n                var output = await serialize_utils.saveEmbedded(state, savers.collected, true);\n                postMessage({\n                    type: \"exportState\",\n                    resp: output,\n                    msg: \"Success: application state exported\"\n                }, [output]);\n            })\n            .catch(error => {\n                console.error(error);\n                postMessage({\n                    type: \"export_ERROR\",\n                    msg: error.toString()\n                });\n            });\n \n    } else if (payload.type == \"SAVEKDB\") { // save analysis to inbrowser indexedDB \n        var title = payload.payload.title;\n        loaded\n            .then(async (x) => {\n                var savers = await serialize_utils.createSaver(false);\n                var state = await serializeAllSteps(savers.saver, false);\n                var output = await serialize_utils.saveLinked(state, savers.collected, title);\n                if (id !== null) {\n                    let recs = await kana_db.getRecords();\n                    postMessage({\n                        type: \"KanaDB_store\",\n                        resp: recs,\n                        msg: `Success: Saved analysis to cache (${id})`\n                    });\n                } else {\n                    console.error(error);\n                    postMessage({\n                        type: \"KanaDB_ERROR\",\n                        msg: `Fail: Cannot save analysis to cache (${id})`\n                    });\n                }\n            })\n            .catch(error => {\n                console.error(error);\n                postMessage({\n                    type: \"export_ERROR\",\n                    msg: error.toString()\n                });\n            });\n  \n    } else if (payload.type == \"REMOVEKDB\") { // remove a saved analysis\n        var id = payload.payload.id;\n        kana_db.removeAnalysis(id)\n            .then(async (result) => {\n                if (result) {\n                    let recs = await kana_db.getRecords();\n                    postMessage({\n                        type: \"KanaDB_store\",\n                        resp: recs,\n                        msg: `Success: Removed file from cache (${id})`\n                    });\n                } else {\n                    console.error(error);\n                    postMessage({\n                        type: \"KanaDB_ERROR\",\n                        msg: `fail: cannot remove file from cache (${id})`\n                    });\n                }\n            });\n  \n    /**************** OTHER EVENTS FROM UI *******************/\n    } else if (payload.type == \"getMarkersForCluster\") {\n        loaded.then(x => {\n            let cluster = payload.payload.cluster;\n            let rank_type = payload.payload.rank_type;\n            var resp = cluster_markers.fetchGroupResults(rank_type, cluster);\n      \n            var transferrable = [];\n            utils.extractBuffers(resp, transferrable);\n            postMessage({\n                type: \"setMarkersForCluster\",\n                resp: resp,\n                msg: \"Success: GET_MARKER_GENE done\"\n            }, transferrable);\n        });\n  \n    } else if (payload.type == \"getGeneExpression\") {\n        loaded.then(x => {\n            let row_idx = payload.payload.gene;\n            var vec = normalization.fetchExpression(row_idx);\n            postMessage({\n                type: \"setGeneExpression\",\n                resp: {\n                    gene: row_idx,\n                    expr: vec\n                },\n                msg: \"Success: GET_GENE_EXPRESSION done\"\n            }, [vec.buffer]);\n        });\n  \n    } else if (payload.type == \"computeCustomMarkers\") {\n        loaded.then(x => {\n            custom_markers.addSelection(payload.payload.id, payload.payload.selection);\n            postMessage({\n                type: \"computeCustomMarkers\",\n                msg: \"Success: COMPUTE_CUSTOM_MARKERS done\"\n            });\n        });\n  \n    } else if (payload.type == \"getMarkersForSelection\") {\n        loaded.then(x => {\n            var resp = custom_markers.fetchResults(payload.payload.cluster, payload.payload.rank_type);\n            var transferrable = [];\n            utils.extractBuffers(resp, transferrable);\n            postMessage({\n                type: \"setMarkersForCustomSelection\",\n                resp: resp,\n                msg: \"Success: GET_MARKER_GENE done\"\n            }, transferrable);\n        });\n  \n    } else if (payload.type == \"removeCustomMarkers\") {\n        loaded.then(x => {\n            custom_markers.removeSelection(payload.payload.id);\n        });\n  \n    } else if (payload.type == \"animateTSNE\") {\n        loaded.then(async (x) => {\n            await tsne.animate();\n            var res = await tsne.results();\n            postSuccess_(res, \"tsne\", \"Resending t-SNE coordinates\");\n        });\n  \n    } else if (payload.type == \"animateUMAP\") {\n        loaded.then(async (x) => {\n            await umap.animate();\n            var res = await umap.results();\n            postSuccess_(res, \"umap\", \"Resending UMAP coordinates\");\n        });\n\n    } else if (payload.type == \"getAnnotation\") {\n        loaded.then(x => {\n            let annot = payload.payload.annotation;\n            var vec = inputs.fetchAnnotations(annot);\n            postMessage({\n                type: \"setAnnotation\",\n                resp: {\n                    annotation: annot,\n                    values: {\n                        \"index\": vec.index,\n                        \"factor\": vec.factor\n                    }\n                },\n                msg: \"Success: GET_ANNOTATION done\"\n            }, [vec.factor.buffer]);\n        });\n  \n    } else {\n        console.error(\"MIM:::msg type incorrect\")\n    }\n}\n","// The module cache\nvar __webpack_module_cache__ = {};\n\n// The require function\nfunction __webpack_require__(moduleId) {\n\t// Check if module is in cache\n\tvar cachedModule = __webpack_module_cache__[moduleId];\n\tif (cachedModule !== undefined) {\n\t\treturn cachedModule.exports;\n\t}\n\t// Create a new module (and put it into the cache)\n\tvar module = __webpack_module_cache__[moduleId] = {\n\t\t// no module.id needed\n\t\t// no module.loaded needed\n\t\texports: {}\n\t};\n\n\t// Execute the module function\n\t__webpack_modules__[moduleId](module, module.exports, __webpack_require__);\n\n\t// Return the exports of the module\n\treturn module.exports;\n}\n\n// expose the modules object (__webpack_modules__)\n__webpack_require__.m = __webpack_modules__;\n\n// the startup function\n__webpack_require__.x = function() {\n\t// Load entry module and return exports\n\t// This entry module depends on other loaded chunks and execution need to be delayed\n\tvar __webpack_exports__ = __webpack_require__.O(undefined, [275,555], function() { return __webpack_require__(7794); })\n\t__webpack_exports__ = __webpack_require__.O(__webpack_exports__);\n\treturn __webpack_exports__;\n};\n\n","var deferred = [];\n__webpack_require__.O = function(result, chunkIds, fn, priority) {\n\tif(chunkIds) {\n\t\tpriority = priority || 0;\n\t\tfor(var i = deferred.length; i > 0 && deferred[i - 1][2] > priority; i--) deferred[i] = deferred[i - 1];\n\t\tdeferred[i] = [chunkIds, fn, priority];\n\t\treturn;\n\t}\n\tvar notFulfilled = Infinity;\n\tfor (var i = 0; i < deferred.length; i++) {\n\t\tvar chunkIds = deferred[i][0];\n\t\tvar fn = deferred[i][1];\n\t\tvar priority = deferred[i][2];\n\t\tvar fulfilled = true;\n\t\tfor (var j = 0; j < chunkIds.length; j++) {\n\t\t\tif ((priority & 1 === 0 || notFulfilled >= priority) && Object.keys(__webpack_require__.O).every(function(key) { return __webpack_require__.O[key](chunkIds[j]); })) {\n\t\t\t\tchunkIds.splice(j--, 1);\n\t\t\t} else {\n\t\t\t\tfulfilled = false;\n\t\t\t\tif(priority < notFulfilled) notFulfilled = priority;\n\t\t\t}\n\t\t}\n\t\tif(fulfilled) {\n\t\t\tdeferred.splice(i--, 1)\n\t\t\tvar r = fn();\n\t\t\tif (r !== undefined) result = r;\n\t\t}\n\t}\n\treturn result;\n};","// getDefaultExport function for compatibility with non-harmony modules\n__webpack_require__.n = function(module) {\n\tvar getter = module && module.__esModule ?\n\t\tfunction() { return module['default']; } :\n\t\tfunction() { return module; };\n\t__webpack_require__.d(getter, { a: getter });\n\treturn getter;\n};","// define getter functions for harmony exports\n__webpack_require__.d = function(exports, definition) {\n\tfor(var key in definition) {\n\t\tif(__webpack_require__.o(definition, key) && !__webpack_require__.o(exports, key)) {\n\t\t\tObject.defineProperty(exports, key, { enumerable: true, get: definition[key] });\n\t\t}\n\t}\n};","__webpack_require__.f = {};\n// This file contains only the entry chunk.\n// The chunk loading function for additional chunks\n__webpack_require__.e = function(chunkId) {\n\treturn Promise.all(Object.keys(__webpack_require__.f).reduce(function(promises, key) {\n\t\t__webpack_require__.f[key](chunkId, promises);\n\t\treturn promises;\n\t}, []));\n};","// This function allow to reference async chunks and sibling chunks for the entrypoint\n__webpack_require__.u = function(chunkId) {\n\t// return url for filenames based on template\n\treturn \"static/js/\" + chunkId + \".\" + {\"139\":\"648828a0\",\"275\":\"a46fbc3b\",\"495\":\"9608b3d0\",\"555\":\"5b63638f\",\"653\":\"983ac64d\"}[chunkId] + \".chunk.js\";\n};","// This function allow to reference async chunks and sibling chunks for the entrypoint\n__webpack_require__.miniCssF = function(chunkId) {\n\t// return url for filenames based on template\n\treturn undefined;\n};","__webpack_require__.g = (function() {\n\tif (typeof globalThis === 'object') return globalThis;\n\ttry {\n\t\treturn this || new Function('return this')();\n\t} catch (e) {\n\t\tif (typeof window === 'object') return window;\n\t}\n})();","__webpack_require__.o = function(obj, prop) { return Object.prototype.hasOwnProperty.call(obj, prop); }","// define __esModule on exports\n__webpack_require__.r = function(exports) {\n\tif(typeof Symbol !== 'undefined' && Symbol.toStringTag) {\n\t\tObject.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });\n\t}\n\tObject.defineProperty(exports, '__esModule', { value: true });\n};","__webpack_require__.p = \"/kana/\";","__webpack_require__.b = self.location + \"/../../../\";\n\n// object to store loaded chunks\n// \"1\" means \"already loaded\"\nvar installedChunks = {\n\t794: 1\n};\n\n// importScripts chunk loading\nvar installChunk = function(data) {\n\tvar chunkIds = data[0];\n\tvar moreModules = data[1];\n\tvar runtime = data[2];\n\tfor(var moduleId in moreModules) {\n\t\tif(__webpack_require__.o(moreModules, moduleId)) {\n\t\t\t__webpack_require__.m[moduleId] = moreModules[moduleId];\n\t\t}\n\t}\n\tif(runtime) runtime(__webpack_require__);\n\twhile(chunkIds.length)\n\t\tinstalledChunks[chunkIds.pop()] = 1;\n\tparentChunkLoadingFunction(data);\n};\n__webpack_require__.f.i = function(chunkId, promises) {\n\t// \"1\" is the signal for \"already loaded\"\n\tif(!installedChunks[chunkId]) {\n\t\tif(true) { // all chunks have JS\n\t\t\timportScripts(__webpack_require__.p + __webpack_require__.u(chunkId));\n\t\t}\n\t}\n};\n\nvar chunkLoadingGlobal = self[\"webpackChunkkana\"] = self[\"webpackChunkkana\"] || [];\nvar parentChunkLoadingFunction = chunkLoadingGlobal.push.bind(chunkLoadingGlobal);\nchunkLoadingGlobal.push = installChunk;\n\n// no HMR\n\n// no HMR manifest","var next = __webpack_require__.x;\n__webpack_require__.x = function() {\n\treturn Promise.all([\n\t\t__webpack_require__.e(275),\n\t\t__webpack_require__.e(555)\n\t]).then(next);\n};","// run startup\nvar __webpack_exports__ = __webpack_require__.x();\n"],"names":["copyVectors","data","copy","Object","keys","k","slice","copyOrView","mimicGetter","value","wa","view","array","freeCache","object","undefined","free","changedParameters","x","y","JSON","stringify","allocateCachedArray","size","type","cache","name","reallocate","candidate","constructor","className","scran","extractBuffers","store","Array","isArray","entries","ArrayBuffer","isView","buffer","push","isObject","parameters","abbreviated","changed","dummyGenes","numberOfRows","genes","i","readDSVFromBuffer","content","fname","delim","ext","split","pop","pako","dec","TextDecoder","decoded","decode","tsv","d3","parsed","parseRows","loadMatrixMarketRaw","files","utils","matrix","first_mtx","filter","contents","Uint8Array","is_compressed","genes_file","length","ids","symb","forEach","annotations_file","diff","numberOfColumns","headerFlag","headers","shift","annotations","map","load10XRaw","first_file","tmppath","objects","fobjects","id","names","loadH5ADRaw","vobjects","key","match","bobjects","val","bobj_factors","bobj_index","loadHDF5","args","format","reader","FileReaderSync","it","bufferFun","formatted","f","readAsArrayBuffer","file","compute","mtx","gene","barcode","loadMatrixMarket","results","output","serialize","handle","saver","embedded","ghandle","createGroup","phandle","writeDataSet","fihandle","index","obj","curhandle","String","res","offset","perm","permutation","dims","rhandle","unserialize","loader","open","kids","children","current","curfile","field","dhandle","load","values","buffer_deets","idx","Number","permuter","temp","set","fetchCountMatrix","fetchGenes","fetchGeneTypes","gene_info_type","gene_info","gene_types","fetchAnnotations","col","annots","uvals","uTypedAray","asize","mito","ensembl","Set","symbol","applyFilters","mat","inputs","disc","fetchDiscards","use_mito_default","mito_prefix","nmads","run_metrics","run_filters","run_apply","filters","QCFiltersMimic","metrics","QCMetricsMimic","subsets","fill","sub_arr","has","lower_mito","toLowerCase","startsWith","computeMetrics","numberOfMADs","computeFilters","getData","sums","detected","proportion","subsetProportions","getThresholds","thresholdsSums","thresholdsDetected","thresholdsSubsetProportions","thresholds","ranges","max","Infinity","min","remaining","mhandle","thandle","this","sums_","detected_","proportion_","discards","thresholds_sums","thresholds_detected","thresholds_proportion","fetchSums","unsafe","discardOverall","fetchFilteredMatrix","rawCompute","qc","size_factors","j","sizeFactors","path","fetchNormalizedMatrix","fetchExpression","row","span","normalization","sorted_residuals","residuals","sort","getResults","means","variances","fitted","ModelGeneVarMimic","vars","resids","means_","vars_","fitted_","resids_","reloaded","fetchSortedResiduals","fetchResiduals","chooseFeatures","num_hvgs","sorted_resids","variance","threshold_at","sub","unsorted_resids","element","num_pcs","hvg_buffer","pcs","features","numberOfPCs","pca_output","var_exp","varianceExplained","total_var","totalVariance","ve","fetchPCs","num_obs","PCAMimic","principalComponents","approximate","pca","raw","numberOfDims","numberOfCells","fetchIndex","valid","fetchClustersAsWasmArray","clusters","membership","run_me","scheme","resolution","rerun_neighbors","rerun_graph","rerun_clusters","neighbors","graph","SNNClusterMimic","run_k","initMethod","KmeansMimic","method","snn_cluster","kmeans_cluster","computeNeighbors","nn_index","rbuf","ibuf","dbuf","runs","indices","distances","sendTask","worker","payload","transferrable","counter","p","Promise","resolve","reject","promises","postMessage","initializeWorker","onmessage","msg","endsWith","iteration","fun","error","runWithNeighbors","nn_out","run_msg","initialize","vizutils","Worker","URL","core","perplexity","iterations","animate","reneighbor","run","then","initialized","num_neighbors","num_epochs","min_dist","summaries2int","int2summaries","serializeGroupStats","group","no_summaries","ihandle","i0","extractor","summary","unserializeGroupStats","fetchGroupResults","rank_type","ordering","ranking","increasing","cohen","auc","lfc","deltaDetected","Int32Array","s","reorder","stats","thing","Float64Array","stat_detected","stat_mean","stat_lfc","stat_delta_d","choice","num","numberOfGroups","markers","DownloadsDB","ScoreMarkersMimic","sidx","effect_grabber","stat_grabber","cl","fetchGroupMeans","init","indexedDB","onupgradeneeded","e","DownloadsDBClient","target","result","deleteObjectStore","createObjectStore","keyPath","onsuccess","onerror","get","url","params","force","trans","transaction","download_store","objectStore","data_check","already","event","found","req","fetch","ok","status","arrayBuffer","data_saving","putrequest","put","hs_loaded","mm_loaded","hs_references","mm_references","proxy","hs_base","mm_base","quickLineReader","compression","txt","lines","getBuiltReference","species","rebuild","base","preloaded","references","downloads","all","encodeURIComponent","buffers","loaded","gene_lines","fields","labels","chosen_ids","feature_details","built","compareArrays","human_references","mouse_references","types","best_feature","best","confidence","g","ref","ngenes","ngroups","cluster_means","numberOfFeatures","o","used_refs","used","used_vals","integrated","arr","feats","integrated_results","out","as_names","perref","perhandle","per_reference","selections","kanaDB","CustomMarkersMimic","sel","v","addSelection","selection","tmp","removeSelection","fetchResults","getRecordsResolver","allAnalysis","getAll","vals","loadContent","request","allOK","allSettled","getRecords","saveFile","file_store","meta_store","meta","refcount","ref_saving","count","saveAnalysis","state","title","analysis_store","id_saving","Date","loadFile","removeFile","remove","delete","recoverTypedArrays","cls","Int8Array","Uint16Array","Int16Array","Uint32Array","Uint64Array","Int64Array","Float32Array","convertFromVersion0","newfile","fhandle","info","xhandle","chandle","num_cells","gehandle","mparams","quality_control_metrics","tparams","quality_control_thresholds","mcontents","tcontents","feature_selection","npcs","ncells","tsne","umap","createDataSet","write","find_params","snn_find_neighbors","build_params","snn_build_graph","cluster_params","snn_cluster_graph","choose_clustering","marker_detection","rankings","shandle","custom_marker_management","numberToBuffer","number","Math","floor","bufferToNumber","multiplier","createSaver","collected","sofar","byteLength","hashwasm","md5","kana_db","save_internal","format_type","extras","combined","combined_arr","version","state_len","saveEmbedded","total_len","saved","buf","saveLinked","state_path","from_v0","parse","bundle","start","postSuccess_","step","message","transferable","resp","step_inputs","step_qc","step_norm","step_feat","step_pca","step_neighbors","step_tsne","step_umap","step_kmeans","step_snn","step_choice","step_markers","step_labels","step_custom","serializeAllSteps","cluster_choice","cluster_markers","label_cells","custom_markers","unserializeAllSteps","postSuccess","namespace","postSuccessAsync","response","nthreads","round","navigator","hardwareConcurrency","scran_init","numberOfThreads","kana_init","kanaDBClient","console","tsne_init","umap_init","fSelection","cluster","annotateCells","runAllSteps","catch","toString","serialize_utils","loaders","savers","recs","row_idx","vec","expr","annot","annotation","factor","__webpack_module_cache__","__webpack_require__","moduleId","cachedModule","exports","module","__webpack_modules__","m","__webpack_exports__","O","deferred","chunkIds","fn","priority","notFulfilled","fulfilled","every","splice","r","n","getter","__esModule","d","a","definition","defineProperty","enumerable","chunkId","reduce","u","miniCssF","globalThis","Function","window","prop","prototype","hasOwnProperty","call","Symbol","toStringTag","b","self","location","installedChunks","importScripts","chunkLoadingGlobal","parentChunkLoadingFunction","bind","moreModules","runtime","next"],"sourceRoot":""}