{"version":3,"file":"static/js/109.91244675.chunk.js","mappings":"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","sources":["workers/_utils.js","workers/_inputs.js","workers/mito.js","workers/_qc_metrics.js","workers/_qc_thresholds.js","workers/_qc_filter.js","workers/_normalization.js","workers/_model_gene_var.js","workers/_pca.js","workers/_neighbor_index.js","workers/_snn_neighbors.js","workers/_snn_graph.js","workers/_snn_cluster.js","workers/_kmeans_cluster.js","workers/_choose_clustering.js","workers/_utils_viz_parent.js","workers/_tsne_monitor.js","workers/_umap_monitor.js","workers/_utils_markers.js","workers/_score_markers.js","workers/DownloadsDBHandler.js","workers/_label_cells.js","workers/_custom_markers.js","workers/KanaDBHandler.js","workers/scran.worker.js","workers/_utils_serialize.js","../webpack/bootstrap","../webpack/runtime/chunk loaded","../webpack/runtime/compat get default export","../webpack/runtime/define property getters","../webpack/runtime/ensure chunk","../webpack/runtime/get javascript chunk filename","../webpack/runtime/get mini-css chunk filename","../webpack/runtime/global","../webpack/runtime/hasOwnProperty shorthand","../webpack/runtime/make namespace object","../webpack/runtime/publicPath","../webpack/runtime/importScripts chunk loading","../webpack/runtime/startup chunk dependencies","../webpack/startup"],"sourcesContent":["import * as scran from \"scran.js\";\nimport * as wa from \"wasmarrays.js\";\n\nexport function freeCache(object) {\n    if (object !== undefined && object !== null) {\n        try { // placeholder try() for now, because older scran.js don't work with double-free.\n            object.free();\n        } catch (e) {\n        }\n    }\n    return;\n}\n\nexport function freeReloaded(cache) {\n    if (\"reloaded\" in cache) {\n        for (const [k, v] of Object.entries(cache.reloaded)) {\n            if (v instanceof wa.WasmArray) {\n                v.free();\n            }\n        }\n        delete cache.reloaded;\n    }\n}\n\nexport function changedParameters(x, y) {\n    return JSON.stringify(x) != JSON.stringify(y);\n}\n\nexport function computeRange(arr) {\n    var max = -Infinity, min = Infinity;\n    arr.forEach(function (x) {\n        if (max < x) {\n            max = x;\n        }\n        if (min > x) {\n            min = x;\n        }\n    });\n    return [min, max];\n}\n\nexport function allocateCachedArray(size, type, cache, name = \"buffer\") {\n    var reallocate = true;\n    if (name in cache) {\n        var candidate = cache[name];\n        if (candidate.size != size || candidate.constructor.className != type) {\n            candidate.free();\n        } else {\n            reallocate = false;\n        }\n    }\n  \n    if (reallocate) {\n        switch (type) {\n            case \"Uint8Array\":\n                cache[name] = scran.createUint8WasmArray(size);\n                break;\n            case \"Int32Array\":\n                cache[name] = scran.createInt32WasmArray(size);\n                break;\n            case \"Float64Array\":\n                cache[name] = scran.createFloat64WasmArray(size);\n                break;\n            default:\n                // We only ever use one of the three above types in our \n                // internal data stores, so no need to go all-out here.\n                throw \"allocating '\" + type + \"' not yet supported\";\n        }\n    }\n\n    return cache[name];\n}\n\nexport function extractBuffers(object, store) {\n    if (Array.isArray(object)) {\n        for (const element of object) {\n            extractBuffers(element, store);\n        }\n    } else if (object.constructor == Object) {\n        for (const [key, element] of Object.entries(object)) {\n            extractBuffers(element, store);\n        }\n    } else if (ArrayBuffer.isView(object)) {\n        if (! (object.buffer instanceof ArrayBuffer)) {\n            throw \"only ArrayBuffers should be in the message payload\";\n        }\n        store.push(object.buffer);\n    }\n}\n\nexport function isObject(object) {\n    return typeof object === 'object' && Array.isArray(object) === false;\n}\n","import * as scran from \"scran.js\";\nimport * as utils from \"./_utils.js\";\nimport * as d3 from \"d3-dsv\";\nimport * as pako from \"pako\";\n\nvar cache = {};\nvar parameters = {};\nvar abbreviated = {};\n\nexport var changed = false;\n\nfunction dummyGenes(numberOfRows) {\n    let genes = []\n    for (let i = 0; i < numberOfRows; i++) {\n        genes.push(`Gene ${i + 1}`);\n    }\n    return { \"id\": genes };\n}\n\nfunction guessFeatureType() {\n    var gene_info_type = {};\n    var gene_info = fetchGenes();\n    for (const [key, val] of Object.entries(gene_info)) {\n        gene_info_type[key] = scran.guessFeatures(val);\n    }\n    cache.gene_types = gene_info_type;\n    return;\n}\n\nfunction readDSVFromBuffer(content, fname, delim = \"\\t\") {\n    var ext = fname.name.split('.').pop();\n\n    if (ext == \"gz\") {\n        content = pako.ungzip(content);\n    }\n\n    const dec = new TextDecoder();\n    let decoded = dec.decode(content);\n    const tsv = d3.dsvFormat(delim);\n    let parsed = tsv.parseRows(decoded);\n\n    return parsed;\n}\n\n/** Matrix Market **/\nfunction loadMatrixMarketRaw(files) {\n    utils.freeCache(cache.matrix);\n\n    // In theory, this section may support multiple files (e.g., for multiple samples).\n    var mtx_files = files.filter(x => x.type == \"mtx\");\n    var first_mtx = mtx_files[0];\n    var contents = new Uint8Array(first_mtx.buffer);\n    var ext = first_mtx.name.split('.').pop();\n    var is_compressed = (ext == \"gz\");\n    cache.matrix = scran.initializeSparseMatrixFromMatrixMarketBuffer(contents, { \"compressed\": is_compressed });\n\n    var genes_file = files.filter(x => x.type == \"genes\");\n    if (genes_file.length == 1) {\n        var genes_file = genes_file[0]\n        var content = new Uint8Array(genes_file.buffer);\n\n        let parsed = readDSVFromBuffer(content, genes_file);\n\n        if (parsed.length != cache.matrix.numberOfRows()) {\n            throw \"number of matrix rows is not equal to the number of genes in '\" + genes_file.name + \"'\";\n        }\n\n        var ids = [], symb = [];\n        parsed.forEach(x => {\n            ids.push(x[0]);\n            symb.push(x[1]);\n        });\n\n        cache.genes = { \"id\": ids, \"symbol\": symb };\n    } else {\n        cache.genes = dummyGenes(cache.matrix.numberOfRows());\n    }\n\n    scran.permuteFeatures(cache.matrix, cache.genes);\n\n    var annotations_file = files.filter(x => x.type == \"annotations\");\n    if (annotations_file.length == 1) {\n        var annotations_file = annotations_file[0]\n        var content = new Uint8Array(annotations_file.buffer);\n\n        let parsed = readDSVFromBuffer(content, annotations_file);\n\n        let diff = cache.matrix.numberOfColumns() - parsed.length;\n        // check if a header is present or not\n        let headerFlag = false;\n        if (diff === 0) {\n            headerFlag = false;\n        } else if (diff === -1) {\n            headerFlag = true;\n        } else {\n            throw \"number of annotations rows is not equal to the number of cells in '\" + annotations_file.name + \"'\";\n        }\n\n        let headers = [];\n        if (headerFlag) {\n            headers = parsed.shift();\n        } else {\n            parsed[0].forEach((x, i) => {\n                headers.push(`Column_${i + 1}`);\n            })\n        }\n\n        cache.annotations = {}\n        headers.forEach((x, i) => {\n            cache.annotations[x] = parsed.map(y => y[i]);\n        });\n\n    } else {\n        cache.annotations = null;\n    }\n\n    if (\"reloaded\" in cache) {\n        delete cache.reloaded;\n    }\n\n    return;\n}\n\nfunction loadMatrixMarket(args) {\n    var reader = new FileReaderSync();\n\n    // First pass computes an abbreviated version to quickly check for changes.\n    // Second pass does the actual readArrayBuffer.\n    for (var it = 0; it < 2; it++) {\n        var formatted = { \"type\": \"MatrixMarket\", \"files\": [] };\n\n        var bufferFun;\n        if (it == 0) {\n            bufferFun = (f) => f.size;\n        } else {\n            bufferFun = (f) => reader.readAsArrayBuffer(f);\n        }\n\n        for (const f of args.mtx) {\n            formatted.files.push({ \"type\": \"mtx\", \"name\": f.name, \"buffer\": bufferFun(f) });\n        }\n\n        if (args.gene !== null) {\n            if (args.gene.length !== 1) {\n                throw \"expected no more than one gene file\";\n            }\n            var genes_file = args.gene[0];\n            formatted.files.push({ \"type\": \"genes\", \"name\": genes_file.name, \"buffer\": bufferFun(genes_file) });\n        }\n\n        if (args.barcode !== null) {\n            if (args.barcode.length !== 1) {\n                throw \"expected no more than one cell annotation file\";\n            }\n            var annotations_file = args.barcode[0];\n            formatted.files.push({ \"type\": \"annotations\", \"name\": annotations_file.name, \"buffer\": bufferFun(annotations_file) });\n        }\n\n        if (it == 0) {\n            if (!utils.changedParameters(abbreviated, formatted)) {\n                changed = false;\n                return;\n            } else {\n                abbreviated = formatted;\n                changed = true;\n            }\n        } else {\n            parameters = formatted;\n            loadMatrixMarketRaw(formatted.files);\n        }\n    }\n\n    return;\n}\n\n/** HDF5 **/\n\nfunction load10XRaw(files) {\n    utils.freeCache(cache.matrix);\n\n    // In theory, we could support multiple HDF5 buffers.\n    var first_file = files[0];\n    var tmppath = first_file.name;\n    scran.writeFile(tmppath, new Uint8Array(first_file.buffer));\n\n    try {\n        cache.matrix = scran.initializeSparseMatrixFromHDF5(tmppath, \"matrix\");\n\n        // Fetching the gene IDs and names.\n        cache.genes = null;\n        let objects = scran.extractHDF5ObjectNames(tmppath);\n        if (\"features\" in objects[\"matrix\"]) {\n            let fobjects = objects[\"matrix\"][\"features\"];\n            if (\"id\" in fobjects && fobjects[\"id\"] === \"string dataset\") {\n                cache.genes = { id: scran.loadHDF5Dataset(tmppath, \"matrix/features/id\").contents };\n                if (\"name\" in fobjects && fobjects[\"name\"] === \"string dataset\") {\n                    cache.genes.names = scran.loadHDF5Dataset(tmppath, \"matrix/features/name\").contents;\n                }\n            }\n        }\n\n        // TODO: pull out sample IDs from the HDF5 file, if they exist.\n        cache.annotations = null;\n\n    } finally {\n        scran.removeFile(tmppath);\n    }\n\n    if (cache.genes === null) {\n        cache.genes = dummyGenes(cache.matrix.numberOfRows());\n    }\n    scran.permuteFeatures(cache.matrix, cache.genes);\n\n    if (\"reloaded\" in cache) {\n        delete cache.reloaded;\n    }\n\n    return;\n}\n\nfunction loadH5ADRaw(files, name) {\n    utils.freeCache(cache.matrix);\n\n    // In theory, we could support multiple HDF5 buffers.\n    var first_file = files[0];\n    var tmppath = first_file.name;\n    scran.writeFile(tmppath, new Uint8Array(first_file.buffer));\n\n    try {\n        cache.matrix = scran.initializeSparseMatrixFromHDF5(tmppath, \"X\");\n        let objects = scran.extractHDF5ObjectNames(tmppath);\n\n        // Trying to guess the gene names.\n        cache.genes = null;\n        if (\"var\" in objects) {\n            let vobjects = objects[\"var\"];\n            if (utils.isObject(vobjects)) {\n                if (\"_index\" in vobjects && vobjects[\"_index\"] == \"string dataset\") {\n                    cache.genes = { \"_index\": scran.loadHDF5Dataset(tmppath, \"var/_index\").contents };\n                    for (const [key, val] of Object.entries(vobjects)) {\n                        if (val === \"string dataset\" && (key.match(/name/i) || key.match(/symb/i))) {\n                            cache.genes[key] = scran.loadHDF5Dataset(tmppath, `var/${key}`).contents;\n                        }\n                    }\n                }\n            }\n        }\n\n        // Adding the annotations.\n        cache.annotations = null;\n        if (\"obs\" in objects) {\n            let bobjects = objects[\"obs\"];\n            cache.annotations = {};\n\n            if (utils.isObject(bobjects)) {\n                // Maybe it has names, maybe not, who knows; let's just add what's there.\n                if (\"_index\" in bobjects && bobjects[\"_index\"] == \"string dataset\") {\n                    cache.annotations[\"_index\"] = scran.loadHDF5Dataset(tmppath, \"obs/_index\").contents;\n                }\n\n                for (const [key, val] of Object.entries(bobjects)) {\n                    if (val === \"string dataset\" || val === \"integer dataset\" || val === \"float dataset\") {\n                        let bobj_factors = scran.loadHDF5Dataset(tmppath, `obs/${key}`).contents;\n\n                        if (\"__categories\" in bobjects && bobjects[\"__categories\"][key] == \"string dataset\") {\n                            let bobj_index = scran.loadHDF5Dataset(tmppath, `obs/__categories/${key}`).contents;\n                            cache.annotations[key] = {\n                                \"type\": \"factor\",\n                                \"index\": bobj_index,\n                                \"factor\": bobj_factors\n                            }\n                        } else {\n                            cache.annotations[key] = bobj_factors;\n                        }\n                    }\n                }\n            }\n        }\n\n    } finally {\n        scran.removeFile(tmppath);\n    }\n\n    if (cache.genes === null) {\n        cache.genes = dummyGenes(cache.matrix.numberOfRows());\n    }\n    scran.permuteFeatures(cache.matrix, cache.genes);\n\n    if (\"reloaded\" in cache) {\n        delete cache.reloaded;\n    }\n\n    return;\n}\n\nfunction loadHDF5(args, format) {\n    var reader = new FileReaderSync();\n\n    // First pass computes an abbreviated version to quickly check for changes.\n    // Second pass does the actual readArrayBuffer.\n    for (var it = 0; it < 2; it++) {\n        var formatted = { \"type\": format, \"files\": [] };\n\n        var bufferFun;\n        if (it == 0) {\n            bufferFun = (f) => f.size;\n        } else {\n            bufferFun = (f) => reader.readAsArrayBuffer(f);\n        }\n\n        for (const f of args.file) {\n            formatted.files.push({ \"type\": \"h5\", \"name\": f.name, \"buffer\": bufferFun(f) });\n        }\n\n        if (it == 0) {\n            if (!utils.changedParameters(abbreviated, formatted)) {\n                changed = false;\n                return;\n            } else {\n                abbreviated = formatted;\n                changed = true;\n            }\n        } else {\n            parameters = formatted;\n            if (format == \"10X\") {\n                load10XRaw(formatted.files);\n            } else {\n                loadH5ADRaw(formatted.files);\n            }\n        }\n    }\n\n    return;\n}\n\n/** Public functions (standard) **/\nexport function compute(args) {\n    switch (args.format) {\n        case \"mtx\":\n            loadMatrixMarket(args.files);\n            break;\n        case \"hdf5\":\n        case \"tenx\":\n            loadHDF5(args.files, \"10X\");\n            break;\n        case \"h5ad\":\n            loadHDF5(args.files, \"H5AD\");\n            break;\n        case \"kana\":\n            // do nothing, this is handled by unserialize.\n            break;\n        default:\n            throw \"unknown matrix file extension: '\" + args.format + \"'\";\n    }\n    guessFeatureType();\n    return;\n}\n\nexport function results() {\n    var output = { \"dimensions\": fetchDimensions() }\n    if (\"reloaded\" in cache) {\n        output.genes = { ...cache.reloaded.genes };\n\n        if (cache.annotations) {\n            output.annotations = Object.keys(cache.reloaded.annotations);\n        }\n    } else {\n        output.genes = { ...cache.genes };\n        if (cache.annotations) {\n            output.annotations = Object.keys(cache.annotations);\n        }\n    }\n    return output;\n}\n\nexport function serialize() {\n    var contents = {};\n    if (\"reloaded\" in cache) {\n        contents.genes = { ...cache.reloaded.genes };\n        contents.num_cells = cache.reloaded.num_cells;\n        if (cache.reloaded.annotations) {\n            contents.annotations = cache.reloaded.annotations;\n        }\n    } else {\n        contents.genes = { ...cache.genes };\n        contents.num_cells = cache.matrix.numberOfColumns();\n        if (cache.annotations) {\n            contents.annotations = cache.annotations;\n        }\n    }\n\n    // Making a deep-ish clone of the parameters so that any fiddling with\n    // buffers during serialization does not compromise internal state.\n    var parameters2 = { ...parameters };\n    parameters2.files = parameters.files.map(x => { return { ...x }; });\n\n    return {\n        \"parameters\": parameters2,\n        \"contents\": contents\n    };\n}\n\nexport function unserialize(saved) {\n    parameters = saved.parameters;\n    cache.reloaded = saved.contents;\n    guessFeatureType();\n    return;\n}\n\n/** Public functions (custom) **/\nexport function fetchCountMatrix() {\n    if (\"reloaded\" in cache) {\n        if (parameters.type == \"MatrixMarket\") {\n            loadMatrixMarketRaw(parameters.files);\n\n        } else if (parameters.type == \"H5AD\") {\n            loadH5ADRaw(parameters.files);\n\n        } else if (parameters.type == \"10X\") {\n            load10XRaw(parameters.files);\n\n        } else if (parameters.type == \"HDF5\") {\n            // legacy support: trying to guess what it is based on its extension.\n            if (parameters.files[0].name.match(/h5ad$/i)) {\n                loadH5ADRaw(parameters.files);\n            } else {\n                load10XRaw(parameters.files);\n            }\n\n        } else {\n            throw `unrecognized count matrix format, ${parameters.type}`;\n        }\n    }\n    return cache.matrix;\n}\n\nexport function fetchDimensions() {\n    if (\"reloaded\" in cache) {\n        return {\n            // This should contain at least one element,\n            // and all of them should have the same length,\n            // so indexing by the first element is safe.\n            \"num_genes\": Object.values(cache.reloaded.genes)[0].length,\n            \"num_cells\": cache.reloaded.num_cells\n        };\n    } else {\n        return {\n            \"num_genes\": cache.matrix.numberOfRows(),\n            \"num_cells\": cache.matrix.numberOfColumns()\n        };\n    }\n}\n\nexport function fetchGenes() {\n    if (\"reloaded\" in cache) {\n        return cache.reloaded.genes;\n    } else {\n        return cache.genes;\n    }\n}\n\nexport function fetchGeneTypes() {\n    return cache.gene_types;\n}\n\nexport function fetchAnnotations(col) {\n    let annots, asize;\n    if (\"reloaded\" in cache) {\n        annots = cache.reloaded.annotations;\n        asize = cache.reloaded.matrix.numberOfColumns();\n    } else {\n        annots = cache.annotations;\n        asize = cache.matrix.numberOfColumns();\n    }\n\n    if (!(col in annots)) {\n        throw `column ${col} does not exist in col.tsv`;\n    }\n\n    if (utils.isObject(annots[col]) && \"type\" in annots[col]) {\n        return annots[col];\n    }\n\n    let uvals = {};\n    let uTypedAray = new Uint8Array(asize);\n    annots[col].map((x, i) => {\n        if (!(x in uvals)) {\n            uvals[x] = Object.keys(uvals).length;\n        }\n\n        uTypedAray[i] = uvals[x];\n    });\n\n    return {\n        \"index\": Object.keys(uvals),\n        \"factor\": uTypedAray\n    }\n}\n","/* Derived from scran.js's blacklists.js.R. */\n\nexport var mito = {};\nmito.ensembl = new Set([\"ENSMUSG00000064336\",\"ENSMUSG00000064337\",\"ENSMUSG00000064338\",\"ENSMUSG00000064339\",\"ENSMUSG00000064340\",\"ENSMUSG00000064341\",\"ENSMUSG00000064342\",\"ENSMUSG00000064343\",\"ENSMUSG00000064344\",\"ENSMUSG00000064345\",\"ENSMUSG00000064346\",\"ENSMUSG00000064347\",\"ENSMUSG00000064348\",\"ENSMUSG00000064349\",\"ENSMUSG00000064350\",\"ENSMUSG00000064351\",\"ENSMUSG00000064352\",\"ENSMUSG00000064353\",\"ENSMUSG00000064354\",\"ENSMUSG00000064355\",\"ENSMUSG00000064356\",\"ENSMUSG00000064357\",\"ENSMUSG00000064358\",\"ENSMUSG00000064359\",\"ENSMUSG00000064360\",\"ENSMUSG00000064361\",\"ENSMUSG00000064363\",\"ENSMUSG00000064364\",\"ENSMUSG00000064365\",\"ENSMUSG00000064366\",\"ENSMUSG00000064367\",\"ENSMUSG00000064368\",\"ENSMUSG00000064369\",\"ENSMUSG00000064370\",\"ENSMUSG00000064371\",\"ENSMUSG00000064372\",\"ENSMUSG00000065947\",\"ENSG00000198695\",\"ENSG00000198712\",\"ENSG00000198727\",\"ENSG00000198763\",\"ENSG00000198786\",\"ENSG00000198804\",\"ENSG00000198840\",\"ENSG00000198886\",\"ENSG00000198888\",\"ENSG00000198899\",\"ENSG00000198938\",\"ENSG00000209082\",\"ENSG00000210049\",\"ENSG00000210077\",\"ENSG00000210082\",\"ENSG00000210100\",\"ENSG00000210107\",\"ENSG00000210112\",\"ENSG00000210117\",\"ENSG00000210127\",\"ENSG00000210135\",\"ENSG00000210140\",\"ENSG00000210144\",\"ENSG00000210151\",\"ENSG00000210154\",\"ENSG00000210156\",\"ENSG00000210164\",\"ENSG00000210174\",\"ENSG00000210176\",\"ENSG00000210184\",\"ENSG00000210191\",\"ENSG00000210194\",\"ENSG00000210195\",\"ENSG00000210196\",\"ENSG00000211459\",\"ENSG00000212907\",\"ENSG00000228253\"]);\nmito.symbol = new Set([\"mt-Tf\",\"mt-Rnr1\",\"mt-Tv\",\"mt-Rnr2\",\"mt-Tl1\",\"mt-Nd1\",\"mt-Ti\",\"mt-Tq\",\"mt-Tm\",\"mt-Nd2\",\"mt-Tw\",\"mt-Ta\",\"mt-Tn\",\"mt-Tc\",\"mt-Ty\",\"mt-Co1\",\"mt-Ts1\",\"mt-Td\",\"mt-Co2\",\"mt-Tk\",\"mt-Atp8\",\"mt-Atp6\",\"mt-Co3\",\"mt-Tg\",\"mt-Nd3\",\"mt-Tr\",\"mt-Nd4\",\"mt-Th\",\"mt-Ts2\",\"mt-Tl2\",\"mt-Nd5\",\"mt-Nd6\",\"mt-Te\",\"mt-Cytb\",\"mt-Tt\",\"mt-Tp\",\"mt-Nd4l\",\"MT-ND6\",\"MT-CO2\",\"MT-CYB\",\"MT-ND2\",\"MT-ND5\",\"MT-CO1\",\"MT-ND3\",\"MT-ND4\",\"MT-ND1\",\"MT-ATP6\",\"MT-CO3\",\"MT-TL1\",\"MT-TF\",\"MT-TV\",\"MT-RNR2\",\"MT-TI\",\"MT-TQ\",\"MT-TM\",\"MT-TW\",\"MT-TA\",\"MT-TN\",\"MT-TC\",\"MT-TY\",\"MT-TS1\",\"MT-TD\",\"MT-TK\",\"MT-TG\",\"MT-TR\",\"MT-TH\",\"MT-TS2\",\"MT-TL2\",\"MT-TE\",\"MT-TT\",\"MT-TP\",\"MT-RNR1\",\"MT-ND4L\",\"MT-ATP8\"]);\n","import * as scran from \"scran.js\"; \nimport * as utils from \"./_utils.js\";\nimport * as inputs from \"./_inputs.js\";\nimport { mito } from \"./mito.js\";\n\nvar cache = {};\nvar parameters = {};\n\nexport var changed = false;\n\nfunction rawCompute(args) {\n    utils.freeCache(cache.raw);\n    var mat = inputs.fetchCountMatrix();\n\n    // TODO: add more choices.\n    var nsubsets = 1;\n    var subsets = utils.allocateCachedArray(mat.numberOfRows() * nsubsets, \"Uint8Array\", cache);\n    subsets.fill(0);\n\n    var gene_info = inputs.fetchGenes();\n    var sub_arr = subsets.array();\n    for (const [key, val] of Object.entries(gene_info)) {\n        if (args.use_mito_default) {\n            val.forEach((x, i) => {\n                if (mito.symbol.has(x) || mito.ensembl.has(x)) {\n                    sub_arr[i] = 1;\n                }\n            });\n        } else {\n            var lower_mito = args.mito_prefix.toLowerCase();\n            val.forEach((x, i) => {\n                if(x.toLowerCase().startsWith(lower_mito)) {\n                    sub_arr[i] = 1;\n                }\n            });\n        }\n    }\n\n    var mat = inputs.fetchCountMatrix();\n\n    cache.raw = scran.computePerCellQCMetrics(mat, subsets);\n    delete cache.reloaded;\n    return;\n}\n\nfunction fetchResults() {\n    var data = {};\n    if (\"reloaded\" in cache) {\n        var qc_output = cache.reloaded;\n        data.sums = qc_output.sums.slice();\n        data.detected = qc_output.detected.slice();\n        data.proportion = qc_output.proportion.slice();\n    } else {\n        var qc_output = cache.raw;\n        data.sums = qc_output.sums();\n        data.detected = qc_output.detected();\n        data.proportion = qc_output.subsetProportions(0);\n    }\n    return data;\n}\n\nexport function compute(args) {\n    if (!inputs.changed && !utils.changedParameters(parameters, args)) {\n        changed = false;\n    } else {\n        rawCompute(args);\n        parameters = args;\n        changed = true;\n    }\n    return;\n}\n\nexport function results() {\n    var data = fetchResults();\n\n    var ranges = {};\n    ranges.sums = utils.computeRange(data.sums);\n    ranges.detected = utils.computeRange(data.detected);\n    ranges.proportion = utils.computeRange(data.proportion);\n\n    return { \n        \"data\": data, \n        \"ranges\": ranges \n    };\n}\n\nexport function serialize() {\n    return {\n      \"parameters\": parameters,\n      \"contents\": fetchResults()\n    };\n}\n\nexport function unserialize(saved) {\n    /* TODO: reconstutite a fully-formed QCMetrics object so that\n     * fetchQCMetrics() doesn't have to recompute it.\n     */\n    parameters = saved.parameters;\n    cache.reloaded = saved.contents;\n    return;\n}\n\nexport function fetchQCMetrics() {\n    if (\"reloaded\" in cache) {\n        rawCompute();\n    }\n    return cache.raw;\n}\n\nexport function fetchSums({ unsafe = true } = {}) {\n    if (\"reloaded\" in cache) {\n        return cache.reloaded.sums;\n    } else {\n        // Unsafe, because we're returning a raw view into the Wasm heap,\n        // which might be invalidated upon further allocations.\n        return cache.raw.sums({ copy: !unsafe });\n    }\n}\n","import * as scran from \"scran.js\"; \nimport * as utils from \"./_utils.js\";\nimport * as metrics from \"./_qc_metrics.js\";\nimport * as wa from \"wasmarrays.js\";\n\nvar cache = {};\nvar parameters = {};\n\nexport var changed = false;\n\nexport function compute(args) {\n    if (!metrics.changed && !utils.changedParameters(parameters, args)) {\n        changed = false;\n    } else {\n        utils.freeCache(cache.raw);\n        var stats = metrics.fetchQCMetrics();\n\n        cache.raw = scran.computePerCellQCFilters(stats, { numberOfMADs: args.nmads });\n\n        utils.freeReloaded(cache);\n        changed = true;\n        parameters = args;\n    }\n    return;\n}\n\nexport function results() {\n    let data;\n    if (\"reloaded\" in cache) {\n        data = {\n            \"sums\": cache.reloaded.sums,\n            \"detected\": cache.reloaded.detected,\n            \"proportion\": cache.reloaded.proportion\n        };\n    } else {\n        var obj = cache.raw;\n        data = {\n            \"sums\": obj.thresholdsSums()[0],\n            \"detected\": obj.thresholdsDetected()[0],\n            \"proportion\": obj.thresholdsSubsetProportions(0)[0] // TODO: generalize...\n        };\n    }\n    return data;\n}\n\nexport function serialize() {\n    var contents = results();\n    contents.discards = fetchDiscards();\n    return {\n        \"parameters\": parameters,\n        \"contents\": contents\n    };\n}\n\nexport function unserialize(saved) {\n    parameters = saved.parameters;\n\n    utils.freeReloaded(cache);\n    cache.reloaded = saved.contents;\n\n    var tmp = scran.createUint8WasmArray(cache.reloaded.discards.length);\n    tmp.set(cache.reloaded.discards);\n    cache.reloaded.discards = tmp;\n    \n    return;\n}\n\nexport function fetchDiscardsAsWasmArray() {\n    if (\"reloaded\" in cache) {\n        return cache.reloaded.discards;        \n    } else {\n        return cache.raw.discardOverall({ copy: \"view\" });\n    }\n}\n\nexport function fetchDiscards({ unsafe = false } = {}) {\n    var out;\n    if (\"reloaded\" in cache) {\n        out = cache.reloaded.discards.array();\n    } else {\n        out = cache.raw.discardOverall();\n    }\n\n    if (unsafe) {\n        // Unsafe, because we're returning a raw view into the Wasm heap,\n        // which might be invalidated upon further allocations.\n        return out;\n    } else {\n        return out.slice();\n    }\n}\n","import * as scran from \"scran.js\"; \nimport * as utils from \"./_utils.js\";\nimport * as inputs from \"./_inputs.js\";\nimport * as thresholds from \"./_qc_thresholds.js\";\n\nvar cache = {};\nvar parameters = {};\n\nexport var changed = false;\n\nfunction rawCompute() {\n    utils.freeCache(cache.matrix);\n    var mat = inputs.fetchCountMatrix();\n\n    var disc = thresholds.fetchDiscardsAsWasmArray();\n    cache.matrix = scran.filterCells(mat, disc);\n\n    delete cache.reloaded;\n    return;\n}\n\nexport function compute(args) {\n    if (!inputs.changed && !thresholds.changed && !utils.changedParameters(parameters, args)) {\n        changed = false;\n    } else {\n        rawCompute();\n        parameters = args;\n        changed = true;\n    }\n    return;\n}\n   \nexport function results() {\n    return {\n      \"retained\": fetchRetained()\n    };\n}\n\nexport function serialize() {\n    return {\n        \"parameters\": parameters,\n        \"contents\": results()\n    };\n}\n\nexport function unserialize(saved) {\n    parameters = saved.parameters;\n    cache.reloaded = saved.contents;\n\n    // Precomputing this for easier retrieval later.\n    var discards = thresholds.fetchDiscards({ unsafe: true });\n    var retained = 0;\n    for (const i of discards) {\n        if (i == 0) {\n            retained++;\n        }\n    }\n    cache.reloaded.retained = retained;\n    return;\n}\n\nexport function fetchFilteredMatrix() {\n    if (\"reloaded\" in cache) {\n        rawCompute();\n    }\n    return cache.matrix;    \n}\n\nexport function fetchRetained() {\n    if (\"reloaded\" in cache) {\n        return cache.reloaded.retained;\n    } else {\n        return cache.matrix.numberOfColumns();\n    }\n}\n","import * as scran from \"scran.js\"; \nimport * as utils from \"./_utils.js\";\nimport * as thresholds from \"./_qc_thresholds.js\";\nimport * as filter from \"./_qc_filter.js\";\nimport * as metrics from \"./_qc_metrics.js\";\n\nvar cache = {};\nvar parameters = {};\n\nexport var changed = false;\n\nfunction rawCompute() {\n    var mat = filter.fetchFilteredMatrix();\n    var buffer = utils.allocateCachedArray(mat.numberOfColumns(), \"Float64Array\", cache);\n\n    // Better not have any more allocations in between now and filling of size_factors!\n    var sums = metrics.fetchSums({ unsafe: true });\n    var discards = thresholds.fetchDiscards({ unsafe: true });\n\n    // Reusing the totals computed earlier.\n    var size_factors = buffer.array();\n    var j = 0;\n    for (var i = 0; i < discards.length; ++i) {\n        if (!discards[i]) {\n            size_factors[j] = sums[i];\n            j++;\n        }\n    }\n\n    if (j != mat.numberOfColumns()) {\n        throw \"normalization and filtering are not in sync\";\n    }\n\n    utils.freeCache(cache.matrix);\n    cache.matrix = scran.logNormCounts(mat, { sizeFactors: buffer });\n\n    delete cache.reloaded;\n    return;\n}\n\nexport function compute(args) {\n    if (!metrics.changed && !filter.changed && !utils.changedParameters(parameters, args)) {\n        changed = false;\n    } else {\n        rawCompute();\n        parameters = args;\n        changed = true;\n    }\n    return;\n}\n\nexport function results() {\n    return {};\n}\n\nexport function serialize() {\n    return {\n        \"parameters\": parameters,\n        \"contents\": results()\n    };\n}\n\nexport function unserialize(saved) {\n    parameters = saved.parameters;\n    cache.reloaded = saved.contents;\n    return;\n}\n\nexport function fetchNormalizedMatrix() {\n    if (\"reloaded\" in cache) {\n        rawCompute();\n    }\n    return cache.matrix;\n}\n\nexport function fetchExpression(index) {\n    var mat = fetchNormalizedMatrix();\n    var buffer = utils.allocateCachedArray(mat.numberOfColumns(), \"Float64Array\", cache); // re-using the buffer.\n    mat.row(index, { buffer: buffer });\n    return buffer.slice();\n}\n","import * as scran from \"scran.js\"; \nimport * as utils from \"./_utils.js\";\nimport * as normalization from \"./_normalization.js\";\n  \nvar cache = {};\nvar parameters = {};\n\nexport var changed = false;\n\nfunction spawnStats() {\n    var model_output = cache.raw;\n    return {\n        \"means\": model_output.means(),\n        \"vars\": model_output.variances(),\n        \"fitted\": model_output.fitted(),\n        \"resids\": model_output.residuals()\n    };\n}\n\nexport function compute(args) {\n    if (!normalization.changed && !utils.changedParameters(parameters, args)) {\n        changed = false;\n    } else {\n        var mat = normalization.fetchNormalizedMatrix();\n        cache.raw = scran.modelGeneVar(mat, { span: args.span });\n\n        cache.sorted_residuals = cache.raw.residuals().slice(); // a separate copy.\n        cache.sorted_residuals.sort();\n\n        parameters = args;\n        delete cache.reloaded;\n        changed = true;\n    }\n    return;\n}\n\nexport function results() {\n    if (\"reloaded\" in cache) {\n        return {\n            \"means\": cache.reloaded.means.slice(),\n            \"vars\": cache.reloaded.vars.slice(),\n            \"fitted\": cache.reloaded.fitted.slice(),\n            \"resids\": cache.reloaded.resids.slice()\n        };\n    } else {\n        return spawnStats();\n    }\n}\n\nexport function serialize() {\n    return { \n        \"parameters\": parameters,\n        \"contents\": results()\n    };\n}\n\nexport function unserialize(saved) {\n    parameters = saved.parameters;\n    cache.reloaded = saved.contents;\n    cache.sorted_residuals = cache.reloaded.resids.slice();\n    cache.sorted_residuals.sort();\n    return;\n}\n\nexport function fetchSortedResiduals() {\n    return cache.sorted_residuals;\n}\n\nexport function fetchResiduals({ unsafe = false } = {}) {\n    if (\"reloaded\" in cache) {\n        return cache.reloaded.resids;\n    } else {\n        return cache.raw.residuals({ copy: !unsafe });\n    }\n}\n","import * as scran from \"scran.js\";\nimport * as utils from \"./_utils.js\";\nimport * as normalization from \"./_normalization.js\";\nimport * as variance from \"./_model_gene_var.js\";\nimport * as wa from \"wasmarrays.js\";\n\nvar cache = {};\nvar parameters = {};\n\nexport var changed = false;\n\nfunction fetchPCsAsWasmArray() {\n    if (\"reloaded\" in cache) {\n        return cache.reloaded.pcs;\n    } else {\n        return cache.raw.principalComponents({ copy: \"view\" });\n    }\n}\n\nexport function compute(args) {\n    if (!normalization.changed && !variance.changed && !utils.changedParameters(parameters, args)) {\n        changed = false;\n    } else {\n        // Choosing the highly variable genes.\n        var sorted_resids = variance.fetchSortedResiduals();\n        var threshold_at = sorted_resids[sorted_resids.length - args.num_hvgs];\n\n        var mat = normalization.fetchNormalizedMatrix();\n        var sub = utils.allocateCachedArray(mat.numberOfRows(), \"Uint8Array\", cache);\n        var unsorted_resids = variance.fetchResiduals({ unsafe: true });\n        sub.array().forEach((element, index, array) => {\n            array[index] = unsorted_resids[index] >= threshold_at;\n        });\n\n        // Actually performing the PCA.\n        utils.freeCache(cache.raw);\n        cache.raw = scran.runPCA(mat, { features: sub, numberOfPCs: args.num_pcs });\n\n        utils.freeReloaded(cache);\n        changed = true;\n        parameters = args;\n    }\n    return;\n}\n\nexport function results() {\n    var var_exp;\n\n    if (\"reloaded\" in cache) {\n        var_exp = cache.reloaded.var_exp.slice();\n    } else {\n        var pca_output = cache.raw;\n        var_exp = pca_output.varianceExplained();\n        var total_var = pca_output.totalVariance();\n        var_exp.forEach((x, i) => {\n            var_exp[i] = x/total_var;\n        });\n    }\n\n    return { \"var_exp\": var_exp };\n}\n\nexport function serialize() {\n    var to_save = results();\n    to_save.pcs = fetchPCsAsWasmArray().slice();\n    return {\n      \"parameters\": parameters,\n      \"contents\": to_save\n    };\n}\n \nexport function unserialize(saved) {\n    parameters = saved.parameters;\n\n    utils.freeReloaded(cache);\n    cache.reloaded = saved.contents;\n\n    var tmp = scran.createFloat64WasmArray(cache.reloaded.pcs.length);\n    tmp.set(cache.reloaded.pcs);\n    cache.reloaded.pcs = tmp;\n    return;\n}\n\nexport function fetchPCs() {\n    var pcs = fetchPCsAsWasmArray();\n    return {\n        \"pcs\": pcs,\n        \"num_pcs\": parameters.num_pcs,\n        \"num_obs\": pcs.length / parameters.num_pcs\n    };\n}\n","import * as scran from \"scran.js\";\nimport * as utils from \"./_utils.js\";\nimport * as pca from \"./_pca.js\";\n\nvar cache = {};\nvar parameters = {};\n\nexport var changed = false;\n\nexport function rawCompute(args) {\n    utils.freeCache(cache.raw);\n    var pcs = pca.fetchPCs();\n    cache.raw = scran.buildNeighborSearchIndex(pcs.pcs, { numberOfDims: pcs.num_pcs, numberOfCells: pcs.num_obs });\n    delete cache.reloaded;\n    return;\n}\n\nexport function compute(args) {\n    if (!pca.changed && !utils.changedParameters(parameters, args)) {\n        changed = false;\n    } else {\n        rawCompute(args);\n        parameters = args;\n        changed = true;\n    }\n    return;\n}\n\nexport function results() {\n    return {};\n}\n\nexport function serialize() {\n    return {\n      \"parameters\": parameters,\n      \"contents\": results()\n    };\n}\n\nexport function unserialize(saved) {\n    parameters = saved.parameters;\n    cache.reloaded = saved.contents;\n    return;\n}\n\nexport function fetchIndex() {\n    if (\"reloaded\" in cache) {\n        rawCompute(parameters);\n    }\n    return cache.raw;\n}\n","import * as scran from \"scran.js\";\nimport * as utils from \"./_utils.js\";\nimport * as index from \"./_neighbor_index.js\";\n\nvar cache = {};\nvar parameters = {};\n\nexport var changed = false;\n\nexport function rawCompute(args) {\n    utils.freeCache(cache.raw);\n    var nn_index = index.fetchIndex();\n    cache.raw = scran.findNearestNeighbors(nn_index, args.k);\n    delete cache.reloaded;\n    return;\n}\n\nexport function compute(args) {\n    // Setting the existing cluster_method to the new method so that we don't\n    // pick up changes in the method in the changedParameters() call. This aims\n    // to preserve the state if only the clustering method choice changed, such\n    // that a user avoids recomputation when they switch back to this method.\n    let method = args.cluster_method;\n    delete args.cluster_method;\n\n    if (changed !== null && !index.changed && !utils.changedParameters(parameters, args)) {\n        changed = false;\n\n    } else if (!method.startsWith(\"snn_\")) {\n        changed = null; // neither changed or unchanged, just skipped.\n        utils.freeCache(cache.raw); // freeing some memory as a courtesy.\n        delete cache.reloaded;\n        parameters = args;\n\n    } else {\n        rawCompute(args);\n        parameters = args;\n        changed = true;\n    }\n\n    return;\n}\n\nexport function results() {\n    return {};\n}\n\nexport function serialize() {\n    let output = { \n        \"parameters\": parameters\n    };\n\n    if (changed === null) {\n        output.contents = null;\n    } else {\n        output.contents = results();\n    }\n    \n    return output;\n};\n\nexport function unserialize(saved) {\n    parameters = saved.parameters;\n\n    if (saved.contents !== null) {\n        cache.reloaded = saved.contents;\n    } else {\n        changed = null;\n    }\n\n    return;\n}\n\nexport function fetchNeighbors() {\n    if (\"reloaded\" in cache) {\n        rawCompute(parameters);\n    }\n    return cache.raw;\n}\n","import * as scran from \"scran.js\";\nimport * as neighbors from \"./_snn_neighbors.js\";\nimport * as utils from \"./_utils.js\";\n\nvar cache = {};\nvar parameters = {};\n\nexport var changed = false;\n\nfunction rawCompute(args) {\n    utils.freeCache(cache.raw);\n    var res = neighbors.fetchNeighbors();\n    cache.raw = scran.buildSNNGraph(res, { scheme: args.scheme });\n    delete cache.reloaded;\n    return;\n}\n\nexport function compute(args) {\n    if (neighbors.changed === null) { // If my upstream was skipped, then I am also skipped.\n        changed = null;\n        utils.freeCache(cache.raw); // Clearing out memory as a courtesy.\n        delete cache.reloaded;\n        parameters = args;\n\n    } else if (changed !== null && !neighbors.changed && !utils.changedParameters(parameters, args)) {\n        changed = false;\n\n    } else {\n        rawCompute(args);\n        parameters = args;\n        changed = true;\n    }\n\n    return;\n}\n\nexport function results() {\n    return {};\n}\n\nexport function serialize() {\n    let output = { \n        \"parameters\": parameters\n    };\n\n    if (changed === null) {\n        output.contents = null;\n    } else {\n        output.contents = results();\n    }\n\n    return output;\n}\n\nexport function unserialize(saved) {\n    parameters = saved.parameters;\n\n    if (saved !== undefined) {\n        cache.reloaded = saved.contents;\n    } else {\n        changed = null;\n    }\n\n    return;\n}\n\nexport function fetchGraph() {\n    if (\"reloaded\" in cache) {\n        rawCompute(parameters);\n    }\n    return cache.raw;\n}\n","import * as scran from \"scran.js\"; \nimport * as utils from \"./_utils.js\";\nimport * as graph from \"./_snn_graph.js\";\n\nvar cache = {};\nvar parameters = {};\n\nexport var changed = false;\n\nexport function fetchClustersAsWasmArray() {\n    if (\"reloaded\" in cache) {\n        return cache.reloaded.clusters;\n    } else {\n        return cache.raw.membership({ copy: \"view\" });\n    }\n}\n\nexport function compute(args) {\n    if (graph.changed === null) { // If my upstream was skipped, then I am also skipped.\n        changed = null;\n        utils.freeCache(cache.raw); // Also freeing some memory as a courtesy.\n        utils.freeReloaded(cache);\n        parameters = args;\n\n    } else if (changed !== null && !graph.changed && !utils.changedParameters(parameters, args)) {\n        changed = false;\n        \n    } else {\n        utils.freeCache(cache.raw);\n        var g = graph.fetchGraph();\n        cache.raw = scran.clusterSNNGraph(g, { resolution: args.resolution });\n\n        parameters = args;\n        changed = true;\n        utils.freeReloaded(cache);\n    }\n\n    return;\n}\n\nexport function results() {\n    // Cluster IDs will be passed to main thread in \n    // choose_clustering, so no need to do it here.\n    return {};\n}\n\nexport function serialize() {\n    let output = { \n        \"parameters\": parameters\n    };\n\n    if (changed === null) {\n        output.contents = null;\n    } else {\n        output.contents = {\n            \"clusters\": fetchClustersAsWasmArray().slice()\n        };\n    }\n\n    return output;\n}\n\nexport function unserialize(saved) {\n    parameters = saved.parameters;\n\n    if (saved.contents !== null) {\n        utils.freeReloaded(cache);\n        cache.reloaded = saved.contents;\n\n        var out = scran.createInt32WasmArray(cache.reloaded.clusters.length);\n        out.set(cache.reloaded.clusters);\n        cache.reloaded.clusters = out;\n    } else {\n        changed = null;\n    }\n\n    return;\n}\n","import * as scran from \"scran.js\"; \nimport * as utils from \"./_utils.js\";\nimport * as pca from \"./_pca.js\";\n\nvar cache = {};\nvar parameters = {};\n\nexport var changed = false;\n\nexport function fetchClustersAsWasmArray() {\n    if (\"reloaded\" in cache) {\n        return cache.reloaded.clusters;\n    } else {\n        return cache.raw.clusters({ copy: \"view\" });\n    }\n}\n\nexport function compute(args) {\n    // Removing the cluster_method so that we don't pick up changes in the\n    // method in the changedParameters() call. This aims to preserve the state\n    // if only the clustering method choice changed, such that a user avoids\n    // recomputation when they switch back to this method.\n    let method = args.cluster_method;\n    delete args.cluster_method;\n\n    if (changed !== null && !pca.changed && !utils.changedParameters(parameters, args)) {\n        changed = false;\n\n    } else if (method !== \"kmeans\") {\n        changed = null; // neither changed or unchanged, just skipped.\n        utils.freeCache(cache.raw); // free up some memory as a courtesy.\n        utils.freeReloaded(cache);\n        parameters = args;\n\n    } else {\n        utils.freeCache(cache.raw);\n        var pcs = pca.fetchPCs();\n        cache.raw = scran.clusterKmeans(pcs.pcs, args.k, { numberOfDims: pcs.num_pcs, numberOfCells: pcs.num_obs, initMethod: \"pca-part\" });\n        parameters = args;\n        changed = true;\n        utils.freeReloaded(cache);\n    }\n\n    return;\n}\n\nexport function results() {\n    // Cluster IDs will be passed to main thread in \n    // choose_clustering, so no need to do it here.\n    return {};\n}\n\nexport function serialize() {\n    let output = { \n        \"parameters\": parameters\n    };\n\n    if (changed === null) {\n        output.contents = null;\n    } else {\n        output.contents = {\n            \"clusters\": fetchClustersAsWasmArray().slice()\n        };\n    }\n\n    return output;\n}\n\nexport function unserialize(saved) {\n    parameters = saved.parameters;\n\n    if (saved.contents !== null) {\n        utils.freeReloaded(cache); // free anything that might have been there previously.\n        cache.reloaded = saved.contents;\n\n        var out = scran.createInt32WasmArray(cache.reloaded.clusters.length);\n        out.set(cache.reloaded.clusters);\n        cache.reloaded.clusters = out;\n    } else {\n        changed = null;\n    }\n\n    return;\n}\n","import * as scran from \"scran.js\";\nimport * as utils from \"./_utils.js\";\nimport * as snn_cluster from \"./_snn_cluster.js\";\nimport * as kmeans_cluster from \"./_kmeans_cluster.js\";\n\nvar cache = {};\nvar parameters = {};\n\nexport var changed = false;\n\n/** Standard functions **/\nexport function compute(args) {\n    changed = true;\n    \n    if (!utils.changedParameters(parameters, args)) {\n        if (args.method == \"snn_graph\") {\n            if (!snn_cluster.changed) {\n                changed = false;\n            }\n        } else if (args.method == \"kmeans\") {\n            if (!kmeans_cluster.changed) {\n                changed = false;\n            }\n        }\n    }\n\n    if (changed) {\n        delete cache.reloaded;\n        parameters = args;\n        changed = true;\n    }\n    \n    return;\n}\n\nexport function results() {\n    var clusters = fetchClustersAsWasmArray();\n    return { \"clusters\": clusters.slice() };\n}\n\nexport function serialize() {\n    // No need to serialize the cluster IDs,\n    // as this is done for each step.\n    return {\n        \"parameters\": parameters,\n        \"contents\": {}\n    };\n}\n\nexport function unserialize(saved) {\n    parameters = saved.parameters;\n    cache.reloaded = saved.contents;\n    return;\n}\n\n/** Non-standard functions **/\nexport function fetchClustersAsWasmArray() {\n    if (parameters.method == \"snn_graph\") {\n        return snn_cluster.fetchClustersAsWasmArray();\n    } else if (parameters.method == \"kmeans\") {\n        return kmeans_cluster.fetchClustersAsWasmArray();\n    }\n}\n","import * as scran from \"scran.js\";\nimport * as index from \"./_neighbor_index.js\";\nimport * as utils from \"./_utils.js\";\n\nexport function computeNeighbors(k) {\n    var nn_index = index.fetchIndex();\n\n    var output = { \"num_obs\": nn_index.numberOfCells() };\n    var results = null, rbuf = null, ibuf = null, dbuf = null;\n    try {\n        results = scran.findNearestNeighbors(nn_index, k);\n\n        rbuf = scran.createInt32WasmArray(results.numberOfCells());\n        ibuf = scran.createInt32WasmArray(results.size());\n        dbuf = scran.createFloat64WasmArray(results.size());\n\n        results.serialize({ runs: rbuf, indices: ibuf, distances: dbuf });\n        output[\"size\"] = results.size();\n        output[\"runs\"] = rbuf.array().slice();\n        output[\"indices\"] = ibuf.array().slice();\n        output[\"distances\"] = dbuf.array().slice();\n\n    } finally {\n        if (results !== null) {\n            results.free();\n        }\n        if (rbuf !== null) {\n            rbuf.free();\n        }\n        if (ibuf !== null) {\n            ibuf.free();\n        }\n        if (dbuf !== null) {\n            dbuf.free();\n        }\n    }\n\n    return output;\n}\n\nexport function sendTask(worker, payload, cache, transferrable = []) {\n    var i = cache.counter;\n    var p = new Promise((resolve, reject) => {\n        cache.promises[i] = { \"resolve\": resolve, \"reject\": reject };\n    });\n    cache.counter++;\n    payload.id = i;\n    worker.postMessage(payload, transferrable);\n    return p;\n}\n\nexport function initializeWorker(worker, cache) {\n    worker.onmessage = function (msg) {\n        var type = msg.data.type;\n        if (type.endsWith(\"_iter\")) {\n            postMessage({\n                \"type\": type,\n                \"resp\": {\n                    \"x\": msg.data.x,\n                    \"y\": msg.data.y,\n                    \"iteration\": msg.data.iteration\n                },\n            }, [msg.data.x.buffer, msg.data.y.buffer]);\n            return;\n        }\n  \n        var id = msg.data.id;\n        var fun = cache.promises[id];\n        if (type == \"error\") {\n            fun.reject(msg.data.error);\n        } else {\n            fun.resolve(msg.data.data);\n        }\n        delete cache.promises[id];\n    };\n    return sendTask(worker, { \"cmd\": \"INIT\" }, cache);\n}\n\nexport function runWithNeighbors(worker, args, nn_out, cache) {\n    var run_msg = {\n        \"cmd\": \"RUN\",\n        \"params\": args \n    };\n\n    var transferrable = [];\n    if (nn_out !== null) {\n        run_msg.neighbors = nn_out;\n        utils.extractBuffers(nn_out, transferrable);\n    }\n\n    return sendTask(worker, run_msg, cache, transferrable);\n}\n\nexport function retrieveCoordinates(worker, cache) {\n    if (\"reloaded\" in cache) {\n        // Buffers are transferred to the main thread, so we need to make sure we\n        // clone it so that we don't lose our master copy.\n        var copy = { ...cache.reloaded };\n        copy.x = copy.x.slice();\n        copy.y = copy.y.slice();\n        return new Promise(resolve => resolve(copy));\n    } else {\n        return cache.run.then(x => sendTask(worker, { \"cmd\": \"FETCH\" }, cache));\n    }\n}\n","import * as scran from \"scran.js\";\nimport * as vizutils from \"./_utils_viz_parent.js\";\nimport * as index from \"./_neighbor_index.js\";\nimport * as utils from \"./_utils.js\";\n\nvar cache = { \"counter\": 0, \"promises\": {} };\nvar parameters = {};\nvar worker = null;\n\nexport function initialize() {\n    worker = new Worker(new URL(\"./tsne.worker.js\", import.meta.url), { type: \"module\" });\n    return vizutils.initializeWorker(worker, cache);\n}\n\nexport var changed = false;\n\nfunction core(args, reneighbor) {\n    var nn_out = null;\n    if (reneighbor) {\n        var k = scran.perplexityToNeighbors(args.perplexity);\n        nn_out = vizutils.computeNeighbors(k);\n    }\n\n    // This returns a promise but the message itself is sent synchronously,\n    // which is important to ensure that the t-SNE runs in its worker in\n    // parallel with other analysis steps. Do NOT put the runWithNeighbors\n    // call in a .then() as this may defer the message sending until \n    // the current thread is completely done processing.\n    cache.run = vizutils.runWithNeighbors(worker, args, nn_out, cache);\n    return;\n}\n\nexport function compute(args) {\n    if (!index.changed && !utils.changedParameters(parameters, args)) {\n        changed = false;\n        return;\n    }\n\n    var reneighbor = index.changed || utils.changedParameters(parameters.perplexity, args.perplexity);\n    core(args, reneighbor);\n\n    parameters = args;\n    delete cache.reloaded;\n    changed = true;\n}\n\n\nexport function results() {\n    return vizutils.retrieveCoordinates(worker, cache);\n}\n\nexport async function serialize() {\n    var contents = await vizutils.retrieveCoordinates(worker, cache);\n    return {\n        \"parameters\": parameters,\n        \"contents\": contents\n    };\n}\n\nexport function unserialize(saved) {\n    parameters = saved.parameters;\n    cache.reloaded = saved.contents;\n    return;\n}\n\nexport function animate() {\n    if (\"reloaded\" in cache) {\n        var param_copy = { ...parameters };\n        param_copy.animate = true;\n        core(param_copy, true);\n        delete cache.reloaded;\n\n        // Mimicking the response from the re-run.\n        return cache.run\n            .then(contents => {\n                return {\n                    \"type\": \"tsne_rerun\",\n                    \"data\": { \"status\": \"SUCCESS\" }\n                };\n            });\n    } else {\n        return vizutils.sendTask(worker, { \"cmd\": \"RERUN\" }, cache);\n    }\n}\n","import * as vizutils from \"./_utils_viz_parent.js\";\nimport * as index from \"./_neighbor_index.js\";\nimport * as utils from \"./_utils.js\";\n\nvar cache = { \"counter\": 0, \"promises\": {} };\nvar parameters = {};\nvar worker = null;\n\nexport function initialize() {\n    worker = new Worker(new URL(\"./umap.worker.js\", import.meta.url), { type: \"module\" });\n    cache.initialized = vizutils.initializeWorker(worker, cache);\n}\n\nexport var changed = false;\n\nfunction core(args, reneighbor) {\n    var nn_out = null;\n    if (reneighbor) {\n        nn_out = vizutils.computeNeighbors(args.num_neighbors);\n    }\n\n    // This returns a promise but the message itself is sent synchronously,\n    // which is important to ensure that the UMAP runs in its worker in\n    // parallel with other analysis steps. Do NOT put the runWithNeighbors\n    // call in a .then() as this may defer the message sending until \n    // the current thread is completely done processing.\n    cache.run = vizutils.runWithNeighbors(worker, args, nn_out, cache);\n    return;\n}\n\nexport function compute(args) {\n    if (!index.changed && !utils.changedParameters(parameters, args)) {\n        changed = false;\n        return;\n    }\n\n    var reneighbor = index.changed || utils.changedParameters(parameters.num_neighbors, args.num_neighbors);\n    core(args, reneighbor);\n\n    parameters = args;\n    delete cache.reloaded;\n    changed = true;\n}\n\nexport function results() {\n    return vizutils.retrieveCoordinates(worker, cache);\n}\n\nexport async function serialize() {\n    var contents = await vizutils.retrieveCoordinates(worker, cache);\n    return {\n        \"parameters\": parameters,\n        \"contents\": contents\n    };\n}\n\nexport function unserialize(saved) {\n    parameters = saved.parameters;\n    cache.reloaded = saved.contents;\n    return;\n}\n\nexport function animate() {\n    if (\"reloaded\" in cache) {\n        var param_copy = { ...parameters };\n        param_copy.animate = true;\n        core(param_copy, true);\n        delete cache.reloaded;\n  \n        // Mimicking the response from the re-run.\n        return cache.run\n            .then(contents => { \n                return {\n                    \"type\": \"umap_rerun\",\n                    \"data\": { \"status\": \"SUCCESS\" }\n                };\n            });\n    } else {\n        return vizutils.sendTask(worker, { \"cmd\": \"RERUN\" }, cache);\n    }\n}\n","export function serializeGroupStats(obj, group) {\n    return {\n        \"means\": obj.means(group),\n        \"detected\": obj.detected(group),\n        \"lfc\": {\n            \"min\": obj.lfc(group, { summary: 0 }),\n            \"mean\": obj.lfc(group, { summary: 1 }),\n            \"min-rank\": obj.lfc(group, { summary: 4 })\n        },\n        \"delta_detected\": {\n            \"min\": obj.deltaDetected(group, { summary: 0 }),\n            \"mean\": obj.deltaDetected(group, { summary: 1 }),\n            \"min-rank\": obj.deltaDetected(group, { summary: 4 })\n        },\n        \"cohen\": {\n            \"min\": obj.cohen(group, { summary: 0 }),\n            \"mean\": obj.cohen(group, { summary: 1 }),\n            \"min-rank\": obj.cohen(group, { summary: 4 })\n        },\n        \"auc\": {\n            \"min\": obj.auc(group, { summary: 0 }),\n            \"mean\": obj.auc(group, { summary: 1 }),\n            \"min-rank\": obj.auc(group, { summary: 4 })\n        }\n    };\n}\n\nfunction useReloaded(reloaded) {\n    return reloaded !== undefined;\n}\n\n/*\n * Helper function to retrieve marker statistics for plotting.\n * This is used both for cluster-specific markers as well as the\n * DE genes that are computed for a custom selection vs the rest.\n */\nexport function fetchGroupResults(results, reloaded, rank_type, group) {\n    if (!rank_type || rank_type === undefined) {\n        rank_type = \"cohen-min-rank\";\n    }\n    var use_reloaded = useReloaded(reloaded);\n\n    var ordering;\n    {\n        // Choosing the ranking statistic. Do NOT do any Wasm allocations\n        // until 'ranking' is fully consumed!\n        let ranking;\n        let increasing = false;\n      \n        if (use_reloaded) {\n            let summary = \"mean\";\n            if (rank_type.match(/-min$/)) {\n                summary = \"min\";\n            } else if (rank_type.match(/-min-rank$/)) {\n                increasing = true;\n                summary = \"min-rank\";\n            }\n      \n            let effect;\n            if (rank_type.match(/^cohen-/)) {\n                effect = \"cohen\";\n            } else if (rank_type.match(/^auc-/)) {\n                effect = \"auc\";\n            } else if (rank_type.match(/^lfc-/)) {\n                effect = \"lfc\";\n            } else if (rank_type.match(/^delta-d-/)) {\n                effect = \"delta_detected\";\n            } else {\n                throw \"unknown rank type '\" + rank_type + \"'\";\n            }\n      \n            ranking = reloaded[group][effect][summary];\n        } else {\n            let index = 1;\n            if (rank_type.match(/-min$/)) {\n                index = 0;\n            } else if (rank_type.match(/-min-rank$/)) {\n                increasing = true;\n                index = 4;\n            }\n\n            if (rank_type.match(/^cohen-/)) {\n                ranking = results.cohen(group, { summary: index, copy: false });\n            } else if (rank_type.match(/^auc-/)) {\n                ranking = results.auc(group, { summary: index, copy: false });\n            } else if (rank_type.match(/^lfc-/)) {\n                ranking = results.lfc(group, { summary: index, copy: false });\n            } else if (rank_type.match(/^delta-d-/)) {\n                ranking = results.deltaDetected(group, { summary: index, copy: false });\n            } else {\n                throw \"unknown rank type '\" + rank_type + \"'\";\n            }\n        }\n      \n        // Computing the ordering based on the ranking statistic.\n        ordering = new Int32Array(ranking.length);\n        for (var i = 0; i < ordering.length; i++) {\n            ordering[i] = i;\n        }\n        if (increasing) {\n            ordering.sort((f, s) => (ranking[f] - ranking[s]));\n        } else {\n            ordering.sort((f, s) => (ranking[s] - ranking[f]));\n        }\n    }\n  \n    // Apply that ordering to each statistic of interest.\n    var reorder = function(stats) {\n        var thing = new Float64Array(stats.length);\n        for (var i = 0; i < ordering.length; i++) {\n            thing[i] = stats[ordering[i]];\n        }\n        return thing;\n    };\n  \n    var stat_detected, stat_mean, stat_lfc, stat_delta_d;\n    if (use_reloaded) {\n        var current = reloaded[group];\n        stat_mean = reorder(current.means);\n        stat_detected = reorder(current.detected);\n        stat_lfc = reorder(current.lfc[\"mean\"]);\n        stat_delta_d = reorder(current.delta_detected[\"mean\"]);\n    } else {\n        stat_detected = reorder(results.detected(group, { copy: false }));\n        stat_mean = reorder(results.means(group, { copy: false }));\n        stat_lfc = reorder(results.lfc(group, { summary: 1, copy: false }));\n        stat_delta_d = reorder(results.deltaDetected(group, { summary: 1, copy: false }));\n    }\n  \n    return {\n        \"ordering\": ordering,\n        \"means\": stat_mean,\n        \"detected\": stat_detected,\n        \"lfc\": stat_lfc,\n        \"delta_detected\": stat_delta_d\n    };\n}\n\n/* The functions below are dunked here instead of in _score_markers.js, mostly\n * to centralize the logic of how we distinguish between reloaded and computed\n * results.\n */\nexport function numberOfGroups(results, reloaded) {\n    if (useReloaded(reloaded)) {\n        return reloaded.length;\n    } else {\n        return results.numberOfGroups();\n    }\n}\n\nexport function fetchGroupMeans(results, reloaded, group, copy = true) {\n    if (useReloaded(reloaded)) {\n        return reloaded[group].means;\n    } else {\n        return results.means(group, { copy: copy });\n    }\n}\n","import * as scran from \"scran.js\"; \nimport * as utils from \"./_utils.js\";\nimport * as normalization from \"./_normalization.js\";\nimport * as choice from \"./_choose_clustering.js\";\nimport * as markers from \"./_utils_markers.js\";\n\nvar cache = {};\nvar parameters = {};\n\nexport var changed = false;\n\nexport function compute(args) {\n    if (!normalization.changed && !choice.changed && !utils.changedParameters(parameters, args)) {\n        changed = false;\n    } else {\n        utils.freeCache(cache.raw);\n        var mat = normalization.fetchNormalizedMatrix();\n        var clusters = choice.fetchClustersAsWasmArray();\n\n        cache.raw = scran.scoreMarkers(mat, clusters);\n\n        parameters = args;\n        delete cache.reloaded;\n        changed = true;\n    }\n    return;\n}\n\nexport function results() {\n    return {};\n}\n\nexport function serialize() {\n    var contents;\n    if (\"reloaded\" in cache) {\n        contents = cache.reloaded;\n    } else {\n        var contents = [];\n        var num = cache.raw.numberOfGroups();\n        for (var i = 0; i < num; i++) {\n            contents.push(markers.serializeGroupStats(cache.raw, i));\n        }\n    }\n    return {\n        \"parameters\": parameters,\n        \"contents\": contents\n    };\n}\n\nexport function unserialize(saved) {\n    parameters = saved.parameters;\n    cache.reloaded = saved.contents;\n    return;\n}\n\nexport function fetchGroupResults(rank_type, group) {\n    return markers.fetchGroupResults(cache.raw, cache.reloaded, rank_type, group); \n}\n\nexport function numberOfGroups() {\n    return markers.numberOfGroups(cache.raw, cache.reloaded);\n}\n\nexport function fetchGroupMeans(group, copy = true) {\n    return markers.fetchGroupMeans(cache.raw, cache.reloaded, group, copy);\n}\n","var DownloadsDB;\nvar init = null;\n\nexport function initialize() {\n    if (init === null) {\n        init = new Promise((resolve, reject) => {\n            // initialize database on worker creation\n            DownloadsDB = indexedDB.open(\"DownloadsDB\", 3);\n\n            DownloadsDB.onupgradeneeded = (e) => {\n                var DownloadsDBClient = e.target.result;\n\n                // Currently purging all existing stores when the version is updated.\n                // At some point we may add a more sophisticated upgrade mechanism.\n                try {\n                    DownloadsDBClient.deleteObjectStore(\"downloads\");\n                } catch (e) {}\n\n                DownloadsDBClient.createObjectStore(\"downloads\", { keyPath: 'url' });\n            };\n\n            DownloadsDB.onsuccess = () => {\n                resolve(null);\n            };\n\n            DownloadsDB.onerror = () => {\n                reject(\"failed to initialize DownloadsDB\");\n            };\n        });\n    }\n\n    return init;\n}\n\nexport async function list() {\n    await init;\n    let trans = DownloadsDB.result.transaction([\"downloads\"], \"readonly\");\n    let download_store = trans.objectStore(\"downloads\");\n    return download_store.getAllKeys();\n}\n\nexport async function get(url, params = null, force = false) {\n    await init;\n\n    if (!force) {\n        let trans = DownloadsDB.result.transaction([\"downloads\"], \"readonly\");\n        let download_store = trans.objectStore(\"downloads\");\n        var data_check = new Promise(resolve => {\n            var already = download_store.get(url);\n            already.onsuccess = function (event) {\n                if (already.result !== undefined) {\n                    resolve(already.result.payload);\n                } else {\n                    resolve(null);\n                }\n            };\n            already.onerror = function (event) {\n                resolve(null);\n            };\n        });\n\n        var found = await data_check;\n        if (found !== null) {\n            return found;\n        }\n    }\n\n    var req;\n    if (params == null) {\n        req = fetch(url);\n    } else {\n        req = fetch(url, params);\n    }\n\n    var res = await req;\n    if (!res.ok) {\n        throw \"failed to download '\" + url + \"' (\" + res.status + \")\";\n    }\n    var buffer = await res.arrayBuffer();\n\n    // Technically, this isn't quite right, because we need to close the read\n    // transaction before opening the write transaction; multiple queries to\n    // the same URL from different workers could cause multiple downloads if\n    // they each miss each other's read check. But oh well; the auto-commit\n    // of IDB transactions means that it's hard to do any better. (Specifically,\n    // we can't do an async fetch while the transaction is still open, because\n    // it just closes before the fetch is done.)\n    let trans = DownloadsDB.result.transaction([\"downloads\"], \"readwrite\");\n    let download_store = trans.objectStore(\"downloads\");\n    var data_saving = new Promise(resolve => {\n        var putrequest = download_store.put({ \"url\": url, \"payload\": buffer });\n        putrequest.onsuccess = function (event) {\n            resolve(true);\n        };\n        putrequest.onerror = function (event) {\n            resolve(false);\n        };\n    });\n\n    let success = await data_saving;\n    if (!success) {\n        throw \"failed to download resources for '\" + url + \"'\";\n    }\n\n    return buffer;\n}\n\nexport async function remove(url) {\n    await init;\n    let trans = DownloadsDB.result.transaction([\"downloads\"], \"readwrite\")\n    let download_store = trans.objectStore(\"downloads\");\n\n    var removal = new Promise(resolve => {\n        let request = download_store.delete(url);\n        request.onsuccess = function (event) {\n            resolve(true);\n        };\n        request.onerror = function (event) {\n            resolve(false);\n        };\n    });\n\n    return await removal;\n}\n","import * as scran from \"scran.js\";\nimport * as utils from \"./_utils.js\";\nimport * as inputs from \"./_inputs.js\";\nimport * as markers from \"./_score_markers.js\";\nimport * as downloads from \"./DownloadsDBHandler.js\";\nimport * as pako from \"pako\";\n\nvar cache = {};\nvar parameters = {};\n\nexport var changed = false;\n\nvar hs_loaded = {};\nvar mm_loaded = {};\nvar hs_references = {};\nvar mm_references = {};\n\nconst proxy = \"https://cors-proxy.aaron-lun.workers.dev\";\nconst hs_base = \"https://github.com/clusterfork/singlepp-references/releases/download/hs-latest\";\nconst mm_base = \"https://github.com/clusterfork/singlepp-references/releases/download/mm-latest\";\n\n// Try to figure out the best feature identifiers to use,\n// based on the highest confidence annotation.\nfunction chooseFeatures() {\n    let genes = inputs.fetchGenes();\n    let types = inputs.fetchGeneTypes();\n\n    let best_feature = null;\n    let best = null;\n    for (const [key, val] of Object.entries(types)) {\n        if (best === null) {\n            best_feature = key;\n            best = val;\n        } else if (val.confidence > best.confidence) {\n            best_feature = key;\n            best = val;\n        }\n    }\n\n    cache.features = genes[best_feature];\n    cache.feature_details = best;\n    return;\n}\n\n// TODO: consolidate this with _inputs.readDSVFromBuffer to eliminate the D3 dependency.\nfunction quickLineReader(buffer, compression = \"gz\") {\n    let txt = buffer;\n    if (compression == \"gz\") {\n        txt = pako.ungzip(buffer);\n    }\n\n    const dec = new TextDecoder();\n    let decoded = dec.decode(txt);\n\n    let lines = decoded.split(\"\\n\");\n    if (lines.length > 0 && lines[lines.length - 1] == \"\") { // ignoring the trailing newline.\n        lines.pop();\n    }\n\n    return lines;    \n}\n\nasync function getBuiltReference(name, species, rebuild) {\n    let base;\n    let references;\n    let preloaded;\n    if (species == \"human\") {\n        base = hs_base;\n        preloaded = hs_loaded;\n        references = hs_references;\n    } else {\n        base = mm_base;\n        preloaded = mm_loaded;\n        references = mm_references;\n    }\n\n    downloads.initialize();\n\n    if (!(name in preloaded)) {\n        let buffers = await Promise.all([\n            downloads.get(proxy + \"/\" + encodeURIComponent(base + \"/\" + name + \"_genes.csv.gz\")),\n            downloads.get(proxy + \"/\" + encodeURIComponent(base + \"/\" + name + \"_labels_fine.csv.gz\")),\n            downloads.get(proxy + \"/\" + encodeURIComponent(base + \"/\" + name + \"_label_names_fine.csv.gz\")),\n            downloads.get(proxy + \"/\" + encodeURIComponent(base + \"/\" + name + \"_markers_fine.gmt.gz\")),\n            downloads.get(proxy + \"/\" + encodeURIComponent(base + \"/\" + name + \"_matrix.csv.gz\"))\n        ]);\n\n        console.log(buffers);\n\n        let loaded;\n        try {\n            loaded = scran.loadLabelledReferenceFromBuffers(\n                new Uint8Array(buffers[4]), // rank matrix\n                new Uint8Array(buffers[3]), // markers\n                new Uint8Array(buffers[1])) // label per sample\n\n            let gene_lines = quickLineReader(new Uint8Array(buffers[0])); // gene names\n            let ensembl = [];\n            let symbol = [];\n            gene_lines.forEach(x => {\n                let fields = x.split(\",\");\n                ensembl.push(fields[0]);\n                symbol.push(fields[1]);\n            });\n\n            let labels = quickLineReader(new Uint8Array(buffers[2])); // full label names\n            preloaded[name] = { \n                \"raw\": loaded, \n                \"genes\": {\n                    \"ensembl\": ensembl,\n                    \"symbol\": symbol\n                },\n                \"labels\": labels\n            };\n\n        } catch (e) {\n            utils.freeCache(loaded);\n            throw e;\n        }\n    }\n\n\n    if (!(name in references) || rebuild) {\n        let built;\n        try {\n            if (name in references) {\n                utils.freeCache(references[name].raw);\n            }\n\n            let current = preloaded[name];\n            let loaded = current.raw;\n\n            let chosen_ids;\n            if (cache.feature_details.type === \"ensembl\") {\n                chosen_ids = current.genes.ensembl;\n            } else {\n                chosen_ids = current.genes.symbol;\n            }\n\n            let built = scran.buildLabelledReference(cache.features, loaded, chosen_ids); \n            references[name] = {\n                \"features\": chosen_ids,\n                \"raw\": built\n            };\n\n        } catch (e) {\n            utils.freeCache(built);\n            throw e;\n        }\n    }\n\n    return {\n        \"loaded\": preloaded[name],\n        \"built\": references[name]\n    };\n}\n\nexport function compute(args) {\n    if (!markers.changed && !inputs.changed && !utils.changedParameters(parameters, args)) {\n        changed = false;\n        return;\n    } \n\n    let rebuild = false;\n    if (inputs.changed || !(\"feature_space\" in cache)) {\n        rebuild = true;\n        chooseFeatures();\n    }\n\n    // automatically choose from the data\n    let species = cache.feature_details.species;\n\n    // Fetching all of the references.\n    let init = downloads.initialize();\n    let valid = {};\n    if (species == \"human\") {\n        for (const ref of args.human_references) {\n            valid[ref] = getBuiltReference(ref, \"human\", rebuild);\n        }\n    } else if (species == \"mouse\") {\n        for (const ref of args.mouse_references) {\n            valid[ref] = getBuiltReference(ref, \"mouse\", rebuild);\n        }\n    }\n\n    // Creating a column-major array of mean vectors.\n    let ngenes = cache.features.length;\n    let ngroups = markers.numberOfGroups(); \n    let cluster_means = utils.allocateCachedArray(ngroups * ngenes, \"Float64Array\", cache);\n    for (var g = 0; g < ngroups; g++) {\n        let means = markers.fetchGroupMeans(g, false); // Warning: direct view in wasm space - be careful.\n        let cluster_array = cluster_means.array();\n        cluster_array.set(means, g * ngenes);\n    }\n\n    // Running classifications on the cluster means. Note that compute() itself\n    // cannot be async, as we need to make sure 'changed' is set and available for\n    // downstream steps; hence the explicit then().\n    cache.results = {};\n    for (const [key, val] of Object.entries(valid)) {\n        cache.results[key] = val.then(ref => {\n            let output = scran.labelCells(cluster_means, ref.built.raw, { numberOfFeatures: ngenes, numberOfCells: ngroups });\n            let labels = [];\n            for (const o of output) {\n                labels.push(ref.loaded.labels[o]);\n            }\n            return labels;\n        });\n    }\n\n    // Performing additional integration, if necessary. We don't really \n    // need this if there's only one reference.\n    let used_refs = Object.keys(valid);\n    if (used_refs.length > 1) {\n        if (rebuild || utils.changedParameters(used_refs, cache.used)) {\n            let used_vals = Object.values(valid);\n\n            cache.integrated = Promise.all(used_vals)\n                .then(arr => {\n                    let loaded = arr.map(x => x.loaded.raw);\n                    let feats = arr.map(x => x.built.features);\n                    let built = arr.map(x => x.built.raw);\n                    return scran.integrateLabelledReferences(cache.features, loaded, feats, built);\n                }\n            );\n        }\n\n        cache.integrated_results = cache.integrated\n            .then(async (integrated) => {\n                let results = [];\n                for (const key of used_refs) {\n                    results.push(await cache.results[key]);\n                }\n\n                let out = scran.integrateCellLabels(cluster_means, results, integrated, { numberOfFeatures: ngenes, numberOfCells: ngroups });\n                let as_names = [];\n                out.forEach(i => {\n                    as_names.push(used_refs[i]);\n                });\n                return as_names;\n            }\n        );\n    } else {\n        utils.freeCache(cache.integrated);\n        delete cache.integrated_results;\n    }\n    cache.used = used_refs;\n\n    changed = true;\n    delete cache.reloaded;\n    return;\n}\n\nexport async function results() {\n    if (\"reloaded\" in cache) {\n        return cache.reloaded;\n    } else {\n        let perref = {};\n        for (const [key, val] of Object.entries(cache.results)) {\n            perref[key] = await val;\n        }\n\n        let output = { \"per_reference\": perref };\n        if (\"integrated_results\" in cache) {\n            output.integrated = await cache.integrated_results;\n        }\n        console.log(output);\n        return output;\n    }\n}\n\nexport async function serialize() {\n    return {\n        \"parameters\": parameters,\n        \"contents\": await results()\n    };\n}\n\nexport function unserialize(state) {\n    parameters = state.parameters;\n    cache.reloaded = state.contents;\n    return;\n}\n","import * as scran from \"scran.js\";\nimport * as utils from \"./_utils.js\";\nimport * as filter from \"./_qc_filter.js\";\nimport * as normalization from \"./_normalization.js\";\nimport * as markers from \"./_utils_markers.js\";\n\nvar cache = { \"results\": {} };\nvar parameters = { \"selections\": {} };\n\nexport var changed = false;\n\nexport function compute(args) {\n    /* If the QC filter was re-run, all of the selections are invalidated as\n     * the identity of the indices may have changed.\n     */\n    if (filter.changed) {\n        parameters.selections = {};\n        for (const [key, val] of Object.entries(cache.results)) {\n            utils.freeCache(val.raw);                    \n        }\n        cache.results = {};\n    }\n\n    /*\n     * Technically we would need to re-run detection on the existing selections\n     * if the normalization changed but the QC was the same. In practice, this\n     * never happens, so we'll deal with it later.\n     */\n    \n    changed = true;\n    return;\n}\n\nexport function results() {\n    return {};\n}\n\nexport function serialize() {\n    var results = {};\n    \n    for (const [key, val] of Object.entries(cache.results)) {\n        if (\"reloaded\" in val) {\n            results[key] = val.reloaded;\n        } else {\n            results[key] = markers.serializeGroupStats(val.raw, 1);\n        }\n    }\n    \n    return {\n        \"parameters\": parameters,\n        \"contents\": { \"results\": results }\n    };\n}\n\nexport function unserialize(saved) {\n    parameters = saved.parameters;\n    for (const [key, val] of Object.entries(saved.contents)) {\n        cache.results[key] = { \"reloaded\": val };\n    }\n    return;\n}\n\nexport function addSelection(id, selection) {\n    var mat = normalization.fetchNormalizedMatrix();\n\n    var buffer = utils.allocateCachedArray(mat.numberOfColumns(), \"Int32Array\", cache);\n    buffer.fill(0);\n    var tmp = buffer.array();\n    selection.forEach(element => { tmp[element] = 1; });\n\n    // Assumes that we have at least one cell in and outside the selection!\n    var res = scran.scoreMarkers(mat, buffer); \n  \n    // Removing previous results, if there were any.\n    if (id in cache.results) {\n        utils.freeCache(cache.results[id].raw);\n        delete cache.results[id];\n    }\n  \n    cache.results[id] = { \"raw\": res };\n    parameters.selections[id] = selection;\n}\n\nexport function removeSelection(id) {\n    utils.freeCache(cache.results[id].raw);\n    delete cache.results[id];\n    delete parameters.selections[id];\n}\n\nexport function fetchResults(id, rank_type) {\n    var current = cache.results[id];\n    return markers.fetchGroupResults(current.raw, current.reloaded, rank_type, 1); \n};\n","var kanaDB;\nvar init = null;\n\nexport function initialize() {\n    init = new Promise(resolve => {\n        // initialize database on worker creation\n        kanaDB = indexedDB.open(\"KanaDB\", 2);\n\n        kanaDB.onupgradeneeded = (e) => {\n            var kanaDBClient = e.target.result;\n\n            // Currently purging all existing stores when the version is updated.\n            // At some point we may add a more sophisticated upgrade mechanism.\n            try {\n                kanaDBClient.deleteObjectStore(\"analysis\");\n            } catch (e) {}\n            try {\n                kanaDBClient.deleteObjectStore(\"analysis_meta\");\n            } catch (e) {}\n            try {\n                kanaDBClient.deleteObjectStore(\"file\");\n            } catch (e) {}\n            try {\n                kanaDBClient.deleteObjectStore(\"file_meta\");\n            } catch (e) {}\n\n            kanaDBClient.createObjectStore(\"analysis\", { keyPath: 'id' });\n            kanaDBClient.createObjectStore(\"analysis_meta\", { keyPath: 'id' });\n            kanaDBClient.createObjectStore(\"file\", { keyPath: 'id' });\n            kanaDBClient.createObjectStore(\"file_meta\", { keyPath: 'id' });\n        };\n\n        // Send existing stored analyses, if available.\n        kanaDB.onsuccess = () => {\n            getRecordsResolver(resolve);\n        };\n\n        kanaDB.onerror = () => {\n            resolve(null);\n        };\n    });\n\n    return init;\n}\n\nfunction getRecordsResolver(resolve, store = null) {\n    if (store === null) {\n        store = kanaDB.result\n            .transaction([\"analysis_meta\"], \"readonly\")\n            .objectStore(\"analysis_meta\")\n    }\n\n    var allAnalysis = store.getAll();\n\n    allAnalysis.onsuccess = function () {\n        let vals = allAnalysis.result;\n        vals.forEach(x => { delete x.files }); // no need to transfer that.\n        resolve(vals);\n    };\n    allAnalysis.onerror = function () {\n        resolve(null);\n    };\n}\n\n/** Helper functions **/\nasync function loadContent(id, store) {\n    return new Promise(resolve => {\n        let request = store.get(id);\n        request.onsuccess = function () {\n            if (request.result !== undefined) {\n                resolve(request.result);\n            } else {\n                resolve(null);\n            }\n        };\n        request.onerror = function () {\n            resolve(null);\n        };\n    });\n}\n\nfunction allOK(promises) {\n    return Promise.allSettled(promises)\n        .then(vals => {\n            for (const x of vals) {\n                if (!x) {\n                    return false;\n                }\n            }\n            return true;\n        });\n}\n\nexport async function getRecords() {\n    await init;\n    return new Promise(resolve => {\n        getRecordsResolver(resolve);\n    });\n}\n\n/** Functions to save content **/\nexport async function saveFile(id, buffer) {\n    await init;\n    let trans = kanaDB.result.transaction([\"file\", \"file_meta\"], \"readwrite\");\n    let file_store = trans.objectStore(\"file\");\n    let meta_store = trans.objectStore(\"file_meta\");\n\n    var meta = await loadContent(id, meta_store);\n    var refcount;\n    if (meta === null) {\n        refcount = 0;\n    } else {\n        refcount = meta[\"count\"];\n    }\n    refcount++;\n\n    var data_saving = new Promise(resolve => {\n        var putrequest = file_store.put({ \"id\": id, \"payload\": buffer });\n        putrequest.onsuccess = function (event) {\n            resolve(true);\n        };\n        putrequest.onerror = function (event) {\n            resolve(false);\n        };\n    });\n\n    var ref_saving = new Promise(resolve => {\n        meta.count = refcount;\n        var putrequest = meta_store.put(meta);\n        putrequest.onsuccess = function (event) {\n            resolve(true);\n        };\n        putrequest.onerror = function (event) {\n            resolve(false);\n        };\n    });\n\n    return allOK([data_saving, ref_saving])\n};\n\nexport async function saveAnalysis(id, state, files, title) { \n    await init;\n    let trans = kanaDB.result.transaction([\"analysis\", \"analysis_meta\"], \"readwrite\")\n    let analysis_store = trans.objectStore(\"analysis\");\n    let meta_store = trans.objectStore(\"analysis_meta\");\n\n    if (id == null) {\n        let already = await new Promise(resolve => getRecordsResolver(resolve, meta_store));\n        id = String(already.length);\n    }\n\n    var data_saving = new Promise(resolve => {\n        var putrequest = analysis_store.put({ \"id\": id, \"payload\": state });\n        putrequest.onsuccess = function (event) {\n            resolve(true);\n        };\n        putrequest.onerror = function (event) {\n            resolve(false);\n        };\n    });\n\n    var id_saving = new Promise(resolve => {\n        var putrequest = meta_store.put({ \"id\": id, \"files\": files, \"time\": Number(new Date()), \"title\": title });\n        putrequest.onsuccess = function (event) {\n            resolve(true);\n        };\n        putrequest.onerror = function (event) {\n            resolve(false);\n        };\n    });\n\n    if (await allOK([data_saving, id_saving])) {\n        return id;\n    } else {\n        return null;\n    }\n};\n\n/** Functions to load content **/\nexport async function loadFile(id) {\n    await init;\n    let file_store = kanaDB.result\n        .transaction([\"file\"], \"readonly\")\n        .objectStore(\"file\");\n\n    var meta = await loadContent(id, file_store);\n    return meta[\"payload\"];\n}\n\nexport async function loadAnalysis(id) {\n    await init;\n    let analysis_store = kanaDB.result\n        .transaction([\"analysis\"], \"readonly\")\n        .objectStore(\"analysis\");\n    var meta = await loadContent(id, analysis_store);\n    return meta[\"payload\"];\n}\n\n/** Functions to load content **/\nexport async function removeFile(id) {\n    await init;\n    let trans = kanaDB.result.transaction([\"file\", \"file_meta\"], \"readwrite\");\n    let file_store = trans.objectStore(\"file\");\n    let meta_store = trans.objectStore(\"file_meta\");\n\n    var meta = await loadContent(id, meta_store);\n    var refcount = meta[\"count\"];\n    refcount--;\n    var promises = [];\n\n    if (refcount == 0) {\n        promises.push(new Promise(resolve => {\n            let request = file_store.remove(id);\n            request.onerror = function (event) {\n                resolve(false);\n            };\n            request.onsuccess = function (event) {\n                resolve(true);\n            };\n        }));\n        promises.push(new Promise(resolve => {\n            let request = meta_store.delete(id);\n            request.onerror = function (event) {\n                resolve(false);\n            };\n            request.onsuccess = function (event) {\n                resolve(true);\n            };\n        }))\n    } else {\n        promises.push(new Promise(resolve => {\n            meta.count = refcount;\n            let request = meta_store.put(meta);\n            request.onsuccess = function (event) {\n                resolve(true);\n            };\n            request.onerror = function (event) {\n                resolve(false);\n            };\n        }));\n    }\n\n    return allOK(promises);\n}\n\nexport async function removeAnalysis(id) {\n    await init;\n    let trans = kanaDB.result.transaction([\"analysis\", \"analysis_meta\"], \"readwrite\")\n    let analysis_store = trans.objectStore(\"analysis\");\n    let meta_store = trans.objectStore(\"analysis_meta\");\n\n    var promises = [];\n\n    promises.push(new Promise(resolve => {\n        let request = analysis_store.delete(id);\n        request.onsuccess = function (event) {\n            resolve(true);\n        };\n        request.onerror = function (event) {\n            resolve(false);\n        };\n    }));\n\n    // Removing all files as well.\n    var meta = await loadContent(id, meta_store);\n    for (const f of meta[\"files\"]) {\n        promises.push(removeFile(f));\n    }\n\n    promises.push(new Promise(resolve => {\n        let request = meta_store.delete(id);\n        request.onsuccess = function (event) {\n            resolve(true);\n        };\n        request.onerror = function (event) {\n            resolve(false);\n        };\n    }));\n\n    return allOK(promises);\n}\n","import * as scran from \"scran.js\";\nimport * as inputs from \"./_inputs.js\";\nimport * as metrics from \"./_qc_metrics.js\";\nimport * as thresholds from \"./_qc_thresholds.js\";\nimport * as filter from \"./_qc_filter.js\";\nimport * as normalization from \"./_normalization.js\";\nimport * as variance from \"./_model_gene_var.js\";\nimport * as pca from \"./_pca.js\";\nimport * as index from \"./_neighbor_index.js\";\nimport * as cluster_choice from \"./_choose_clustering.js\";\nimport * as kmeans_cluster from \"./_kmeans_cluster.js\";\nimport * as snn_cluster from \"./_snn_cluster.js\";\nimport * as snn_graph from \"./_snn_graph.js\";\nimport * as snn_neighbors from \"./_snn_neighbors.js\";\nimport * as tsne from \"./_tsne_monitor.js\";\nimport * as umap from \"./_umap_monitor.js\";\nimport * as cluster_markers from \"./_score_markers.js\";\nimport * as label_cells from \"./_label_cells.js\";\nimport * as custom_markers from \"./_custom_markers.js\";\nimport * as kana_db from \"./KanaDBHandler.js\";\nimport * as utils from \"./_utils.js\";\nimport * as serialize_utils from \"./_utils_serialize.js\";\n\n/***************************************/\n\nfunction postSuccess_(info, step, message) {\n    var transferable = [];\n    utils.extractBuffers(info, transferable);\n    postMessage({\n        type: `${step}_DATA`,\n        resp: info,\n        msg: \"Success: \" + message\n    }, transferable);\n}\n\nfunction runAllSteps(mode = \"run\", state = null) {\n    var response;\n    if (mode === \"serialize\") {\n        response = {};\n    } else {\n        if (state == null) {\n            throw \"'state' must be supplied if 'mode' is not 'serialize'\";\n        }\n        if (mode === \"unserialize\") {\n            console.log(state);\n            response = { \"params\": {} };\n        }\n    }\n  \n    // Creating helper functions.\n    var postSuccess = function (namespace, step, message) {\n        if (namespace.changed || mode == \"unserialize\") {\n            postSuccess_(namespace.results(), step, message);\n        }\n    }\n  \n    var postSuccessAsync = function (namespace, step, message) {\n        if (namespace.changed || mode == \"unserialize\") {\n            namespace.results()\n                .then(res => {\n                    postSuccess_(res, step, message);\n                });\n        }\n    }\n    \n    var addSerialized = function(step, namespace) {\n        let value = namespace.serialize();\n        if (value !== null) {\n            response[step] = value;\n        }\n    };\n  \n    var addParameters = function(name, value, remapped) {\n        let object = response[\"params\"];\n        if (name in object) {\n            for (const [k, v] of Object.entries(value)) {\n                object[name][k] = v;\n            }\n        } else {\n            object[name] = value;\n        }\n    }\n\n    let serialization_promises = {};\n  \n    // Running through all steps.\n    {\n        let step = \"inputs\";\n        if (mode === \"serialize\") {\n            addSerialized(step, inputs);\n        } else {\n            if (mode == \"run\") {\n                inputs.compute({\n                    \"format\": state.files.format,\n                    \"files\": state.files.files\n                });\n            } else {\n                inputs.unserialize(state[step]);\n                response[\"files\"] = {\n                    \"format\": \"kana\",\n                    \"files\": []\n                };\n            }\n            postSuccess(inputs, step, \"Count matrix loaded\");\n        }\n    }\n  \n    {\n        let step = \"quality_control_metrics\";\n        if (mode === \"serialize\") {\n            addSerialized(step, metrics);\n        } else {\n            if (mode == \"run\") {\n                metrics.compute({\n                    \"use_mito_default\": state.params.qc[\"qc-usemitodefault\"],\n                    \"mito_prefix\": state.params.qc[\"qc-mito\"]\n                });\n            } else {\n                metrics.unserialize(state[step]);\n                addParameters(\"qc\", {\n                    \"qc-usemitodefault\": state[step].parameters.use_mito_default,\n                    \"qc-mito\": state[step].parameters.mito_prefix\n                });\n            }\n            postSuccess(metrics, step, \"QC metrics computed\");\n        }\n    }\n  \n    {\n        let step = \"quality_control_thresholds\";\n        if (mode === \"serialize\") {\n            addSerialized(step, thresholds);\n        } else {\n            if (mode == \"run\") {\n                thresholds.compute({\n                    \"nmads\": state.params.qc[\"qc-nmads\"]\n                });\n            } else {\n                thresholds.unserialize(state[step]);\n                addParameters(\"qc\", {\n                    \"qc-nmads\": state[step].parameters.nmads\n                });\n            }\n            postSuccess(thresholds, step, \"QC thresholds computed\");\n        }\n    }\n  \n    {\n        let step = \"quality_control_filtered\";\n        if (mode == \"serialize\") {\n            addSerialized(step, filter);\n        } else {\n            if (mode == \"run\") {\n                filter.compute({});\n            } else {\n                filter.unserialize(state[step]);\n            }\n            postSuccess(filter, step, \"QC filtering completed\");\n        }\n    }\n  \n    {\n        let step = \"normalization\";\n        if (mode == \"serialize\") {\n            addSerialized(step, normalization);\n        } else {\n            if (mode == \"run\") {\n                normalization.compute({});\n            } else {\n                normalization.unserialize(state[step]);\n            }\n            postSuccess(normalization, step, \"Log-normalization completed\");\n        }\n    }\n  \n    {\n        let step = \"feature_selection\";\n        if (mode == \"serialize\") {\n            addSerialized(step, variance);\n        } else {\n            if (mode == \"run\") {\n                variance.compute({\n                    \"span\": state.params.fSelection[\"fsel-span\"]\n                });\n            } else {\n                variance.unserialize(state[step]);\n                addParameters(\"fSelection\", {\n                    \"fsel-span\": state[step].parameters.span\n                });\n            }\n            postSuccess(variance, step, \"Variance modelling completed\");\n        }\n    }\n  \n    {\n        let step = \"pca\";\n        if (mode == \"serialize\") {\n            addSerialized(step, pca);\n        } else {\n            if (mode == \"run\") {\n                pca.compute({\n                    \"num_hvgs\": state.params.pca[\"pca-hvg\"],\n                    \"num_pcs\": state.params.pca[\"pca-npc\"]\n                });\n            } else {\n                pca.unserialize(state[step]);\n                addParameters(\"pca\", {\n                    \"pca-hvg\": state[step].parameters.num_hvgs,\n                    \"pca-npc\": state[step].parameters.num_pcs\n                });\n            }\n            postSuccess(pca, step, \"Principal components analysis completed\");\n        }\n    }\n  \n    {\n        let step = \"neighbor_index\";\n        if (mode == \"serialize\") {\n            addSerialized(step, index);\n        } else {\n            if (mode == \"run\") {\n                index.compute({\n                    \"approximate\": state.params.cluster[\"clus-approx\"]\n                });\n            } else {\n                index.unserialize(state[step]);\n                addParameters(\"cluster\", {\n                    \"clus-approx\": state[step].parameters.approximate\n                });\n            }\n            postSuccess(index, step, \"Neighbor search index constructed\");\n        }\n    }\n\n    // Need to handle promises in serialize(), results() output,\n    // as these are coming from other workers and are inherently async.\n    {\n        let step = \"tsne\";\n        if (mode == \"serialize\") {\n            serialization_promises[step] = tsne.serialize();\n        } else {\n            if (mode == \"run\") {\n                tsne.compute({\n                    \"perplexity\": state.params.tsne[\"tsne-perp\"],\n                    \"iterations\": state.params.tsne[\"tsne-iter\"],\n                    \"animate\": state.params.tsne[\"animate\"]\n                });\n            } else {\n                tsne.unserialize(state[step]);\n                addParameters(\"tsne\", {\n                  \"tsne-perp\": state[step].parameters.perplexity,\n                  \"tsne-iter\": state[step].parameters.iterations,\n                  \"animate\": state[step].parameters.animate\n                });\n            }\n            postSuccessAsync(tsne, step, \"t-SNE completed\");\n        }\n    }\n\n    {\n        let step = \"umap\";\n        if (mode == \"serialize\") {\n            serialization_promises[step] = umap.serialize();\n        } else {\n            if (mode == \"run\") {\n                umap.compute({\n                    \"num_epochs\": state.params.umap[\"umap-epochs\"],\n                    \"num_neighbors\": state.params.umap[\"umap-nn\"],\n                    \"min_dist\": state.params.umap[\"umap-min_dist\"],\n                    \"animate\": state.params.umap[\"animate\"]\n                });\n            } else {\n                umap.unserialize(state[step]);\n                addParameters(\"umap\", {\n                    \"umap-epochs\": state[step].parameters.num_epochs,\n                    \"umap-nn\": state[step].parameters.num_neighbors,\n                    \"umap-min_dist\": state[step].parameters.min_dist,\n                    \"animate\": state[step].parameters.animate\n                });\n            }\n            postSuccessAsync(umap, step, \"UMAP completed\");\n        }\n    }\n  \n    // Back to normal programming.\n    {\n        let step = \"kmeans_cluster\";\n        if (mode == \"serialize\") {\n            addSerialized(step, kmeans_cluster);\n        } else {\n            if (mode == \"run\") {\n                // Only reporting the method to decide whether to execute this\n                // step; this does not need to be unserialized, as it is \n                // remembered by the choose_clustering step.\n                kmeans_cluster.compute({\n                    \"k\": state.params.cluster[\"kmeans-k\"],\n                    \"cluster_method\": state.params.cluster[\"clus-method\"] \n                });\n            } else {\n                if (step in state) { // clause for back-compatibility with saved analyses.\n                    kmeans_cluster.unserialize(state[step]);\n                    addParameters(\"cluster\", {\n                        \"kmeans-k\": state[step].parameters.k\n                    });\n                }\n            }\n            postSuccess(kmeans_cluster, step, \"K-means clustering completed\");\n        }\n    }\n\n    {\n        let step = \"snn_find_neighbors\";\n        if (mode == \"serialize\") {\n            addSerialized(step, snn_neighbors);\n        } else {\n            if (mode == \"run\") {\n                // Only reporting the method to decide whether to execute this\n                // step; this does not need to be unserialized, as it is \n                // remembered by the choose_clustering step.\n                snn_neighbors.compute({\n                    \"k\": state.params.cluster[\"clus-k\"],\n                    \"cluster_method\": state.params.cluster[\"clus-method\"]\n                });\n            } else {\n                snn_neighbors.unserialize(state[step]);\n                addParameters(\"cluster\", {\n                    \"clus-k\": state[step].parameters.k\n                });\n            }\n            postSuccess(snn_neighbors, step, \"Shared nearest neighbor search completed\");\n        }\n    }\n  \n    {\n        let step = \"snn_build_graph\";\n        if (mode == \"serialize\") {\n            addSerialized(step, snn_graph);\n        } else {\n            if (mode == \"run\") {\n                snn_graph.compute({\n                    \"scheme\": state.params.cluster[\"clus-scheme\"]\n                });\n            } else {\n                snn_graph.unserialize(state[step]);\n                addParameters(\"cluster\", {\n                    \"clus-scheme\": state[step].parameters.scheme\n                });\n            }\n            postSuccess(snn_graph, step, \"Shared nearest neighbor graph constructed\");\n        }\n    }\n  \n    {\n        let step = \"snn_cluster_graph\";\n        if (mode == \"serialize\") {\n            addSerialized(step, snn_cluster);\n        } else {\n            if (mode == \"run\") {\n                snn_cluster.compute({\n                    \"resolution\": state.params.cluster[\"clus-res\"]\n                });\n            } else {\n                snn_cluster.unserialize(state[step]);\n                addParameters(\"cluster\", {\n                    \"clus-res\": state[step].parameters.resolution\n                });\n            }\n            postSuccess(snn_cluster, step, \"Community detection from SNN graph complete\");\n        }\n    }\n\n    {\n        let step = \"choose_clustering\";\n        if (mode == \"serialize\") {\n            addSerialized(step, cluster_choice);\n        } else {\n            if (mode == \"run\") {\n                cluster_choice.compute({\n                    \"method\": state.params.cluster[\"clus-method\"]\n                });\n            } else {\n                cluster_choice.unserialize(state[step]);\n                addParameters(\"cluster\", {\n                    \"clus-method\": state[step].parameters.method\n                });\n            }\n            postSuccess(cluster_choice, step, \"Clustering of interest chosen\");\n        }\n    }\n\n    {\n        let step = \"marker_detection\";\n        if (mode == \"serialize\") {\n            addSerialized(step, cluster_markers);\n        } else {\n            if (mode == \"run\") {\n                cluster_markers.compute({});\n            } else {\n                cluster_markers.unserialize(state[step]);\n            }\n            postSuccess(cluster_markers, step, \"Marker detection complete\");\n        }\n    }\n\n    {\n        let step = \"cell_labelling\";\n        if (mode == \"serialize\") {\n            serialization_promises[step] = label_cells.serialize();\n        } else {\n            if (mode == \"run\") {\n                let anno_species = state.params.annotateCells[\"annotateCells-species\"];\n                let stateObj = {\n                    \"species\": anno_species,\n                    \"human_references\": state.params.annotateCells[\"annotateCells-human_references\"],\n                    \"mouse_references\": state.params.annotateCells[\"annotateCells-mouse_references\"]\n                };\n                label_cells.compute(stateObj);\n            } else {\n                label_cells.unserialize(state[step]);\n            }\n            postSuccessAsync(label_cells, step, \"Cell type labelling complete\");\n        }\n    }\n\n    {\n        let step = \"custom_marker_management\";\n        if (mode == \"serialize\") {\n            addSerialized(step, custom_markers);\n        } else {\n            if (mode == \"run\") {\n                custom_markers.compute({});\n            } else {\n                custom_markers.unserialize(state[step]);\n            }\n            postSuccess(custom_markers, step, \"Pruning of custom markers finished\");\n        }\n    }\n  \n    if (mode == \"serialize\") {\n        let keys = Object.keys(serialization_promises);\n        let vals = Object.values(serialization_promises);\n        return Promise.all(vals)\n            .then(done => {\n                done.forEach((x, i) => {\n                    response[keys[i]] = x;\n                });\n                return response;\n            });\n    } else {\n        return response;\n    }\n}\n\n/***************************************/\n\nvar loaded;\nonmessage = function (msg) {\n    const payload = msg.data;\n    if (payload.type == \"INIT\") {\n        let nthreads = Math.round(navigator.hardwareConcurrency * 2 / 3);\n        let scran_init = scran.initialize({ numberOfThreads: nthreads });\n        scran_init \n            .then(x => {\n                postMessage({\n                    type: payload.type,\n                    msg: `Success: ScranJS/WASM initialized`\n                });\n            });\n\n        let kana_init = kana_db.initialize();\n        kana_init\n            .then(result => {\n                if (result !== null) {\n                    postMessage({\n                        type: \"KanaDB_store\",\n                        resp: result,\n                        msg: \"Success\"\n                    });\n                } else {\n                    console.error(error);\n                    postMessage({\n                        type: \"KanaDB_ERROR\",\n                        msg: `Fail: Cannot initialize DB`\n                    });\n                }\n            });\n\n        let tsne_init = tsne.initialize();\n        let umap_init = umap.initialize();\n\n        loaded = Promise.all([\n            scran_init,\n            kana_init,\n            tsne_init,\n            umap_init\n        ]);\n\n    } else if (payload.type == \"RUN\") {\n        loaded\n            .then(x => {\n                runAllSteps(\"run\", payload.payload)\n            })\n            .catch(error => {\n                console.error(error);\n                postMessage({\n                    type: \"run_ERROR\",\n                    msg: error.toString()\n                });\n            });\n\n    /**************** LOADING EXISTING ANALYSES *******************/\n    } else if (payload.type == \"LOAD\") {\n        if (payload.payload.files.format == \"kana\") {\n            const reader = new FileReaderSync();\n            var f = payload.payload.files.files.file[0];\n            loaded\n                .then(async (x) => {\n                    var contents = await serialize_utils.load(reader.readAsArrayBuffer(f));\n                    var response = runAllSteps(\"unserialize\", contents);\n                    postMessage({\n                        type: \"loadedParameters\",\n                        resp: response\n                    });\n                })\n                .catch(error => {\n                    console.error(error);\n                    postMessage({\n                        type: \"load_ERROR\",\n                        msg: error.toString()\n                    });\n                });\n\n        } else if (payload.payload.files.format == \"kanadb\") {\n            var id = payload.payload.files.files.file;\n            kana_db.loadAnalysis(id)\n                .then(async (res) => {\n                    if (res == null) {\n                        postMessage({\n                            type: \"KanaDB_ERROR\",\n                            msg: `Fail: cannot load analysis ID '${id}'`\n                        });\n                    } else {\n                        var contents = await serialize_utils.load(res);\n                        var response = await runAllSteps(\"unserialize\", contents);\n                        postMessage({\n                            type: \"loadedParameters\",\n                            resp: response\n                        });\n                    }\n                })\n                .catch(error => {\n                    console.error(error);\n                    postMessage({\n                        type: \"load_ERROR\",\n                        msg: error.toString()\n                    });\n                });\n        }\n  \n    } else if (payload.type == \"EXPORT\") { // exporting an analysis\n        loaded\n            .then(async (x) => {\n                var state = await runAllSteps(\"serialize\");\n                var output = await serialize_utils.save(state, \"full\");\n                postMessage({\n                    type: \"exportState\",\n                    resp: output,\n                    msg: \"Success: application state exported\"\n                }, [output]);\n            })\n            .catch(error => {\n                console.error(error);\n                postMessage({\n                    type: \"export_ERROR\",\n                    msg: error.toString()\n                });\n            });\n  \n    } else if (payload.type == \"SAVEKDB\") { // save analysis to inbrowser indexedDB \n        var title = payload.payload.title;\n        loaded\n            .then(async (x) => {\n                var state = await runAllSteps(\"serialize\");\n                var output = await serialize_utils.save(state, \"KanaDB\");\n                var id = await kana_db.saveAnalysis(null, output.state, output.file_ids, title);\n                if (id !== null) {\n                    let recs = await kana_db.getRecords();\n                    postMessage({\n                        type: \"KanaDB_store\",\n                        resp: recs,\n                        msg: `Success: Saved analysis to cache (${id})`\n                    });\n                } else {\n                    console.error(error);\n                    postMessage({\n                        type: \"KanaDB_ERROR\",\n                        msg: `Fail: Cannot save analysis to cache (${id})`\n                    });\n                }\n            })\n            .catch(error => {\n                console.error(error);\n                postMessage({\n                    type: \"export_ERROR\",\n                    msg: error.toString()\n                });\n            });\n  \n    } else if (payload.type == \"REMOVEKDB\") { // remove a saved analysis\n        var id = payload.payload.id;\n        kana_db.removeAnalysis(id)\n            .then(async (result) => {\n                if (result) {\n                    let recs = await kana_db.getRecords();\n                    postMessage({\n                        type: \"KanaDB_store\",\n                        resp: recs,\n                        msg: `Success: Removed file from cache (${id})`\n                    });\n                } else {\n                    console.error(error);\n                    postMessage({\n                        type: \"KanaDB_ERROR\",\n                        msg: `fail: cannot remove file from cache (${id})`\n                    });\n                }\n            });\n  \n    /**************** OTHER EVENTS FROM UI *******************/\n    } else if (payload.type == \"getMarkersForCluster\") {\n        loaded.then(x => {\n            let cluster = payload.payload.cluster;\n            let rank_type = payload.payload.rank_type;\n            var resp = cluster_markers.fetchGroupResults(rank_type, cluster);\n      \n            var transferrable = [];\n            utils.extractBuffers(resp, transferrable);\n            postMessage({\n                type: \"setMarkersForCluster\",\n                resp: resp,\n                msg: \"Success: GET_MARKER_GENE done\"\n            }, transferrable);\n        });\n  \n    } else if (payload.type == \"getGeneExpression\") {\n        loaded.then(x => {\n            let row_idx = payload.payload.gene;\n            var vec = normalization.fetchExpression(row_idx);\n            postMessage({\n                type: \"setGeneExpression\",\n                resp: {\n                    gene: row_idx,\n                    expr: vec\n                },\n                msg: \"Success: GET_GENE_EXPRESSION done\"\n            }, [vec.buffer]);\n        });\n  \n    } else if (payload.type == \"computeCustomMarkers\") {\n        loaded.then(x => {\n            custom_markers.addSelection(payload.payload.id, payload.payload.selection);\n            postMessage({\n                type: \"computeCustomMarkers\",\n                msg: \"Success: COMPUTE_CUSTOM_MARKERS done\"\n            });\n        });\n  \n    } else if (payload.type == \"getMarkersForSelection\") {\n        loaded.then(x => {\n            var resp = custom_markers.fetchResults(payload.payload.cluster, payload.payload.rank_type);\n            var transferrable = [];\n            utils.extractBuffers(resp, transferrable);\n            postMessage({\n                type: \"setMarkersForCustomSelection\",\n                resp: resp,\n                msg: \"Success: GET_MARKER_GENE done\"\n            }, transferrable);\n        });\n  \n    } else if (payload.type == \"removeCustomMarkers\") {\n        loaded.then(x => {\n            custom_markers.removeSelection(payload.payload.id);\n        });\n  \n    } else if (payload.type == \"animateTSNE\") {\n        loaded.then(async (x) => {\n            await tsne.animate();\n            var res = await tsne.results();\n            postSuccess_(res, \"tsne\", \"Resending t-SNE coordinates\");\n        });\n  \n    } else if (payload.type == \"animateUMAP\") {\n        loaded.then(async (x) => {\n            await umap.animate();\n            var res = await umap.results();\n            postSuccess_(res, \"umap\", \"Resending UMAP coordinates\");\n        });\n\n    } else if (payload.type == \"getAnnotation\") {\n        loaded.then(x => {\n            let annot = payload.payload.annotation;\n            var vec = inputs.fetchAnnotations(annot);\n            postMessage({\n                type: \"setAnnotation\",\n                resp: {\n                    annotation: annot,\n                    values: {\n                        \"index\": vec.index,\n                        \"factor\": vec.factor\n                    }\n                },\n                msg: \"Success: GET_ANNOTATION done\"\n            }, [vec.factor.buffer]);\n        });\n  \n    } else {\n        console.error(\"MIM:::msg type incorrect\")\n    }\n}\n","import * as pako from \"pako\";\nimport * as hashwasm from \"hash-wasm\";\nimport * as kana_db from \"./KanaDBHandler.js\";\n\n// Must be integers!\nconst FORMAT_EMBEDDED_FILES = 0;\nconst FORMAT_EXTERNAL_KANADB = 1;\nconst FORMAT_VERSION = 0;\n\nfunction normalizeTypedArrays(object) {\n    if (Array.isArray(object)) {\n        for (var i = 0; i < object.length; i++) {\n            object[i] = normalizeTypedArrays(object[i]);\n        }\n    } else if (ArrayBuffer.isView(object)) {\n        object = { \n            \"_TypedArray_class\": object.constructor.name, \n            \"_TypedArray_values\": Array.from(object) \n        };\n    } else if (object instanceof Object) {\n        // This MUST be after the previous clause, as otherwise\n        // a TypedArray is an object and is incorrectly handled. \n        for (const [key, element] of Object.entries(object)) {\n            object[key] = normalizeTypedArrays(element);\n        }\n    }\n    return object;\n}\n\nfunction recoverTypedArrays(object) {\n    if (Array.isArray(object)) {\n        for (var i = 0; i < object.length; i++) {\n            object[i] = recoverTypedArrays(object[i]);\n        }\n    } else if (object instanceof Object) {\n        if (\"_TypedArray_class\" in object) {\n            var cls = object[[\"_TypedArray_class\"]];\n            var vals = object[[\"_TypedArray_values\"]];\n            switch (cls) {\n                case \"Uint8Array\":\n                    object = new Uint8Array(vals.length);\n                    break;\n                case \"Int8Array\":\n                    object = new Int8Array(vals.length);\n                    break;\n                case \"Uint8Array\":\n                    object = new Uint8Array(vals.length);\n                    break;\n                case \"Uint16Array\":\n                    object = new Uint16Array(vals.length);\n                    break;\n                case \"Int16Array\":\n                    object = new Int16Array(vals.length);\n                    break;\n                case \"Uint32Array\":\n                    object = new Uint32Array(vals.length);\n                    break;\n                case \"Int32Array\":\n                    object = new Int32Array(vals.length);\n                    break;\n                case \"Uint64Array\":\n                    object = new Uint64Array(vals.length);\n                    break;\n                case \"Int64Array\":\n                    object = new Int64Array(vals.length);\n                    break;\n                case \"Float32Array\":\n                    object = new Float32Array(vals.length);\n                    break;\n                case \"Float64Array\":\n                    object = new Float64Array(vals.length);\n                    break;\n                default:\n                    throw \"unrecognized TypedArray class '\" + cls;\n            }\n            object.set(vals);\n        } else {\n            for (const [key, element] of Object.entries(object)) {\n                object[key] = recoverTypedArrays(element);\n            }\n        }\n    } \n    return object;\n}\n\nfunction numberToBuffer(number) {\n    // Store as little-endian. Probably safer\n    // than trying to cast it from a Uint64Array;\n    // not sure that endianness is strictly defined.\n    var output = new Uint8Array(8);\n\n    var i = 0;\n    while (number > 0) {\n        output[i] = number % 256;\n        number = Math.floor(number / 256);\n        i++;\n    }\n\n    return output;\n}\n\nfunction bufferToNumber(buffer) {\n    var output = 0;\n    var multiplier = 1;\n    for (const x of buffer) {\n        output += multiplier * x;\n        multiplier *= 256;\n    }\n    return output;\n}\n\nexport async function save(contents, mode = \"full\") {\n    // Extract out the file buffers.\n    var buffered = contents.inputs.parameters.files;\n    var all_buffers = [];\n    var total_len = 0;\n    var format_type;\n\n    if (mode == \"full\") {\n        format_type = FORMAT_EMBEDDED_FILES;\n        buffered.forEach((x, i) => {\n            var val = x.buffer;\n            all_buffers.push(val);\n            buffered[i].buffer = { \"offset\": total_len, \"size\": val.byteLength };\n            total_len += val.byteLength;\n        });\n\n    } else if (mode == \"KanaDB\") {\n        // Saving the files to IndexedDB instead. 'all_buffers' now holds a promise\n        // indicating whether all of these things were saved properly.\n        format_type = FORMAT_EXTERNAL_KANADB;\n        for (const x of buffered) {\n            var md5 = await hashwasm.md5(new Uint8Array(x.buffer));\n            var id = x.type + \"_\" + x.name + \"_\" + x.buffer.byteLength + \"_\" + md5;\n            var ok = await kana_db.saveFile(id, x.buffer);\n            if (!ok) {\n                throw \"failed to save file '\" + id + \"' to KanaDB\";\n            }\n            x.buffer = id;\n            all_buffers.push(id);\n        }\n\n    } else {\n        throw \"unsupported mode \" + mode;\n    }\n\n    // Converting all other TypedArrays to normal arrays.\n    contents = normalizeTypedArrays(contents);\n\n    // Converting the JSON to a string and gzipping it into a Uint8Array.\n    var json_str = JSON.stringify(contents);\n    const json_view = pako.gzip(json_str);\n\n    // Allocating a huge arrayBuffer.\n    var combined = new ArrayBuffer(24 + json_view.length + total_len);\n    var combined_arr = new Uint8Array(combined);\n    var offset = 0;\n\n    let format = numberToBuffer(format_type);\n    combined_arr.set(format, offset); \n    offset += format.length;\n\n    let version = numberToBuffer(FORMAT_VERSION);\n    combined_arr.set(version, offset); \n    offset += version.length;\n\n    let json_len = numberToBuffer(json_view.length);\n    combined_arr.set(json_len, offset); \n    offset += json_len.length;\n\n    if (offset != 24) {\n        throw \"oops - accounting error in the serialization code!\";\n    }\n\n    combined_arr.set(json_view, offset);\n    offset += json_view.length;\n\n    if (mode == \"full\") {\n        for (const buf of all_buffers) {\n            const tmp = new Uint8Array(buf);\n            combined_arr.set(tmp, offset);\n            offset += tmp.length;\n        }\n        return combined;\n\n    } else if (mode == \"KanaDB\") {\n        return { \"file_ids\": all_buffers, \"state\": combined };\n\n    } else {\n        throw \"unsupported mode \" + mode;\n    }\n}\n\nexport async function load(buffer) {\n    var offset = 0;\n    var format = bufferToNumber(new Uint8Array(buffer, offset, 8));\n    offset += 8;\n\n    var version = bufferToNumber(new Uint8Array(buffer, offset, 8));\n    offset += 8;\n\n    var json_len = bufferToNumber(new Uint8Array(buffer, offset, 8));\n    offset += 8;\n\n    var contents = pako.ungzip(new Uint8Array(buffer, offset, json_len), { \"to\": \"string\" });\n    contents = JSON.parse(contents);\n    contents = recoverTypedArrays(contents);\n    offset += json_len;\n\n    var buffered = contents.inputs.parameters.files;\n    if (format == FORMAT_EMBEDDED_FILES) {\n        buffered.forEach((x, i) => {\n            var details = x.buffer;\n            var target = new Uint8Array(buffer, offset + details.offset, details.size);\n            var tmp = new ArrayBuffer(details.size);\n            (new Uint8Array(tmp)).set(target);\n            buffered[i].buffer = tmp;\n        });\n\n    } else if (format == FORMAT_EXTERNAL_KANADB) {\n        var collected = [];\n        buffered.forEach((x, i) => {\n            var id = x.buffer;\n            collected.push(kana_db.loadFile(id));\n        });\n  \n        var resolved = await Promise.all(collected);\n        buffered.forEach((x, i) => {\n            if (resolved[i] === null) {\n                throw \"KanaDB loading failed for file ID '\" + x.buffer + \"'\";\n            }\n            x.buffer = resolved[i];\n        });\n\n    } else {\n        throw \"unsupported format type\";\n    }\n \n    return contents;\n}\n","// The module cache\nvar __webpack_module_cache__ = {};\n\n// The require function\nfunction __webpack_require__(moduleId) {\n\t// Check if module is in cache\n\tvar cachedModule = __webpack_module_cache__[moduleId];\n\tif (cachedModule !== undefined) {\n\t\treturn cachedModule.exports;\n\t}\n\t// Create a new module (and put it into the cache)\n\tvar module = __webpack_module_cache__[moduleId] = {\n\t\t// no module.id needed\n\t\t// no module.loaded needed\n\t\texports: {}\n\t};\n\n\t// Execute the module function\n\t__webpack_modules__[moduleId](module, module.exports, __webpack_require__);\n\n\t// Return the exports of the module\n\treturn module.exports;\n}\n\n// expose the modules object (__webpack_modules__)\n__webpack_require__.m = __webpack_modules__;\n\n// the startup function\n__webpack_require__.x = function() {\n\t// Load entry module and return exports\n\t// This entry module depends on other loaded chunks and execution need to be delayed\n\tvar __webpack_exports__ = __webpack_require__.O(undefined, [275,555], function() { return __webpack_require__(4109); })\n\t__webpack_exports__ = __webpack_require__.O(__webpack_exports__);\n\treturn __webpack_exports__;\n};\n\n","var deferred = [];\n__webpack_require__.O = function(result, chunkIds, fn, priority) {\n\tif(chunkIds) {\n\t\tpriority = priority || 0;\n\t\tfor(var i = deferred.length; i > 0 && deferred[i - 1][2] > priority; i--) deferred[i] = deferred[i - 1];\n\t\tdeferred[i] = [chunkIds, fn, priority];\n\t\treturn;\n\t}\n\tvar notFulfilled = Infinity;\n\tfor (var i = 0; i < deferred.length; i++) {\n\t\tvar chunkIds = deferred[i][0];\n\t\tvar fn = deferred[i][1];\n\t\tvar priority = deferred[i][2];\n\t\tvar fulfilled = true;\n\t\tfor (var j = 0; j < chunkIds.length; j++) {\n\t\t\tif ((priority & 1 === 0 || notFulfilled >= priority) && Object.keys(__webpack_require__.O).every(function(key) { return __webpack_require__.O[key](chunkIds[j]); })) {\n\t\t\t\tchunkIds.splice(j--, 1);\n\t\t\t} else {\n\t\t\t\tfulfilled = false;\n\t\t\t\tif(priority < notFulfilled) notFulfilled = priority;\n\t\t\t}\n\t\t}\n\t\tif(fulfilled) {\n\t\t\tdeferred.splice(i--, 1)\n\t\t\tvar r = fn();\n\t\t\tif (r !== undefined) result = r;\n\t\t}\n\t}\n\treturn result;\n};","// getDefaultExport function for compatibility with non-harmony modules\n__webpack_require__.n = function(module) {\n\tvar getter = module && module.__esModule ?\n\t\tfunction() { return module['default']; } :\n\t\tfunction() { return module; };\n\t__webpack_require__.d(getter, { a: getter });\n\treturn getter;\n};","// define getter functions for harmony exports\n__webpack_require__.d = function(exports, definition) {\n\tfor(var key in definition) {\n\t\tif(__webpack_require__.o(definition, key) && !__webpack_require__.o(exports, key)) {\n\t\t\tObject.defineProperty(exports, key, { enumerable: true, get: definition[key] });\n\t\t}\n\t}\n};","__webpack_require__.f = {};\n// This file contains only the entry chunk.\n// The chunk loading function for additional chunks\n__webpack_require__.e = function(chunkId) {\n\treturn Promise.all(Object.keys(__webpack_require__.f).reduce(function(promises, key) {\n\t\t__webpack_require__.f[key](chunkId, promises);\n\t\treturn promises;\n\t}, []));\n};","// This function allow to reference async chunks and sibling chunks for the entrypoint\n__webpack_require__.u = function(chunkId) {\n\t// return url for filenames based on template\n\treturn \"static/js/\" + chunkId + \".\" + {\"139\":\"1c21bba7\",\"275\":\"66af1466\",\"495\":\"961c2f19\",\"555\":\"39d4c1fb\",\"653\":\"b182baa9\"}[chunkId] + \".chunk.js\";\n};","// This function allow to reference async chunks and sibling chunks for the entrypoint\n__webpack_require__.miniCssF = function(chunkId) {\n\t// return url for filenames based on template\n\treturn undefined;\n};","__webpack_require__.g = (function() {\n\tif (typeof globalThis === 'object') return globalThis;\n\ttry {\n\t\treturn this || new Function('return this')();\n\t} catch (e) {\n\t\tif (typeof window === 'object') return window;\n\t}\n})();","__webpack_require__.o = function(obj, prop) { return Object.prototype.hasOwnProperty.call(obj, prop); }","// define __esModule on exports\n__webpack_require__.r = function(exports) {\n\tif(typeof Symbol !== 'undefined' && Symbol.toStringTag) {\n\t\tObject.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });\n\t}\n\tObject.defineProperty(exports, '__esModule', { value: true });\n};","__webpack_require__.p = \"/kana/\";","__webpack_require__.b = self.location + \"/../../../\";\n\n// object to store loaded chunks\n// \"1\" means \"already loaded\"\nvar installedChunks = {\n\t109: 1\n};\n\n// importScripts chunk loading\nvar installChunk = function(data) {\n\tvar chunkIds = data[0];\n\tvar moreModules = data[1];\n\tvar runtime = data[2];\n\tfor(var moduleId in moreModules) {\n\t\tif(__webpack_require__.o(moreModules, moduleId)) {\n\t\t\t__webpack_require__.m[moduleId] = moreModules[moduleId];\n\t\t}\n\t}\n\tif(runtime) runtime(__webpack_require__);\n\twhile(chunkIds.length)\n\t\tinstalledChunks[chunkIds.pop()] = 1;\n\tparentChunkLoadingFunction(data);\n};\n__webpack_require__.f.i = function(chunkId, promises) {\n\t// \"1\" is the signal for \"already loaded\"\n\tif(!installedChunks[chunkId]) {\n\t\tif(true) { // all chunks have JS\n\t\t\timportScripts(__webpack_require__.p + __webpack_require__.u(chunkId));\n\t\t}\n\t}\n};\n\nvar chunkLoadingGlobal = self[\"webpackChunkkana\"] = self[\"webpackChunkkana\"] || [];\nvar parentChunkLoadingFunction = chunkLoadingGlobal.push.bind(chunkLoadingGlobal);\nchunkLoadingGlobal.push = installChunk;\n\n// no HMR\n\n// no HMR manifest","var next = __webpack_require__.x;\n__webpack_require__.x = function() {\n\treturn Promise.all([\n\t\t__webpack_require__.e(275),\n\t\t__webpack_require__.e(555)\n\t]).then(next);\n};","// run startup\nvar __webpack_exports__ = __webpack_require__.x();\n"],"names":["freeCache","object","undefined","free","e","freeReloaded","cache","Object","entries","reloaded","v","wa","changedParameters","x","y","JSON","stringify","computeRange","arr","max","Infinity","min","forEach","allocateCachedArray","size","type","name","reallocate","candidate","constructor","className","scran","extractBuffers","store","Array","isArray","ArrayBuffer","isView","buffer","push","isObject","parameters","abbreviated","changed","dummyGenes","numberOfRows","genes","i","guessFeatureType","gene_info_type","gene_info","fetchGenes","key","val","gene_types","readDSVFromBuffer","content","fname","delim","ext","split","pop","pako","dec","TextDecoder","decoded","decode","tsv","d3","parsed","parseRows","loadMatrixMarketRaw","files","utils","matrix","first_mtx","filter","contents","Uint8Array","is_compressed","genes_file","length","ids","symb","annotations_file","diff","numberOfColumns","headerFlag","headers","shift","annotations","map","load10XRaw","first_file","tmppath","objects","fobjects","id","names","loadH5ADRaw","vobjects","match","bobjects","bobj_factors","bobj_index","loadHDF5","args","format","reader","FileReaderSync","it","bufferFun","formatted","f","readAsArrayBuffer","file","compute","mtx","gene","barcode","loadMatrixMarket","results","output","fetchDimensions","keys","serialize","num_cells","parameters2","unserialize","saved","fetchCountMatrix","values","fetchGeneTypes","fetchAnnotations","col","annots","asize","uvals","uTypedAray","mito","ensembl","Set","symbol","rawCompute","raw","subsets","mat","inputs","fill","sub_arr","array","use_mito_default","has","lower_mito","mito_prefix","toLowerCase","startsWith","fetchResults","data","qc_output","sums","slice","detected","proportion","subsetProportions","ranges","fetchQCMetrics","fetchSums","unsafe","copy","metrics","stats","numberOfMADs","nmads","obj","thresholdsSums","thresholdsDetected","thresholdsSubsetProportions","discards","fetchDiscards","tmp","set","fetchDiscardsAsWasmArray","discardOverall","out","disc","thresholds","fetchRetained","retained","fetchFilteredMatrix","size_factors","j","sizeFactors","fetchNormalizedMatrix","fetchExpression","index","row","normalization","span","sorted_residuals","residuals","sort","means","vars","fitted","resids","model_output","variances","spawnStats","fetchSortedResiduals","fetchResiduals","fetchPCsAsWasmArray","pcs","principalComponents","variance","sorted_resids","threshold_at","num_hvgs","sub","unsorted_resids","element","features","numberOfPCs","num_pcs","var_exp","pca_output","varianceExplained","total_var","totalVariance","to_save","fetchPCs","pca","numberOfDims","numberOfCells","num_obs","fetchIndex","nn_index","k","method","cluster_method","fetchNeighbors","res","neighbors","scheme","fetchGraph","fetchClustersAsWasmArray","clusters","membership","graph","g","resolution","initMethod","snn_cluster","kmeans_cluster","computeNeighbors","rbuf","ibuf","dbuf","runs","indices","distances","sendTask","worker","payload","transferrable","counter","p","Promise","resolve","reject","promises","postMessage","initializeWorker","onmessage","msg","endsWith","iteration","fun","error","runWithNeighbors","nn_out","run_msg","retrieveCoordinates","run","then","initialize","vizutils","Worker","URL","core","reneighbor","perplexity","animate","param_copy","initialized","num_neighbors","serializeGroupStats","group","lfc","summary","deltaDetected","cohen","auc","useReloaded","fetchGroupResults","rank_type","ordering","ranking","use_reloaded","increasing","effect","Int32Array","s","stat_detected","stat_mean","stat_lfc","stat_delta_d","reorder","thing","Float64Array","current","delta_detected","fetchGroupMeans","DownloadsDB","choice","num","numberOfGroups","markers","init","indexedDB","open","onupgradeneeded","DownloadsDBClient","target","result","deleteObjectStore","createObjectStore","keyPath","onsuccess","onerror","get","url","params","force","trans","transaction","download_store","objectStore","data_check","already","event","found","req","fetch","ok","status","arrayBuffer","data_saving","putrequest","put","hs_loaded","mm_loaded","hs_references","mm_references","proxy","hs_base","mm_base","quickLineReader","compression","txt","lines","getBuiltReference","species","rebuild","base","preloaded","references","downloads","all","encodeURIComponent","buffers","console","log","loaded","gene_lines","fields","labels","chosen_ids","feature_details","built","types","best_feature","best","confidence","chooseFeatures","valid","human_references","ref","mouse_references","ngenes","ngroups","cluster_means","numberOfFeatures","o","used_refs","used","used_vals","integrated","feats","integrated_results","as_names","perref","state","kanaDB","selections","addSelection","selection","removeSelection","getRecordsResolver","allAnalysis","getAll","vals","loadContent","request","allOK","allSettled","getRecords","saveFile","file_store","meta_store","meta","refcount","ref_saving","count","saveAnalysis","title","analysis_store","String","id_saving","Number","Date","loadFile","removeFile","remove","delete","normalizeTypedArrays","from","recoverTypedArrays","cls","Int8Array","Uint16Array","Int16Array","Uint32Array","Uint64Array","Int64Array","Float32Array","numberToBuffer","number","Math","floor","bufferToNumber","multiplier","save","mode","buffered","all_buffers","total_len","format_type","byteLength","hashwasm","md5","kana_db","json_str","json_view","combined","combined_arr","offset","version","json_len","buf","load","parse","details","collected","resolved","postSuccess_","info","step","message","transferable","resp","runAllSteps","response","postSuccess","namespace","postSuccessAsync","addSerialized","value","addParameters","remapped","serialization_promises","qc","fSelection","cluster","approximate","tsne","iterations","umap","num_epochs","min_dist","snn_neighbors","snn_graph","cluster_choice","cluster_markers","label_cells","anno_species","annotateCells","stateObj","custom_markers","done","nthreads","round","navigator","hardwareConcurrency","scran_init","numberOfThreads","kana_init","kanaDBClient","tsne_init","umap_init","catch","toString","serialize_utils","file_ids","recs","row_idx","vec","expr","annot","annotation","factor","__webpack_module_cache__","__webpack_require__","moduleId","cachedModule","exports","module","__webpack_modules__","m","__webpack_exports__","O","deferred","chunkIds","fn","priority","notFulfilled","fulfilled","every","splice","r","n","getter","__esModule","d","a","definition","defineProperty","enumerable","chunkId","reduce","u","miniCssF","globalThis","this","Function","window","prop","prototype","hasOwnProperty","call","Symbol","toStringTag","b","self","location","installedChunks","importScripts","chunkLoadingGlobal","parentChunkLoadingFunction","bind","moreModules","runtime","next"],"sourceRoot":""}