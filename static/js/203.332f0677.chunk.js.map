{"version":3,"file":"static/js/203.332f0677.chunk.js","mappings":"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","sources":["workers/_utils.js","workers/_utils_reader.js","workers/_reader_10x.js","workers/_reader_h5ad.js","workers/_reader_mtx.js","workers/_utils_inputs.js","workers/_inputs.js","workers/_preflight_inputs.js","workers/mito.js","workers/_quality_control.js","workers/_normalization.js","workers/_model_gene_var.js","workers/_pca.js","workers/_neighbor_index.js","workers/_snn_cluster.js","workers/_kmeans_cluster.js","workers/_choose_clustering.js","workers/_utils_viz_parent.js","workers/_tsne_monitor.js","workers/_umap_monitor.js","workers/_utils_markers.js","workers/_score_markers.js","workers/DownloadsDBHandler.js","workers/_label_cells.js","workers/_custom_markers.js","workers/KanaDBHandler.js","workers/legacy/from_v0.js","workers/_utils_serialize.js","workers/scran.worker.js","../webpack/bootstrap","../webpack/runtime/chunk loaded","../webpack/runtime/compat get default export","../webpack/runtime/define property getters","../webpack/runtime/ensure chunk","../webpack/runtime/get javascript chunk filename","../webpack/runtime/get mini-css chunk filename","../webpack/runtime/global","../webpack/runtime/hasOwnProperty shorthand","../webpack/runtime/make namespace object","../webpack/runtime/publicPath","../webpack/runtime/importScripts chunk loading","../webpack/runtime/startup chunk dependencies","../webpack/startup"],"sourcesContent":["import * as scran from \"scran.js\";\nimport * as wa from \"wasmarrays.js\";\n\nexport function copyVectors(data, copy) {\n    if (copy) {\n        for (const k of Object.keys(data)) {\n            data[k] = data[k].slice();\n        }\n    }\n}\n\nexport function copyOrView(copy) {\n    if (!copy) {\n        return \"view\";\n    } else {\n        return copy;\n    }\n}\n\nexport function mimicGetter(value, copy) {\n    if (value instanceof wa.WasmArray) {\n        if (copy == \"view\") {\n            return value.view();\n        } else if (copy) {\n            return value.slice();\n        } else {\n            return value.array();\n        }\n    } else {\n        if (copy === true) {\n            return value.slice();\n        } else {\n            // Includes copy = \"view\"; we just provide a no-copy and assume\n            // that, if the caller actually wanted a WasmArray, they would\n            // have generated a WasmArray during the unserialization.\n            return value;\n        }\n    }\n}\n\nexport function freeCache(object) {\n    if (object !== undefined && object !== null) {\n        object.free();\n    }\n    return;\n}\n\nexport function changedParameters(x, y) {\n    return JSON.stringify(x) != JSON.stringify(y);\n}\n\nexport function allocateCachedArray(size, type, cache, name = \"buffer\") {\n    var reallocate = true;\n    if (name in cache) {\n        var candidate = cache[name];\n        if (candidate.size != size || candidate.constructor.className != type) {\n            candidate.free();\n        } else {\n            reallocate = false;\n        }\n    }\n  \n    if (reallocate) {\n        switch (type) {\n            case \"Uint8Array\":\n                cache[name] = scran.createUint8WasmArray(size);\n                break;\n            case \"Int32Array\":\n                cache[name] = scran.createInt32WasmArray(size);\n                break;\n            case \"Float64Array\":\n                cache[name] = scran.createFloat64WasmArray(size);\n                break;\n            default:\n                // We only ever use one of the three above types in our \n                // internal data stores, so no need to go all-out here.\n                throw \"allocating '\" + type + \"' not yet supported\";\n        }\n    }\n\n    return cache[name];\n}\n\nexport function extractBuffers(object, store) {\n    if (Array.isArray(object)) {\n        for (const element of object) {\n            extractBuffers(element, store);\n        }\n    } else if (object.constructor == Object) {\n        for (const [key, element] of Object.entries(object)) {\n            extractBuffers(element, store);\n        }\n    } else if (ArrayBuffer.isView(object)) {\n        if (! (object.buffer instanceof ArrayBuffer)) {\n            throw \"only ArrayBuffers should be in the message payload\";\n        }\n        store.push(object.buffer);\n    }\n}\n\nexport function isObject(object) {\n    return typeof object === 'object' && Array.isArray(object) === false;\n}\n","import * as pako from \"pako\";\nimport * as d3 from \"d3-dsv\";\nimport * as scran from \"scran.js\";\n\nexport function extractHDF5Strings(handle, name) {\n    if (!(name in handle.children)) {\n        return null;\n    }\n\n    if (handle.children[name] !== \"DataSet\") {\n        return null;\n    }\n\n    let content = handle.open(name);\n    if (content.type !== \"String\") {\n        return null;\n    }\n\n    return content.load();\n}\n\nexport function readDSVFromBuffer(content, fname, delim = \"\\t\") {\n    var ext = fname.name.split('.').pop();\n\n    if (ext == \"gz\") {\n        content = pako.ungzip(content);\n    }\n\n    const dec = new TextDecoder();\n    let decoded = dec.decode(content);\n    const tsv = d3.dsvFormat(delim);\n    let parsed = tsv.parseRows(decoded);\n\n    return parsed;\n}\n\nexport function generateRandomName(prefix = \"\", suffix = \"\") {\n    return prefix + String(Number(new Date())) + suffix\n}\n","import * as scran from \"scran.js\";\nimport * as utils from \"./_utils.js\";\nimport * as rutils from \"./_utils_reader.js\";\n\nexport function formatFiles(args, bufferFun) {\n    var formatted = { \"format\": \"10X\", \"files\": [] };\n\n    if (args.file.length != 1) {\n        throw new Error(\"expected exactly one 'h5' file\");\n    }\n\n    let h5file = args.file[0];\n    formatted.files.push({ \"type\": \"h5\", \"name\": h5file.name, \"buffer\": bufferFun(h5file) });\n    return formatted;\n}\n\nfunction extract_features(handle) {\n    let genes = null;\n\n    if (!(\"matrix\" in handle.children) || handle.children[\"matrix\"] != \"Group\") {\n        throw new Error(\"expected a 'matrix' group at the top level of the file\");\n    }\n\n    let mhandle = handle.open(\"matrix\");\n    if (\"features\" in mhandle.children && mhandle.children[\"features\"] == \"Group\") {\n        let fhandle = mhandle.open(\"features\");\n\n        let ids = rutils.extractHDF5Strings(fhandle, \"id\");\n        if (ids !== null) {\n            genes = { id: ids };\n            let names = rutils.extractHDF5Strings(fhandle, \"name\");\n            if (names !== null) {\n                genes.name = names;\n            }\n        }\n    }\n\n    return genes;\n}\n\nexport function loadPreflight(input) {\n    let output = {};\n\n    const tmppath = rutils.generateRandomName(\"10x_\", \".h5\");\n    scran.writeFile(tmppath, new Uint8Array(input.files[0].buffer));\n    try {\n        let handle = new scran.H5File(tmppath);\n        output.genes = extract_features(handle);\n        output.annotations = null;\n        // TODO: try pull out sample IDs from the 10X file, if they exist?\n    } finally {\n        scran.removeFile(tmppath);\n    }\n\n    return output;\n}\n\nexport function loadData(input) {\n    let output = {};\n\n    const tmppath = rutils.generateRandomName(\"10x_\", \".h5\");\n    scran.writeFile(tmppath, new Uint8Array(input.files[0].buffer));\n    try {\n        output.matrix = scran.initializeSparseMatrixFromHDF5(tmppath, \"matrix\");\n        let handle = new scran.H5File(tmppath);\n        output.genes = extract_features(handle);\n        output.annotations = null;\n    } catch (e) {\n        utils.freeCache(output.matrix);\n        throw e;\n    } finally {\n        scran.removeFile(tmppath);\n    }\n\n    return output;\n}\n","import * as scran from \"scran.js\";\nimport * as utils from \"./_utils.js\";\nimport * as rutils from \"./_utils_reader.js\";\n\nexport function formatFiles(args, bufferFun) {\n    var formatted = { \"format\": \"H5AD\", \"files\": [] };\n\n    if (args.file.length != 1) {\n        throw new Error(\"expected exactly one 'h5' file\");\n    }\n\n    let h5file = args.file[0];\n    formatted.files.push({ \"type\": \"h5\", \"name\": h5file.name, \"buffer\": bufferFun(h5file) });\n    return formatted;\n}\n\nfunction extract_features(handle) {\n    let genes = null;\n\n    if (\"var\" in handle.children && handle.children[\"var\"] == \"Group\") {\n        let vhandle = handle.open(\"var\");\n        let index = rutils.extractHDF5Strings(vhandle, \"_index\");\n        if (index !== null) {\n            genes = { \"_index\": index };\n\n            for (const [key, val] of Object.entries(vhandle.children)) {\n                if (val === \"DataSet\" && (key.match(/name/i) || key.match(/symb/i))) {\n                    let dhandle2 = vhandle.open(key);\n                    if (dhandle2.type == \"String\") {\n                        genes[key] = dhandle2.load();\n                    }\n                }\n            }\n        }\n    }\n\n    return genes;\n}\n\nfunction extract_annotations(handle, { namesOnly = false } = {}) {\n    let annotations = null;\n\n    if (\"obs\" in handle.children && handle.children[\"obs\"] == \"Group\") {\n        let ohandle = handle.open(\"obs\");\n        annotations = {};\n\n        // Maybe it has names, maybe not, who knows; let's just add what's there.\n        let index = rutils.extractHDF5Strings(ohandle, \"_index\");\n        if (index !== null) {\n            annotations[\"_index\"] = index;\n        }\n\n        for (const [key, val] of Object.entries(ohandle.children)) {\n            if (val != \"DataSet\") {\n                continue;\n            }\n            let dhandle = ohandle.open(key);\n            if (dhandle.type != \"Other\") {\n                annotations[key] = (!namesOnly ? dhandle.load() : null);\n            }\n        }\n\n        if (!namesOnly && \"__categories\" in ohandle.children && ohandle.children[\"__categories\"] == \"Group\") {\n            let chandle = ohandle.open(\"__categories\");\n\n            for (const [key, val] of Object.entries(chandle.children)) {\n                if (key in annotations) {\n                    let cats = rutils.extractHDF5Strings(chandle, key);\n                    if (cats.type !== null) {\n                        annotations[key] = {\n                            \"type\": \"factor\",\n                            \"index\": val,\n                            \"factor\": cats\n                        }\n                    }\n                }\n            }\n        }\n    }\n\n    if (namesOnly && annotations !== null) {\n        return Object.keys(annotations);\n    } else {\n        return annotations;\n    }\n}\n\nexport function loadPreflight(input) {\n    let output = {};\n\n    const tmppath = rutils.generateRandomName(\"h5ad_\", \".h5\");\n    scran.writeFile(tmppath, new Uint8Array(input.files[0].buffer));\n    try {\n        let handle = new scran.H5File(tmppath);\n        output.genes = extract_features(handle);\n        let annotations = extract_annotations(handle, { load: false });\n        output.annotations = Object.keys(annotations); \n    } finally {\n        scran.removeFile(tmppath);\n    }\n\n    return output;\n}\n\nexport function loadData(input){\n    let output = {};\n\n    const tmppath = rutils.generateRandomName(\"h5ad_\", \".h5\");\n    scran.writeFile(tmppath, new Uint8Array(input.files[0].buffer));\n    try {\n        output.matrix = scran.initializeSparseMatrixFromHDF5(tmppath, \"X\");\n        let handle = new scran.H5File(tmppath);\n        output.genes = extract_features(handle); \n        output.annotations = extract_annotations(handle); // Adding the annotations.\n    } finally {\n        scran.removeFile(tmppath);\n    }\n\n    return output;\n}\n","import * as d3 from \"d3-dsv\";\nimport * as pako from \"pako\";\nimport * as scran from \"scran.js\";\nimport * as utils from \"./_utils.js\";\nimport * as rutils from \"./_utils_reader.js\";\n\nexport function formatFiles(args, bufferFun) {\n    var formatted = { \"format\": \"MatrixMarket\", \"files\": [] };\n\n    if (args.mtx.length != 1) {\n        throw new Error(\"expected exactly one 'mtx' file\");\n    }\n    var mtx_file = args.mtx[0];\n    formatted.files.push({ \"type\": \"mtx\", \"name\": mtx_file.name, \"buffer\": bufferFun(mtx_file) });\n\n    if (\"gene\" in args) {\n        if (args.gene.length !== 1) {\n            throw \"expected no more than one gene file\";\n        }\n        var genes_file = args.gene[0];\n        formatted.files.push({ \"type\": \"genes\", \"name\": genes_file.name, \"buffer\": bufferFun(genes_file) });\n    }\n\n    if (\"barcode\" in args) {\n        if (args.barcode.length !== 1) {\n            throw \"expected no more than one cell annotation file\";\n        }\n        var annotations_file = args.barcode[0];\n        formatted.files.push({ \"type\": \"annotations\", \"name\": annotations_file.name, \"buffer\": bufferFun(annotations_file) });\n    }\n\n    return formatted;\n}\n\nexport function extractFeatures(files, { numberOfRows = null } = {}) {\n    let genes = null;\n    const genes_file = files.filter(x => x.type == \"genes\");\n\n    if (genes_file.length == 1) {\n        const gene_file = genes_file[0]\n        const content = new Uint8Array(gene_file.buffer);\n\n        let parsed = rutils.readDSVFromBuffer(content, gene_file);\n        if (numberOfRows !== null && parsed.length !== numberOfRows) {\n            throw new Error(\"number of matrix rows is not equal to the number of genes in '\" + gene_file.name + \"'\");\n        }\n\n        var ids = [], symb = [];\n        parsed.forEach(x => {\n            ids.push(x[0]);\n            symb.push(x[1]);\n        });\n\n        genes = { \"id\": ids, \"symbol\": symb };\n    }\n\n    return genes;\n}\n\nfunction extractAnnotations(files, { numberOfColumns = null, namesOnly = false } = {}) {\n    let annotations = null;\n    const annotations_file = files.filter(x => x.type == \"annotations\");\n\n    if (annotations_file.length == 1) {\n        const annotation_file = annotations_file[0]\n        const content = new Uint8Array(annotation_file.buffer);\n        let parsed = rutils.readDSVFromBuffer(content, annotation_file);\n\n        // Check if a header is present or not\n        let headerFlag = true;\n        if (numberOfColumns !== null) {\n            let diff = numberOfColumns - parsed.length;\n            if (diff === 0) {\n                headerFlag = false;\n            } else if (diff !== -1) {\n                throw \"number of annotations rows is not equal to the number of cells in '\" + annotation_file.name + \"'\";\n            }\n        }\n\n        let headers;\n        if (headerFlag) {\n            headers = parsed.shift();\n        } else {\n            headers = parsed[0]; // whatever, just using the first row. Hope they're unique enough!\n        }\n\n        if (namesOnly) {\n            annotations = headers;\n        } else {\n            annotations = {}\n            headers.forEach((x, i) => {\n                annotations[x] = parsed.map(y => y[i]);\n            });\n        }\n    }\n\n    return annotations;\n}\n\nexport function loadPreflight(input) {\n    return {\n        genes: extractFeatures(input.files),\n        annotations: extractAnnotations(input.files, { namesOnly: true })\n    };\n}\n\nexport function loadData(input) {\n    var mtx_files = input.files.filter(x => x.type == \"mtx\");\n\n    var first_mtx = mtx_files[0];\n    var contents = new Uint8Array(first_mtx.buffer);\n    var ext = first_mtx.name.split('.').pop();\n    var is_compressed = (ext == \"gz\");\n\n    let output = {};\n    try {\n        output.matrix = scran.initializeSparseMatrixFromMatrixMarketBuffer(contents, { \"compressed\": is_compressed });\n        output.genes = extractFeatures(input.files, { numberOfRows: output.matrix.numberOfRows() });\n        output.annotations = extractAnnotations(input.files, { numberOfColumns: output.matrix.numberOfColumns() });\n    } catch (e) {\n        utils.freeCache(output.matrix);\n        throw e;\n    }\n\n    return output;\n}\n","import * as scran from \"scran.js\";\nimport * as TENxReader from \"./_reader_10x.js\";\nimport * as H5ADReader from \"./_reader_h5ad.js\";\nimport * as MtxReader from \"./_reader_mtx.js\";\n\nexport function fetchGeneTypes(obj) {\n    if (!(\"gene_types\" in obj.cache)) {\n        var gene_info_type = {};\n        var gene_info = obj.cache.genes;\n        for (const [key, val] of Object.entries(gene_info)) {\n            gene_info_type[key] = scran.guessFeatures(val);\n        }\n        cache.gene_types = gene_info_type;\n    }\n    return cache.gene_types;\n}\n\nexport function guessBestFeatures(dataset) {\n    let scores = {}, fields = {};\n    for (const f in dataset.genes) {\n        let fscore = scran.guessFeatures(dataset.genes[f]);\n\n        if ((!scores[`${fscore.type}-${fscore.species}`]) ||\n            fscore.confidence > scores[`${fscore.type}-${fscore.species}`]) {\n            scores[`${fscore.type}-${fscore.species}`] = fscore.confidence;\n            fields[`${fscore.type}-${fscore.species}`] = f;\n        }\n    }\n\n    return { scores, fields };\n}\n\nexport function getCommonGenes(datasets) {\n    // now perform intersection\n    let num_common_genes = 0;\n    let keys = Object.keys(datasets);\n\n    let scores = {\n        \"symbol-mouse\": [],\n        \"symbol-human\": [],\n        \"ensembl-mouse\": [],\n        \"ensembl-human\": [],\n    };\n\n    let fields = JSON.parse(JSON.stringify(scores));\n\n    for (let j = 0; j < keys.length; j++) {\n        let fscores = guessBestFeatures(datasets[keys[j]]);\n\n        for (const i in fscores.fields) {\n            fields[i].push(fscores.fields[i]);\n        }\n\n        for (const i in fscores.scores) {\n            scores[i].push(fscores.scores[i]);\n        }\n    }\n\n    let multiplier = -1000;\n    let bscore;\n\n    for (const i in scores) {\n        if (scores[i].length == keys.length) {\n            let nscore = scores[i].reduce((a, b) => a * b);\n            if (nscore > multiplier) {\n                multiplier = nscore;\n                bscore = i;\n            }\n        }\n    }\n\n    let intersection;\n    if (bscore) {\n        intersection = datasets[keys[0]].genes[fields[bscore][0]];\n        for (var i = 1; i < Object.keys(datasets).length; i++) {\n            let dset = new Set(datasets[keys[i]].genes[fields[bscore][i]]);\n            intersection = intersection.filter((n) => {\n                return dset.has(n);\n            });\n        }\n        num_common_genes = intersection.length;\n    }\n\n    return {\n        \"num_common_genes\": num_common_genes,\n        \"intersection\": intersection,\n        \"best_fields\": bscore ? fields[bscore] : null\n    };\n}\n\nexport function chooseNamespace(format) {\n    let namespace;\n    switch (format) {\n        case \"mtx\":\n        case \"MatrixMarket\":\n            namespace = MtxReader;\n            break;\n        case \"tenx\":\n        case \"hdf5\":\n        case \"10X\":\n            namespace = TENxReader;\n            break;\n        case \"h5ad\":\n        case \"H5AD\":\n            namespace = H5ADReader;\n            break;\n        default:\n            throw \"unknown matrix file extension: '\" + format + \"'\";\n    }\n    return namespace;\n}\n","import * as scran from \"scran.js\";\nimport * as utils from \"./_utils.js\";\nimport * as iutils from \"./_utils_inputs.js\";\n\nvar cache = {};\nvar parameters = {};\nvar abbreviated = {};\n\nexport var changed = false;\n\nfunction dummy_genes(numberOfRows) {\n    let genes = []\n    for (let i = 0; i < numberOfRows; i++) {\n        genes.push(`Gene ${i + 1}`);\n    }\n    return { \"id\": genes };\n}\n\nfunction process_datasets(files, sample_factor) {\n    // Loading all of the individual matrices.\n    let datasets = {};\n    try {\n        for (const [key, val] of Object.entries(files)) {\n            let namespace = iutils.chooseNamespace(val.format);\n            let current = namespace.loadData(val);\n\n            if (!(\"genes\" in current)) {\n                current.genes = dummy_genes(current.matrix.numberOfRows());\n            } \n            if (current.matrix.isPermuted()) {\n                scran.permuteFeatures(current.matrix, current.genes);\n            }\n\n            datasets[key] = current;\n        }\n    } catch (e) {\n        // If any one fails, we free the rest.\n        for (const [key, val] of Object.entries(datasets)){\n            utils.freeCache(val.matrix);\n        }\n        throw e;\n    }\n\n    // Ensure we have a reproducible order; otherwise the batch\n    // order becomes dependent on the JS engine's ordering.\n    let dkeys = Object.keys(datasets);\n    dkeys.sort();\n\n    if (dkeys.length == 1) {\n        let current = datasets[dkeys[0]];\n        let blocks = null;\n        let block_levels = null;\n\n        if (sample_factor && sample_factor !== null) {\n            // Single matrix with a batch factor.\n            try {\n                let anno_batch = current.annotations[sample_factor];\n                let ncols = current.matrix.numberOfColumns();\n                if (anno_batch.length != ncols) {\n                    throw new Error(\"length of sample factor '\" + sample_factor + \"' should be equal to the number of cells\"); \n                }\n\n                blocks = scran.createInt32WasmArray(ncols);\n                block_levels = [];\n                let block_arr = blocks.array();\n\n                let uvals = {};\n                anno_batch.forEach((x, i) => {\n                    if (!(x in uvals)) {\n                        uvals[x] = block_levels.length;\n                        block_levels.push(x);\n                    }\n                    block_arr[i] = uvals[x];\n                });\n            } catch (e) {\n                utils.freeCache(blocks);\n                utils.freeCache(current.matrix);\n                throw e;\n            }\n        }\n\n        current.block_ids = blocks;\n        current.block_levels = block_levels;\n        return current;\n\n    } else {\n        // Multiple matrices, each of which represents a batch.\n        let output = {}\n        let blocks;\n\n        try {\n            // Identify the gene columns to use\n            let result = iutils.getCommonGenes(datasets);\n            let best_fields = result.best_fields;\n\n            let gnames = [];\n            let mats = [];\n            let total = 0;\n            for (var i = 0; i < dkeys.length; i++) {\n                let current = datasets[dkeys[i]];\n                gnames.push(current.genes[best_fields[i]]);\n                mats.push(current.matrix);\n                total += current.matrix.numberOfColumns();\n            }\n\n            blocks = scran.createInt32WasmArray(total);\n            let barr = blocks.array();\n            let nice_barr = new Array(total);\n            let sofar = 0;\n            for (var i = 0; i < dkeys.length; i++) {\n                let old = sofar;\n                let current = datasets[dkeys[i]];\n                sofar += current.matrix.numberOfColumns();\n                barr.fill(i, old, sofar);\n                nice_barr.fill(dkeys[i], old, sofar);\n            }\n            output.block_ids = blocks;\n            output.block_levels = dkeys;\n\n            let merged = scran.cbindWithNames(mats, gnames);\n            output.matrix = merged.matrix;\n\n            // Storing the identities of the genes in terms of the\n            // original row indices of the first matrix.\n            let firstperm = mats[0].permutation({ restore: false });\n            output.indices = merged.indices.map(i => firstperm[i]);\n\n            // Extracting gene information from the first object. We won't make\n            // any attempt at merging and deduplication across objects.\n            let included = new Set(merged.indices);\n            output.genes = {};\n            let first_genes = datasets[dkeys[0]].genes;\n            for (const [key, val] of Object.entries(first_genes)) {\n                output.genes[key] = val.filter((x, i) => included.has(i));\n            }\n\n            // Get all annotations keys across datasets; we then concatenate\n            // columns with the same name, or we just fill them with missings.\n            let ckeys = new Set();\n            for (const d of dkeys) {\n                let current = datasets[d];\n                if (current.annotations !== null) {\n                    for (const a of Object.keys(current.annotations)) {\n                        ckeys.add(a);\n                    }\n                }\n            }\n            let anno_keys = [...ckeys];\n\n            let combined_annotations = {};\n            for (const i of anno_keys) {\n                let current_combined = [];\n                for (const d of dkeys) {\n                    let current = datasets[d];\n                    let x;\n                    if (current.annotations && current.annotations[i]) {\n                        x = current.annotations[i];\n                        if (!(x instanceof Array)) {\n                            x = Array.from(x);\n                        }\n                    } else {\n                        x = new Array(current.matrix.numberOfColumns());\n                    }\n                    current_combined = current_combined.concat(x);\n                }\n                combined_annotations[i] = current_combined;\n            }\n\n            output.annotations = combined_annotations;\n            output.annotations[\"__batch__\"] = nice_barr;\n\n        } catch (e) {\n            utils.freeCache(blocks);\n            throw e;\n\n        } finally {\n            // Once the merged dataset is created, the individual dataset\n            // matrices are no longer useful, so we need to delete them anyway.\n            for (const v of Object.values(datasets)) {\n                utils.freeCache(v.matrix);\n            }\n        }\n\n        return output;\n    }\n}\n\nexport function process_and_cache(new_files, sample_factor) {\n    let contents = process_datasets(new_files, sample_factor);\n    cache.matrix = contents.matrix;\n    cache.genes = contents.genes;\n    cache.annotations = contents.annotations;\n    cache.block_ids = contents.block_ids;\n    cache.block_levels = contents.block_levels;\n    cache.indices = contents.indices;\n    return \n}\n\n/******************************\n ****** Standard exports ******\n ******************************/\n\nexport function compute(files, sample_factor) {\n    // Don't bother proceeding with any of the below\n    // if we're operating from a reloaded state.\n    let entries = Object.entries(files);\n    if (entries.length == 1) {\n        let form = entries[0][1].format;\n        if (form == \"kana\" || form == \"kanadb\") {\n            return;\n        }\n    }\n\n    changed = true;\n\n    let tmp_abbreviated = {};\n    for (const [key, val] of entries) {\n        let namespace = iutils.chooseNamespace(val.format);\n        tmp_abbreviated[key] = namespace.formatFiles(val, f => f.size);\n    }\n\n    if (!utils.changedParameters(tmp_abbreviated, abbreviated) && parameters.sample_factor === sample_factor) {\n        changed = false;\n        return;\n    }\n\n    let new_files = {};\n    for (const [key, val] of Object.entries(files)) {\n        let namespace = iutils.chooseNamespace(val.format);\n        new_files[key] = namespace.formatFiles(val, f => (new FileReaderSync()).readAsArrayBuffer(f));\n    }\n\n    utils.freeCache(cache.matrix);\n    utils.freeCache(cache.block_ids);\n    process_and_cache(new_files, sample_factor);\n\n    abbreviated = tmp_abbreviated;\n    parameters.files = new_files;\n    parameters.sample_factor = sample_factor;\n\n    return;\n}\n\nexport function results() {\n    var output = {\n        \"dimensions\": {\n            \"num_genes\": cache.matrix.numberOfRows(),\n            \"num_cells\": cache.matrix.numberOfColumns()\n        },\n        \"genes\": { ...cache.genes }\n    };\n    if (cache.annotations) {\n        output.annotations = Object.keys(cache.annotations);\n    }\n    return output;\n}\n\nexport async function serialize(handle, saver, embedded) {\n    let ghandle = handle.createGroup(\"inputs\");\n\n    let multifile = false;\n    {\n        let phandle = ghandle.createGroup(\"parameters\");\n\n        let formats = [];\n        let files = [];\n        let names = [];\n        let numbers = [];\n\n        for (const [key, val] of Object.entries(parameters.files)) {\n            formats.push(val.format);\n            for (const x of val.files) {\n                files.push(x);\n            }\n            names.push(key);\n            numbers.push(val.files.length);\n        }\n\n        if (formats.length > 1) {\n            multifile = true;\n            phandle.writeDataSet(\"format\", \"String\", null, formats);\n            phandle.writeDataSet(\"sample_groups\", \"Int32\", null, numbers);\n            phandle.writeDataSet(\"sample_names\", \"String\", null, names);\n        } else {\n            phandle.writeDataSet(\"format\", \"String\", [], formats[0]);\n        }\n\n        let fihandle = phandle.createGroup(\"files\");\n        for (const [index, obj] of files.entries()) {\n            let curhandle = fihandle.createGroup(String(index));\n            curhandle.writeDataSet(\"type\", \"String\", [], obj.type);\n            curhandle.writeDataSet(\"name\", \"String\", [], obj.name);\n\n            let res = await saver(obj);\n            if (embedded) {\n                curhandle.writeDataSet(\"offset\", \"Uint32\", [], res.offset);\n                curhandle.writeDataSet(\"size\", \"Uint32\", [], res.size);\n            } else {\n                curhandle.writeDataSet(\"id\", \"String\", [], res);\n            }\n        }\n    }\n\n    {\n        let rhandle = ghandle.createGroup(\"results\");\n        rhandle.writeDataSet(\"dimensions\", \"Int32\", null, [cache.matrix.numberOfRows(), cache.matrix.numberOfColumns()]);\n\n        // For diagnostic purposes, we store the number of samples;\n        // this may not be captured by the parameters if we're dealing\n        // with a sample_factor from a single file.\n        if (cache.block_levels !== null) {\n            rhandle.writeDataSet(\"num_samples\", \"Int32\", [], cache.block_levels.length); \n        }\n\n        if (multifile) {\n            rhandle.writeDataSet(\"indices\", \"Int32\", null, cache.indices);\n        } else {\n            rhandle.writeDataSet(\"permutation\", \"Int32\", null, cache.matrix.permutation({ copy: \"view\" }));\n        }\n    }\n\n    return;\n}\n\nexport async function unserialize(handle, loader, embedded) {\n    let ghandle = handle.open(\"inputs\");\n    let phandle = ghandle.open(\"parameters\");\n\n    // Extracting the files.\n    let fihandle = phandle.open(\"files\");\n    let kids = fihandle.children;\n    let all_files = new Array(kids.length);\n\n    for (const x of Object.keys(kids)) {\n        let current = fihandle.open(x);\n\n        let curfile = {};\n        for (const field of [\"type\", \"name\"]) {\n            let dhandle = current.open(field, { load: true });\n            curfile[field] = dhandle.values[0];\n        }\n\n        if (!embedded) {\n            let dhandle = current.open(\"id\", { load: true });\n            curfile.buffer = await loader(dhandle.values[0]);\n        } else {\n            let buffer_deets = {};\n            for (const field of [\"offset\", \"size\"]) {\n                let dhandle = current.open(field, { load: true });\n                buffer_deets[field] = dhandle.values[0];\n            }\n            curfile.buffer = await loader(buffer_deets.offset, buffer_deets.size);\n        }\n\n        let idx = Number(x);\n        all_files[idx] = curfile;\n    }\n\n    // Extracting the format and organizing the files.\n    parameters = { files: {}, sample_factor: null };\n    let fohandle = phandle.open(\"format\", { load: true });\n    let solofile = (fohandle.shape.length == 0);\n    if (solofile) {\n        parameters.files[\"default\"] = {\n            format: fohandle.values[0],\n            files: all_files\n        };\n\n        let sf = null;\n        if (\"sample_factor\" in phandle.children) {\n            sf = phandle.open(\"sample_factor\", { load: true }).values[0];\n        }\n        parameters.sample_factor = sf;\n\n    } else {\n        let formats = fohandle.values;\n        let sample_names = phandle.open(\"sample_names\", { load: true }).values;\n        let sample_groups = phandle.open(\"sample_groups\", { load: true }).values;\n\n        let sofar = 0;\n        for (var i = 0; i < formats.length; i++) {\n            let curfiles = [];\n            for (var j = 0; j < sample_groups[i]; j++) {\n                curfiles.push(all_files[sofar]);\n                sofar++;\n            }\n\n            parameters.files[sample_names[i]] = {\n                format: formats[i],\n                files: curfiles\n            };\n        }\n    }\n\n    // Loading matrix data.\n    process_and_cache(parameters.files, parameters.sample_factor);\n\n    // We need to do something if the permutation is not the same.\n    let rhandle = ghandle.open(\"results\");\n    let permuter;\n    if (solofile) {\n        let perm = null;\n        if (\"permutation\" in rhandle.children) {\n            let dhandle = rhandle.open(\"permutation\", { load: true });\n            perm = scran.updatePermutation(cache.matrix, dhandle.values);\n        } else {\n            // Otherwise, we're dealing with v0 states. We'll just\n            // assume it was the same, I guess. Should be fine as we didn't change\n            // the permutation code in v0.\n        }\n\n        if (perm !== null) {\n            // Adding a permuter function for all per-gene vectors.\n            permuter = (x) => {\n                let temp = x.slice();\n                x.forEach((y, i) => {\n                    temp[i] = x[perm[i]];\n                });\n                x.set(temp);\n                return;\n            };\n        } else {\n            permuter = (x) => { };\n        }\n    } else {\n        let old_indices = rhandle.open(\"indices\", { load: true }).values;\n        let new_indices = cache.indices;\n        if (old_indices.length != new_indices.length) {\n            throw new Error(\"old and new indices must have the same length for results to be interpretable\");\n        }\n\n        let same = true;\n        for (var i = 0; i < old_indices.length; i++) {\n            if (old_indices[i] != new_indices[i]) {\n                same = false\n                break\n            }\n        }\n\n        if (same) {\n            permuter = (x) => {};\n        } else {\n            let remap = {};\n            old_indices.forEach((x, i) => {\n                remap[x] = i;\n            });\n            let perm = new_indices.map(o => {\n                if (!(o in remap) || remap[o] === null) {\n                    throw new Error(\"old and new indices should contain the same row identities\");\n                }\n                let pos = remap[o];\n                remap[o] = null;\n                return pos;\n            });\n            permuter = (x) => {\n                return x.map((y, i) => x[perm[i]]);\n            };\n        }\n    }\n\n    return permuter;\n}\n\n/****************************\n ****** Custom exports ******\n ****************************/\n\nexport function fetchCountMatrix() {\n    return cache.matrix;\n}\n\nexport function fetchGenes() {\n    return cache.genes;\n}\n\nexport function fetchGeneTypes() {\n    if (!(\"gene_types\" in cache)) {\n        var gene_info_type = {};\n        var gene_info = fetchGenes();\n        for (const [key, val] of Object.entries(gene_info)) {\n            gene_info_type[key] = scran.guessFeatures(val);\n        }\n        cache.gene_types = gene_info_type;\n    }\n    return cache.gene_types;\n}\n\nexport function fetchAnnotations(col) {\n    let annots = cache.annotations;\n    let size = cache.matrix.numberOfColumns();\n\n    if (!(col in annots)) {\n        throw `column ${col} does not exist in col.tsv`;\n    }\n\n    if (utils.isObject(annots[col]) && \"type\" in annots[col]) {\n        return annots[col];\n    }\n\n    let uvals = {};\n    let uTypedAray = new Uint8Array(size);\n    annots[col].map((x, i) => {\n        if (!(x in uvals)) {\n            uvals[x] = Object.keys(uvals).length;\n        }\n\n        uTypedAray[i] = uvals[x];\n    });\n\n    return {\n        \"index\": Object.keys(uvals),\n        \"factor\": uTypedAray\n    }\n}\n\nexport function fetchBlock() {\n    return cache.block_ids;\n}\n\nexport function fetchBlockLevels() {\n    return cache.block_levels;\n}\n","import * as utils from \"./_utils.js\";\nimport * as iutils from \"./_utils_inputs.js\";\n\nfunction validate_files(datasets) {\n    // possible check if genes is empty in atleast one of them\n    let all_valid = true;\n    let common_genes = 0;\n    let fkeys = Object.keys(datasets);\n    let annotation_names = [];\n    let error_messages = []\n\n    // do all datasets contain genes ?\n    for (const [key, val] of Object.entries(datasets)) {\n        if (!(\"genes\" in val)) {\n            all_valid = false;\n            if (fkeys.length > 1) {\n                error_messages.push(\"all imported datasets must contain genes for integration/batch correction\");\n                break;\n            }\n        }\n        annotation_names.push(val.annotations);\n    }\n\n    // if all files contain genes, run checks to see if they have common genes;\n    // we don't do this if the earlier step already failed\n    let result;\n    if (all_valid) {\n        result = iutils.getCommonGenes(datasets);\n        common_genes = result?.num_common_genes;\n\n        // if there are no common genes\n        if (common_genes == 0) {\n            all_valid = false;\n            error_messages.push(\"no common genes across datasets\");\n        }\n\n        if (fkeys.length !== 1) {\n            // also check if the assumptions in guessing the best column to use for genes \n            // is consistent across datasets\n            // e.g. dataset1 is human and dataset2 cannot be mouse\n            // TODO: not sure if this is useful anymore \n            // I guess the common genes would've failed in this case\n            if (!result?.best_fields) {\n                all_valid = false;\n                error_messages.push(\"we cannot guess the best set of feature columns to use for integrating datasets\");\n            }\n        }\n    }\n\n    // if there's only a single dataset; none of the above holds\n    // the ui takes care of batch column selection\n    if (fkeys.length == 1) {\n        all_valid = true;\n    }\n\n    return {\n        \"valid\": all_valid,\n        \"common_genes\": common_genes,\n        \"annotations\": annotation_names,\n        \"errors\": error_messages,\n        \"best_genes\": result.best_fields\n    }\n}\n\n/******************************\n ****** Standard exports ******\n ******************************/\n\nexport function compute(files) {\n    let datasets = {};\n\n    for (const [key, val] of Object.entries(files)) {\n        let namespace = iutils.chooseNamespace(val.format);\n        let formatted = namespace.formatFiles(val, f => (new FileReaderSync()).readAsArrayBuffer(f));\n        datasets[key] = namespace.loadPreflight(formatted);\n    }\n\n    return validate_files(datasets);\n}\n","/* Derived from scran.js's blacklists.js.R. */\n\nexport var mito = {};\nmito.ensembl = new Set([\"ENSMUSG00000064336\",\"ENSMUSG00000064337\",\"ENSMUSG00000064338\",\"ENSMUSG00000064339\",\"ENSMUSG00000064340\",\"ENSMUSG00000064341\",\"ENSMUSG00000064342\",\"ENSMUSG00000064343\",\"ENSMUSG00000064344\",\"ENSMUSG00000064345\",\"ENSMUSG00000064346\",\"ENSMUSG00000064347\",\"ENSMUSG00000064348\",\"ENSMUSG00000064349\",\"ENSMUSG00000064350\",\"ENSMUSG00000064351\",\"ENSMUSG00000064352\",\"ENSMUSG00000064353\",\"ENSMUSG00000064354\",\"ENSMUSG00000064355\",\"ENSMUSG00000064356\",\"ENSMUSG00000064357\",\"ENSMUSG00000064358\",\"ENSMUSG00000064359\",\"ENSMUSG00000064360\",\"ENSMUSG00000064361\",\"ENSMUSG00000064363\",\"ENSMUSG00000064364\",\"ENSMUSG00000064365\",\"ENSMUSG00000064366\",\"ENSMUSG00000064367\",\"ENSMUSG00000064368\",\"ENSMUSG00000064369\",\"ENSMUSG00000064370\",\"ENSMUSG00000064371\",\"ENSMUSG00000064372\",\"ENSMUSG00000065947\",\"ENSG00000198695\",\"ENSG00000198712\",\"ENSG00000198727\",\"ENSG00000198763\",\"ENSG00000198786\",\"ENSG00000198804\",\"ENSG00000198840\",\"ENSG00000198886\",\"ENSG00000198888\",\"ENSG00000198899\",\"ENSG00000198938\",\"ENSG00000209082\",\"ENSG00000210049\",\"ENSG00000210077\",\"ENSG00000210082\",\"ENSG00000210100\",\"ENSG00000210107\",\"ENSG00000210112\",\"ENSG00000210117\",\"ENSG00000210127\",\"ENSG00000210135\",\"ENSG00000210140\",\"ENSG00000210144\",\"ENSG00000210151\",\"ENSG00000210154\",\"ENSG00000210156\",\"ENSG00000210164\",\"ENSG00000210174\",\"ENSG00000210176\",\"ENSG00000210184\",\"ENSG00000210191\",\"ENSG00000210194\",\"ENSG00000210195\",\"ENSG00000210196\",\"ENSG00000211459\",\"ENSG00000212907\",\"ENSG00000228253\"]);\nmito.symbol = new Set([\"mt-Tf\",\"mt-Rnr1\",\"mt-Tv\",\"mt-Rnr2\",\"mt-Tl1\",\"mt-Nd1\",\"mt-Ti\",\"mt-Tq\",\"mt-Tm\",\"mt-Nd2\",\"mt-Tw\",\"mt-Ta\",\"mt-Tn\",\"mt-Tc\",\"mt-Ty\",\"mt-Co1\",\"mt-Ts1\",\"mt-Td\",\"mt-Co2\",\"mt-Tk\",\"mt-Atp8\",\"mt-Atp6\",\"mt-Co3\",\"mt-Tg\",\"mt-Nd3\",\"mt-Tr\",\"mt-Nd4\",\"mt-Th\",\"mt-Ts2\",\"mt-Tl2\",\"mt-Nd5\",\"mt-Nd6\",\"mt-Te\",\"mt-Cytb\",\"mt-Tt\",\"mt-Tp\",\"mt-Nd4l\",\"MT-ND6\",\"MT-CO2\",\"MT-CYB\",\"MT-ND2\",\"MT-ND5\",\"MT-CO1\",\"MT-ND3\",\"MT-ND4\",\"MT-ND1\",\"MT-ATP6\",\"MT-CO3\",\"MT-TL1\",\"MT-TF\",\"MT-TV\",\"MT-RNR2\",\"MT-TI\",\"MT-TQ\",\"MT-TM\",\"MT-TW\",\"MT-TA\",\"MT-TN\",\"MT-TC\",\"MT-TY\",\"MT-TS1\",\"MT-TD\",\"MT-TK\",\"MT-TG\",\"MT-TR\",\"MT-TH\",\"MT-TS2\",\"MT-TL2\",\"MT-TE\",\"MT-TT\",\"MT-TP\",\"MT-RNR1\",\"MT-ND4L\",\"MT-ATP8\"]);\n","import * as scran from \"scran.js\"; \nimport * as utils from \"./_utils.js\";\nimport * as inputs from \"./_inputs.js\";\nimport { mito } from \"./mito.js\";\n\nvar cache = {};\nvar parameters = {};\n\nexport var changed = false;\n\n/***************************\n ******** Compute **********\n ***************************/\n\nfunction computeMetrics(use_mito_default, mito_prefix) {\n    var mat = inputs.fetchCountMatrix();\n\n    // TODO: add more choices.\n    var nsubsets = 1;\n    var subsets = utils.allocateCachedArray(mat.numberOfRows() * nsubsets, \"Uint8Array\", cache, \"metrics_buffer\");\n    subsets.fill(0);\n\n    // Finding the prefix.\n    // TODO: use the guessed features to narrow the Ensembl/symbol search.\n    var gene_info = inputs.fetchGenes();\n    var sub_arr = subsets.array();\n    for (const [key, val] of Object.entries(gene_info)) {\n        if (use_mito_default) {\n            val.forEach((x, i) => {\n                if (mito.symbol.has(x) || mito.ensembl.has(x)) {\n                    sub_arr[i] = 1;\n                }\n            });\n        } else {\n            var lower_mito = mito_prefix.toLowerCase();\n            val.forEach((x, i) => {\n                if(x.toLowerCase().startsWith(lower_mito)) {\n                    sub_arr[i] = 1;\n                }\n            });\n        }\n    }\n\n    utils.freeCache(cache.metrics);\n    cache.metrics = scran.computePerCellQCMetrics(mat, subsets);\n    return;\n}\n\nfunction computeFilters(nmads) {\n    let block = inputs.fetchBlock();\n    utils.freeCache(cache.filters);\n    cache.filters = scran.computePerCellQCFilters(cache.metrics, { numberOfMADs: nmads, block: block });\n    return;\n}\n\nfunction applyFilters() {\n    var mat = inputs.fetchCountMatrix();\n    var disc = fetchDiscards();\n    utils.freeCache(cache.matrix);\n    cache.matrix = scran.filterCells(mat, disc);\n\n    let block = inputs.fetchBlock();\n\n    cache.blocked = (block !== null);\n    if (cache.blocked) {\n        let bcache = utils.allocateCachedArray(cache.matrix.numberOfColumns(), \"Int32Array\", cache, \"block_buffer\");\n\n        let bcache_arr = bcache.array();\n        let block_arr = block.array();\n        let disc_arr = disc.array();\n        let j = 0;\n        for (let i = 0; i < block_arr.length; i++) {\n            if (disc_arr[i] == 0) {\n                bcache_arr[j] = block_arr[i];\n                j++;\n            }\n        }\n    }\n\n    return;\n}\n\nexport function compute(use_mito_default, mito_prefix, nmads) {\n    let run_metrics = (inputs.changed || use_mito_default !== parameters.use_mito_default || mito_prefix !== parameters.mito_prefix);\n    let run_filters = (run_metrics || nmads !== parameters.nmads);\n    let run_apply = (run_filters);\n\n    // Checking whether each step needs content from the preceding steps.\n    // This is necessary when working with reloaded states and we want to rerun\n    // some later steps but still need to generate their prerequisites.\n    if (cache.filters instanceof QCFiltersMimic) {\n        if (run_apply) {\n            run_filters = true;\n        }\n    }\n    if (cache.metrics instanceof QCMetricsMimic) {\n        if (run_apply || run_filters) {\n            run_metrics = true;\n        }\n    }\n\n    // Running the steps.\n    if (run_metrics) {\n        computeMetrics(use_mito_default, mito_prefix);\n        parameters.use_mito_default = use_mito_default;\n        parameters.mito_prefix = mito_prefix;\n    }\n\n    if (run_filters) {\n        computeFilters(nmads);\n        parameters.nmads = nmads;\n    }\n\n    if (run_apply) {\n        applyFilters();\n        changed = true;\n    }\n\n    return;\n}\n\n/***************************\n ******** Results **********\n ***************************/\n\nfunction getData(copy = true) {\n    copy = utils.copyOrView(copy);\n    return {\n        sums: cache.metrics.sums({ copy: copy }),\n        detected: cache.metrics.detected({ copy: copy }),\n        proportion: cache.metrics.subsetProportions(0, { copy: copy })\n    };\n}\n\nfunction getThresholds(copy = true) {\n    copy = utils.copyOrView(copy);\n    return {\n        sums: cache.filters.thresholdsSums({ copy: copy }),\n        detected: cache.filters.thresholdsDetected({ copy: copy }),\n        proportion: cache.filters.thresholdsSubsetProportions(0, { copy: copy })\n    }\n}\n\nexport function results() {\n    var data = {};\n    var blocks = inputs.fetchBlockLevels();\n    if (blocks === null) {\n        blocks = [ \"default\" ];\n        data[\"default\"] = getData();\n    } else {\n        let metrics = getData();\n        let bids = inputs.fetchBlock();\n        let barray = bids.array();\n\n        for (var b = 0; b < blocks.length; b++) {\n            let current = {};\n            for (const [key, val] of Object.entries(metrics)) {\n                current[key] = val.filter((x, i) => barray[i] == b);\n            }\n            data[blocks[b]] = current;\n        }\n    }\n\n    var thresholds = {};\n    let listed = getThresholds();\n    for (var b = 0; b < blocks.length; b++) {\n        let current = {};\n        for (const [key, val] of Object.entries(listed)) {\n            current[key] = val[b];\n        }\n        thresholds[blocks[b]] = current;\n    }\n\n    var ranges = {};\n    for (var b = 0; b < blocks.length; b++) {\n        let curranges = {};\n        let curdata = data[blocks[b]];\n\n        for (const [key, val] of Object.entries(curdata)) {\n            var max = -Infinity, min = Infinity;\n            val.forEach(function (x) {\n                if (max < x) {\n                    max = x;\n                }\n                if (min > x) {\n                    min = x;\n                }\n            });\n            curranges[key] = [min, max];\n        }\n\n        ranges[blocks[b]] = curranges;\n    }\n\n    let remaining = 0;\n    if (\"matrix\" in cache) {\n        remaining = cache.matrix.numberOfColumns();\n    } else {\n        fetchDiscards().array().forEach(x => {\n            if (x == 0) {\n                remaining++;\n            }\n        });\n    }\n\n    return { \n        \"data\": data, \n        \"ranges\": ranges,\n        \"thresholds\": thresholds,\n        \"retained\": remaining\n    };\n}\n\n/**********************************\n ******** Saving/loading **********\n **********************************/\n\nexport function serialize(handle) {\n    let ghandle = handle.createGroup(\"quality_control\");\n\n    {\n        let phandle = ghandle.createGroup(\"parameters\"); \n        phandle.writeDataSet(\"use_mito_default\", \"Uint8\", [], Number(parameters.use_mito_default));\n        phandle.writeDataSet(\"mito_prefix\", \"String\", [], parameters.mito_prefix);\n        phandle.writeDataSet(\"nmads\", \"Float64\", [], parameters.nmads);\n    }\n\n    {\n        let rhandle = ghandle.createGroup(\"results\"); \n\n        {\n            let mhandle = rhandle.createGroup(\"metrics\");\n            let data = getData(false);\n            mhandle.writeDataSet(\"sums\", \"Float64\", null, data.sums)\n            mhandle.writeDataSet(\"detected\", \"Int32\", null, data.detected);\n            mhandle.writeDataSet(\"proportion\", \"Float64\", null, data.proportion);\n        }\n\n        {\n            let thandle = rhandle.createGroup(\"thresholds\");\n            let thresholds = getThresholds(false);\n            for (const x of [ \"sums\", \"detected\", \"proportion\" ]) {\n                let current = thresholds[x];\n                thandle.writeDataSet(x, \"Float64\", null, current);\n            }\n        }\n\n        let disc = fetchDiscards();\n        rhandle.writeDataSet(\"discards\", \"Uint8\", null, disc);\n    }\n}\n\nclass QCMetricsMimic {\n    constructor(sums, detected, proportion) {\n        this.sums_ = sums;\n        this.detected_ = detected;\n        this.proportion_ = proportion;\n    }\n\n    sums({ copy }) {\n        return utils.mimicGetter(this.sums_, copy);\n    }\n\n    detected({ copy }) {\n        return utils.mimicGetter(this.detected_, copy);\n    }\n\n    subsetProportions(index, { copy }) {\n        if (index != 0) {\n            throw \"only 'index = 0' is supported for mimics\";\n        }\n        return utils.mimicGetter(this.proportion_, copy);\n    }\n\n    free() {}\n}\n\nclass QCFiltersMimic {\n    constructor(sums, detected, proportion, discards) {\n        this.sums_ = sums;\n        this.detected_ = detected;\n        this.proportion_ = proportion;\n        this.discards = scran.createUint8WasmArray(discards.length);\n        this.discards.set(discards);\n    }\n\n    thresholdsSums({ copy }) {\n        return utils.mimicGetter(this.sums_, copy);\n    }\n\n    thresholdsDetected({ copy }) {\n        return utils.mimicGetter(this.detected_, copy);\n    }\n\n    thresholdsSubsetProportions(index, { copy }) {\n        if (index != 0) {\n            throw \"only 'index = 0' is supported for mimics\";\n        }\n        return utils.mimicGetter(this.proportion_, copy);\n    }\n\n    discardOverall({ copy }) {\n        return utils.mimicGetter(this.discards, copy);\n    }\n\n    free() {\n        this.discards.free();\n    }\n}\n\nexport function unserialize(handle) {\n    let ghandle = handle.open(\"quality_control\");\n\n    {\n        let phandle = ghandle.open(\"parameters\"); \n        parameters = {\n            use_mito_default: phandle.open(\"use_mito_default\", { load: true }).values[0] > 0,\n            mito_prefix: phandle.open(\"mito_prefix\", { load: true }).values[0],\n            nmads: phandle.open(\"nmads\", { load: true }).values[0]\n        }\n    }\n\n    {\n        let rhandle = ghandle.open(\"results\");\n\n        let mhandle = rhandle.open(\"metrics\");\n        cache.metrics = new QCMetricsMimic(\n            mhandle.open(\"sums\", { load: true }).values,\n            mhandle.open(\"detected\", { load: true }).values,\n            mhandle.open(\"proportion\", { load: true }).values\n        );\n\n        let thandle = rhandle.open(\"thresholds\");\n        let thresholds_sums = thandle.open(\"sums\", { load: true }).values;\n        let thresholds_detected = thandle.open(\"detected\", { load: true }).values;\n        let thresholds_proportion = thandle.open(\"proportion\", { load: true }).values;\n\n        let discards = rhandle.open(\"discards\", { load: true }).values; \n        cache.filters = new QCFiltersMimic(\n            thresholds_sums, \n            thresholds_detected,\n            thresholds_proportion,\n            discards\n        );\n    }\n\n    return { ...parameters };\n}\n\n/***************************\n ******** Getters **********\n ***************************/\n\nexport function fetchSums({ unsafe = false } = {}) {\n    // Unsafe, because we're returning a raw view into the Wasm heap,\n    // which might be invalidated upon further allocations.\n    return cache.metrics.sums({ copy: !unsafe });\n}\n\nexport function fetchDiscards() {\n    return cache.filters.discardOverall({ copy: \"view\" });\n}\n\nexport function fetchFilteredMatrix() {\n    if (!(\"matrix\" in cache)) {\n        applyFilters();\n    }\n    return cache.matrix;\n}\n\nexport function fetchFilteredBlock() {\n    if (!(\"blocked\" in cache)) {\n        applyFilters();\n    }\n    if (cache.blocked) {\n        return cache.block_buffer;\n    } else {\n        return null;\n    }\n}\n","import * as scran from \"scran.js\"; \nimport * as utils from \"./_utils.js\";\nimport * as qc from \"./_quality_control.js\";\n\nvar cache = {};\nvar parameters = {};\n\nexport var changed = false;\n\nfunction rawCompute() {\n    var mat = qc.fetchFilteredMatrix();\n    var buffer = utils.allocateCachedArray(mat.numberOfColumns(), \"Float64Array\", cache);\n\n    var discards = qc.fetchDiscards();\n    var sums = qc.fetchSums({ unsafe: true }); // Better not have any more allocations in between now and filling of size_factors!\n\n    // Reusing the totals computed earlier.\n    var size_factors = buffer.array();\n    var j = 0;\n    discards.array().forEach((x, i) => {\n        if (!x) {\n            size_factors[j] = sums[i];\n            j++;\n        }\n    });\n\n    if (j != mat.numberOfColumns()) {\n        throw \"normalization and filtering are not in sync\";\n    }\n\n    var block = qc.fetchFilteredBlock();\n\n    utils.freeCache(cache.matrix);\n    cache.matrix = scran.logNormCounts(mat, { sizeFactors: buffer, block: block });\n    return;\n}\n\nexport function compute() {\n    changed = false;\n    if (qc.changed) {\n        changed = true;\n    } \n\n    if (changed) {\n        rawCompute();\n    }\n    return;\n}\n\nexport function results() {\n    return {};\n}\n\nexport function serialize(handle) {\n    // Token effort.\n    let ghandle = handle.createGroup(\"normalization\");\n    ghandle.createGroup(\"parameters\"); \n    ghandle.createGroup(\"results\"); \n}\n\nexport function unserialize(path) {\n    // Nothing to do here.\n    return;\n}\n\nexport function fetchNormalizedMatrix() {\n    if (!(\"matrix\" in cache)) {\n        rawCompute();\n    }\n    return cache.matrix;\n}\n\nexport function fetchExpression(index) {\n    var mat = fetchNormalizedMatrix();\n    var buffer = utils.allocateCachedArray(mat.numberOfColumns(), \"Float64Array\", cache); // re-using the buffer.\n    mat.row(index, { buffer: buffer });\n    return buffer.slice();\n}\n","import * as scran from \"scran.js\"; \nimport * as utils from \"./_utils.js\";\nimport * as normalization from \"./_normalization.js\";\nimport * as qc from \"./_quality_control.js\";\n  \nvar cache = {};\nvar parameters = {};\n\nexport var changed = false;\n\nexport function compute(span) {\n    changed = false;\n    \n    if (normalization.changed || span != parameters.span) {\n        utils.freeCache(cache.results);\n\n        let mat = normalization.fetchNormalizedMatrix();\n        let block = qc.fetchFilteredBlock();\n        cache.results = scran.modelGeneVar(mat, { span: span, block: block });\n\n        cache.sorted_residuals = cache.results.residuals().slice(); // a separate copy.\n        cache.sorted_residuals.sort();\n\n        parameters.span = span;\n        changed = true;\n    }\n\n    return;\n}\n\nfunction getResults(copy = true) {\n    copy = utils.copyOrView(copy);\n    return {\n        \"means\": cache.results.means({ copy: copy }),\n        \"vars\": cache.results.variances({ copy: copy }),\n        \"fitted\": cache.results.fitted({ copy: copy }),\n        \"resids\": cache.results.residuals({copy: copy })\n    };\n}\n\nexport function results() {\n    return getResults();\n}\n\nexport function serialize(handle) {\n    let ghandle = handle.createGroup(\"feature_selection\");\n\n    {\n        let phandle = ghandle.createGroup(\"parameters\"); \n        phandle.writeDataSet(\"span\", \"Float64\", [], parameters.span);\n    }\n\n    {\n        let res = getResults(false);\n        let rhandle = ghandle.createGroup(\"results\"); \n        for (const x of [ \"means\", \"vars\", \"fitted\", \"resids\" ]) {\n            rhandle.writeDataSet(x, \"Float64\", null, res[x]);\n        }\n    }\n}\n\nclass ModelGeneVarMimic {\n    constructor(means, vars, fitted, resids) {\n        this.means_ = means;\n        this.vars_ = vars;\n        this.fitted_ = fitted;\n        this.resids_ = resids;\n    }\n\n    means({copy}) {\n        return utils.mimicGetter(this.means_, copy);\n    }\n\n    variances({copy}) {\n        return utils.mimicGetter(this.vars_, copy);\n    }\n\n    fitted({copy}) {\n        return utils.mimicGetter(this.fitted_, copy);\n    }\n\n    residuals({copy}) {\n        return utils.mimicGetter(this.resids_, copy);\n    }\n\n    free() {}\n}\n\nexport function unserialize(handle, permuter) {\n    let ghandle = handle.open(\"feature_selection\");\n\n    {\n        let phandle = ghandle.open(\"parameters\");\n        parameters = {\n            span: phandle.open(\"span\", { load: true }).values[0]\n        };\n    }\n\n    {\n        let rhandle = ghandle.open(\"results\");\n        let reloaded = {};\n\n        // Possibly permuting it to match the new permutation order;\n        // see 'unserialize' in './_inputs.js'.\n        for (const key of [ \"means\", \"vars\", \"fitted\", \"resids\" ]) {\n            let value = rhandle.open(key, { load: true }).values;\n            permuter(value);\n            reloaded[key] = value;\n        }\n\n        cache.results = new ModelGeneVarMimic(reloaded.means, reloaded.vars, reloaded.fitted, reloaded.resids);\n    }\n\n    cache.sorted_residuals = cache.results.residuals({ copy: true });\n    cache.sorted_residuals.sort();\n\n    return { ...parameters };\n}\n\nexport function fetchSortedResiduals() {\n    return cache.sorted_residuals;\n}\n\nexport function fetchResiduals({ unsafe = false } = {}) {\n    return cache.results.residuals({ copy: !unsafe });\n}\n","import * as scran from \"scran.js\";\nimport * as utils from \"./_utils.js\";\nimport * as normalization from \"./_normalization.js\";\nimport * as qc from \"./_quality_control.js\";\nimport * as variance from \"./_model_gene_var.js\";\nimport * as wa from \"wasmarrays.js\";\n\nvar cache = {};\nvar parameters = {};\n\nexport var changed = false;\n\nfunction chooseFeatures(num_hvgs) {\n    var sorted_resids = variance.fetchSortedResiduals();\n    var threshold_at = sorted_resids[sorted_resids.length - num_hvgs];\n    var sub = utils.allocateCachedArray(sorted_resids.length, \"Uint8Array\", cache, \"hvg_buffer\");\n    var unsorted_resids = variance.fetchResiduals({ unsafe: true });\n    sub.array().forEach((element, index, array) => {\n        array[index] = unsorted_resids[index] >= threshold_at;\n    });\n}\n\nexport function compute(num_hvgs, num_pcs, block_method = \"none\") {\n    changed = false;\n    \n    if (variance.changed || num_hvgs !== parameters.num_hvgs) {\n        chooseFeatures(num_hvgs);\n        parameters.num_hvgs = num_hvgs;\n        changed = true;\n    }\n\n    if (changed || normalization.changed || num_pcs !== parameters.num_pcs) { \n        // Need to check this in case we never ran a chooseFeatures\n        // call, e.g., because we're running from a reloaded analysis\n        // where the user only changed the number of PCs.\n        if (!(\"hvg_buffer\" in cache)) {\n            chooseFeatures(parameters.num_hvgs);\n        }\n        let sub = cache.hvg_buffer;\n\n        let block = qc.fetchFilteredBlock();\n        let block_type = \"block\";\n        if (block_method == \"none\") {\n            block = null;\n        } else if (block_method == \"mnn\") {\n            block_type = \"weight\";\n        }\n\n        var mat = normalization.fetchNormalizedMatrix();\n        utils.freeCache(cache.pcs);\n        cache.pcs = scran.runPCA(mat, { features: sub, numberOfPCs: num_pcs, block: block, blockMethod: block_type });\n\n        if (block_method == \"mnn\") {\n            let pcs =  cache.pcs.principalComponents({ copy:\"view\" });\n            let corrected = utils.allocateCachedArray(pcs.length, \"Float64Array\", cache, \"corrected\");\n            scran.mnnCorrect(cache.pcs, block, { buffer: corrected });\n        }\n\n        parameters.num_pcs = num_pcs;\n        parameters.block_method = block_method;\n        changed = true;\n    }\n\n    return;\n}\n\nexport function results() {\n    var pca_output = cache.pcs;\n    var var_exp = pca_output.varianceExplained();\n    var total_var = pca_output.totalVariance();\n    var_exp.forEach((x, i) => {\n        var_exp[i] = x/total_var;\n    });\n    return { \"var_exp\": var_exp };\n}\n\nexport function serialize(handle) {\n    let ghandle = handle.createGroup(\"pca\");\n\n    {\n        let phandle = ghandle.createGroup(\"parameters\"); \n        phandle.writeDataSet(\"num_hvgs\", \"Int32\", [], parameters.num_hvgs);\n        phandle.writeDataSet(\"num_pcs\", \"Int32\", [], parameters.num_pcs);\n        phandle.writeDataSet(\"block_method\", \"String\", [], parameters.block_method);\n    }\n\n    {\n        let rhandle = ghandle.createGroup(\"results\");\n\n        let ve = results().var_exp;\n        rhandle.writeDataSet(\"var_exp\", \"Float64\", null, ve);\n\n        let pcs = fetchPCs(true);\n        rhandle.writeDataSet(\"pcs\", \"Float64\", [pcs.num_obs, pcs.num_pcs], pcs.pcs); // remember, it's transposed.\n\n        if (parameters.block_method == \"mnn\") {\n            let corrected = cache.corrected;\n            rhandle.writeDataSet(\"corrected\", \"Float64\", [pcs.num_obs, pcs.num_pcs], corrected); \n        }\n    }\n}\n\nclass PCAMimic { \n    constructor(pcs, var_exp) {\n        this.var_exp = var_exp;\n        this.pcs = scran.createFloat64WasmArray(pcs.length);\n        this.pcs.set(pcs);\n    }\n\n    principalComponents({ copy }) {\n        return utils.mimicGetter(this.pcs, copy);\n    }\n\n    varianceExplained({ copy = true } = {}) {\n        return utils.mimicGetter(this.var_exp, copy);\n    }\n\n    totalVariance () {\n        return 1;\n    }\n\n    free() {\n        this.pcs.free();\n    }\n}\n\nexport function unserialize(handle) {\n    let ghandle = handle.open(\"pca\");\n\n    {\n        let phandle = ghandle.open(\"parameters\"); \n        parameters = { \n            num_hvgs: phandle.open(\"num_hvgs\", { load: true }).values[0],\n            num_pcs: phandle.open(\"num_pcs\", { load: true }).values[0]\n        };\n\n        // For back-compatibility.\n        if (\"block_method\" in phandle.children) {\n            parameters.block_method = phandle.open(\"block_method\", { load: true }).values[0]\n        } else {\n            parameters.block_method = \"none\";\n        }\n    }\n\n    {\n        let rhandle = ghandle.open(\"results\");\n        let var_exp = rhandle.open(\"var_exp\", { load: true }).values;\n        let pcs = rhandle.open(\"pcs\", { load: true }).values;\n        cache.pcs = new PCAMimic(pcs, var_exp);\n\n        if (parameters.block_method == \"mnn\") {\n            let corrected = rhandle.open(\"corrected\", { load: true }).values;\n            let corbuffer = utils.allocateCachedArray(corrected.length, \"Float64Array\", cache, \"corrected\");\n            corbuffer.set(corrected);\n        }\n    }\n\n    return { ...parameters };\n}\n\nexport function fetchPCs(original = false) {\n    let pcs;\n    if (!original && parameters.block_method == \"mnn\") {\n        pcs = cache.corrected;\n    } else {\n        pcs = cache.pcs.principalComponents({ copy: \"view\" });\n    }\n    return {\n        \"pcs\": pcs,\n        \"num_pcs\": parameters.num_pcs,\n        \"num_obs\": pcs.length / parameters.num_pcs\n    };\n}\n","import * as scran from \"scran.js\";\nimport * as utils from \"./_utils.js\";\nimport * as pca from \"./_pca.js\";\n\nvar cache = {};\nvar parameters = {};\n\nexport var changed = false;\n\nexport function rawCompute(approximate) {\n    var pcs = pca.fetchPCs();\n    cache.raw = scran.buildNeighborSearchIndex(pcs.pcs, { approximate: approximate, numberOfDims: pcs.num_pcs, numberOfCells: pcs.num_obs });\n    return;\n}\n\nexport function compute(approximate) {\n    changed = false;\n\n    if (pca.changed || approximate != parameters.approximate) {\n        rawCompute(approximate);\n        parameters.approximate = approximate;\n        changed = true;\n    }\n\n    return;\n}\n\nexport function results() {\n    return {};\n}\n\nexport function serialize(handle) {\n    let ghandle = handle.createGroup(\"neighbor_index\");\n\n    {\n        let phandle = ghandle.createGroup(\"parameters\");\n        phandle.writeDataSet(\"approximate\", \"Uint8\", [], Number(parameters.approximate));\n    }\n\n    ghandle.createGroup(\"results\");\n    return;\n}\n\nexport function unserialize(handle) {\n    let ghandle = handle.open(\"neighbor_index\");\n\n    {\n        let phandle = ghandle.open(\"parameters\");\n        parameters = {\n            approximate: phandle.open(\"approximate\", { load: true }).value > 0\n        };\n    }\n\n    return { ...parameters };\n}\n\nexport function fetchIndex() {\n    if (!(\"raw\" in cache)) {\n        rawCompute(parameters.approximate);\n    }\n    return cache.raw;\n}\n","import * as scran from \"scran.js\"; \nimport * as utils from \"./_utils.js\";\nimport * as index from \"./_neighbor_index.js\";\n\nvar cache = {};\nvar parameters = {};\n\nexport var changed = false;\n\nexport function valid() {\n    return (\"clusters\" in cache);\n}\n\nexport function fetchClustersAsWasmArray() {\n    if (!valid()) {\n        throw \"cannot fetch SNN clusters from an invalid state\";\n    } else {\n        return cache.clusters.membership({ copy: \"view\" });\n    }\n}\n\nexport function compute(run_me, k, scheme, resolution) {\n    changed = false;\n\n    let rerun_neighbors = (index.changed || k !== parameters.k);\n    let rerun_graph = (rerun_neighbors || scheme !== parameters.scheme);\n    let rerun_clusters = (rerun_graph || resolution !== parameters.resolution);\n    if (run_me && !valid()) {\n        rerun_clusters = true;\n    }\n\n    // Checking whether each step needs content from the preceding step(s).\n    // This is necessary when working with reloaded states and we want to rerun\n    // some later steps but still need to generate their prerequisites.\n    if (!(\"graph\" in cache)) {\n        if (rerun_clusters) {\n            rerun_graph = true;\n        }\n    }\n    if (!(\"neighbors\" in cache)) {\n        if (rerun_graph || rerun_clusters) {\n            rerun_neighbors = true;\n        }\n    }\n\n    if (rerun_neighbors) {\n        utils.freeCache(cache.neighbors);\n        if (run_me) {\n            cache.neighbors = scran.findNearestNeighbors(index.fetchIndex(), k);\n        } else {\n            delete cache.neighbors; // ensuring that this is re-run on future calls to compute() with run_me = true.\n        }\n        parameters.k = k;\n    }\n\n    if (rerun_graph) {\n        utils.freeCache(cache.graph);\n        if (run_me) {\n            cache.graph = scran.buildSNNGraph(cache.neighbors, { scheme: scheme });\n        } else {\n            delete cache.graph;\n        }\n        parameters.scheme = scheme;\n    }\n\n    if (rerun_clusters) {\n        utils.freeCache(cache.clusters);\n        if (run_me) {\n            cache.clusters = scran.clusterSNNGraph(cache.graph, { resolution: resolution });\n        } else {\n            delete cache.clusters;\n        }\n        parameters.resolution = resolution;\n        changed = true;\n    }\n\n    return;\n}\n\nexport function results() {\n    // Cluster IDs will be passed to main thread in \n    // choose_clustering, so no need to do it here.\n    return {};\n}\n\nexport function serialize(handle) {\n    let ghandle = handle.createGroup(\"snn_graph_cluster\");\n\n    {\n        let phandle = ghandle.createGroup(\"parameters\");\n        phandle.writeDataSet(\"k\", \"Int32\", [], parameters.k);\n        phandle.writeDataSet(\"scheme\", \"String\", [], [\"rank\", \"number\", \"jaccard\"][parameters.scheme]); // TODO: parameters.scheme should just directly be the string.\n        phandle.writeDataSet(\"resolution\", \"Float64\", [], parameters.resolution);\n    }\n\n    {\n        let rhandle = ghandle.createGroup(\"results\");\n        if (valid()) {\n            let clusters = fetchClustersAsWasmArray();\n            rhandle.writeDataSet(\"clusters\", \"Int32\", null, clusters);\n        }\n    }\n\n    return;\n}\n\nclass SNNClusterMimic {\n    constructor(clusters) {\n        this.buffer = scran.createInt32WasmArray(clusters.length);\n        this.buffer.set(clusters);\n    }\n\n    membership({ copy }) {\n        return utils.mimicGetter(this.buffer, copy);\n    }\n\n    free() {\n        this.buffer.free();\n    }\n}\n\nexport function unserialize(handle) {\n    let ghandle = handle.open(\"snn_graph_cluster\");\n\n    {\n        let phandle = ghandle.open(\"parameters\");\n        parameters = {\n            k: phandle.open(\"k\", { load: true }).values[0],\n            scheme: phandle.open(\"scheme\", { load: true }).values[0],\n            resolution: phandle.open(\"resolution\", { load: true }).values[0]\n        };\n        parameters.scheme = { \"rank\": 0, \"number\": 1, \"jaccard\": 2 }[parameters.scheme];\n    }\n\n    {\n        let rhandle = ghandle.open(\"results\");\n        if (\"clusters\" in rhandle.children) {\n            let clusters = rhandle.open(\"clusters\", { load: true }).values;\n            cache.clusters = new SNNClusterMimic(clusters);\n        }\n    }\n\n    return { ...parameters };\n}\n","import * as scran from \"scran.js\"; \nimport * as utils from \"./_utils.js\";\nimport * as pca from \"./_pca.js\";\n\nvar cache = {};\nvar parameters = {};\n\nexport var changed = false;\n\nexport function valid() {\n    return (\"raw\" in cache);\n}\n\nexport function fetchClustersAsWasmArray() {\n    if (!valid()) {\n        throw \"cannot fetch k-means clusters from an invalid state\";\n    } else {\n        return cache.raw.clusters({ copy: \"view\" });\n    }\n}\n\nexport function compute(run_me, k) {\n    changed = false;\n\n    let run_k = (pca.changed || k != parameters.k);\n    if (run_me && !valid()) {\n        run_k = true;\n    }\n\n    if (run_k) {\n        utils.freeCache(cache.raw);\n        if (run_me) {\n            var pcs = pca.fetchPCs();\n            cache.raw = scran.clusterKmeans(pcs.pcs, k, { numberOfDims: pcs.num_pcs, numberOfCells: pcs.num_obs, initMethod: \"pca-part\" });\n        } else {\n            delete cache.raw; // ensure this step gets re-run later when run_me = true. \n        }\n        parameters.k = k;\n        changed = true;\n    }\n\n    return;\n}\n\nexport function results() {\n    // Cluster IDs will be passed to main thread in \n    // choose_clustering, so no need to do it here.\n    return {};\n}\n\nexport function serialize(handle) {\n    let ghandle = handle.createGroup(\"kmeans_cluster\");\n\n    {\n        let phandle = ghandle.createGroup(\"parameters\");\n        phandle.writeDataSet(\"k\", \"Int32\", [], parameters.k);\n    }\n\n    {\n        let rhandle = ghandle.createGroup(\"results\");\n        if (valid()) {\n            let clusters = fetchClustersAsWasmArray();\n            rhandle.writeDataSet(\"clusters\", \"Int32\", null, clusters);\n         }\n    }\n\n    return;\n}\n\nclass KmeansMimic {\n    constructor(clusters) {\n        this.buffer = scran.createInt32WasmArray(clusters.length);\n        this.buffer.set(clusters);\n    }\n\n    clusters({ copy }) {\n        return utils.mimicGetter(this.buffer, copy);\n    }\n\n    free() {\n        this.buffer.free();\n    }\n}\n\nexport function unserialize(handle) {\n    parameters = {\n        k: 10\n    };\n\n    // Protect against old analysis states that don't have kmeans_cluster.\n    if (\"kmeans_cluster\" in handle.children) {\n        let ghandle = handle.open(\"kmeans_cluster\");\n\n        {\n            let phandle = ghandle.open(\"parameters\");\n            parameters.k = phandle.open(\"k\", { load: true }).values[0];\n        }\n\n        {\n            let rhandle = ghandle.open(\"results\");\n            if (\"clusters\" in rhandle.children) {\n                let clusters = rhandle.open(\"clusters\", { load: true }).values;\n                cache.raw = new KmeansMimic(clusters);\n            }\n        }\n    }\n\n    return { ...parameters };\n}\n","import * as scran from \"scran.js\";\nimport * as utils from \"./_utils.js\";\nimport * as snn_cluster from \"./_snn_cluster.js\";\nimport * as kmeans_cluster from \"./_kmeans_cluster.js\";\n\nvar cache = {};\nvar parameters = {};\n\nexport var changed = false;\n\nexport function compute(method) {\n    changed = true;\n    \n    if (method == parameters.method) {\n        if (method == \"snn_graph\") {\n            if (!snn_cluster.changed) {\n                changed = false;\n            }\n        } else if (method == \"kmeans\") {\n            if (!kmeans_cluster.changed) {\n                changed = false;\n            }\n        }\n    }\n\n    parameters.method = method;\n    return;\n}\n\nexport function results() {\n    var clusters = fetchClustersAsWasmArray();\n    return { \"clusters\": clusters.slice() };\n}\n\nexport function serialize(handle) {\n    let ghandle = handle.createGroup(\"choose_clustering\");\n\n    {\n        let phandle = ghandle.createGroup(\"parameters\");\n        phandle.writeDataSet(\"method\", \"String\", [], parameters.method);\n    }\n\n    // No need to serialize the cluster IDs as this is done for each step.\n    ghandle.createGroup(\"results\");\n    return;\n}\n\nexport function unserialize(handle) {\n    let ghandle = handle.open(\"choose_clustering\");\n\n    {\n        let phandle = ghandle.open(\"parameters\");\n        parameters = {\n            method: phandle.open(\"method\", { load: true }).values[0]\n        };\n    }\n\n    return { ...parameters };\n}\n\nexport function fetchClustersAsWasmArray() {\n    if (parameters.method == \"snn_graph\") {\n        return snn_cluster.fetchClustersAsWasmArray();\n    } else if (parameters.method == \"kmeans\") {\n        return kmeans_cluster.fetchClustersAsWasmArray();\n    }\n}\n","import * as scran from \"scran.js\";\nimport * as index from \"./_neighbor_index.js\";\nimport * as utils from \"./_utils.js\";\n\nexport function computeNeighbors(k) {\n    var nn_index = index.fetchIndex();\n\n    var output = { \"num_obs\": nn_index.numberOfCells() };\n    var results = null, rbuf = null, ibuf = null, dbuf = null;\n    try {\n        results = scran.findNearestNeighbors(nn_index, k);\n\n        rbuf = scran.createInt32WasmArray(results.numberOfCells());\n        ibuf = scran.createInt32WasmArray(results.size());\n        dbuf = scran.createFloat64WasmArray(results.size());\n\n        results.serialize({ runs: rbuf, indices: ibuf, distances: dbuf });\n        output[\"size\"] = results.size();\n        output[\"runs\"] = rbuf.array().slice();\n        output[\"indices\"] = ibuf.array().slice();\n        output[\"distances\"] = dbuf.array().slice();\n\n    } finally {\n        if (results !== null) {\n            results.free();\n        }\n        if (rbuf !== null) {\n            rbuf.free();\n        }\n        if (ibuf !== null) {\n            ibuf.free();\n        }\n        if (dbuf !== null) {\n            dbuf.free();\n        }\n    }\n\n    return output;\n}\n\nexport function sendTask(worker, payload, cache, transferrable = []) {\n    var i = cache.counter;\n    var p = new Promise((resolve, reject) => {\n        cache.promises[i] = { \"resolve\": resolve, \"reject\": reject };\n    });\n    cache.counter++;\n    payload.id = i;\n    worker.postMessage(payload, transferrable);\n    return p;\n}\n\nexport function initializeWorker(worker, cache) {\n    worker.onmessage = function (msg) {\n        var type = msg.data.type;\n        if (type.endsWith(\"_iter\")) {\n            postMessage({\n                \"type\": type,\n                \"resp\": {\n                    \"x\": msg.data.x,\n                    \"y\": msg.data.y,\n                    \"iteration\": msg.data.iteration\n                },\n            }, [msg.data.x.buffer, msg.data.y.buffer]);\n            return;\n        }\n  \n        var id = msg.data.id;\n        var fun = cache.promises[id];\n        if (type == \"error\") {\n            fun.reject(msg.data.error);\n        } else {\n            fun.resolve(msg.data.data);\n        }\n        delete cache.promises[id];\n    };\n    return sendTask(worker, { \"cmd\": \"INIT\" }, cache);\n}\n\nexport function runWithNeighbors(worker, args, nn_out, cache) {\n    var run_msg = {\n        \"cmd\": \"RUN\",\n        \"params\": args \n    };\n\n    var transferrable = [];\n    if (nn_out !== null) {\n        run_msg.neighbors = nn_out;\n        utils.extractBuffers(nn_out, transferrable);\n    }\n\n    return sendTask(worker, run_msg, cache, transferrable);\n}\n","import * as scran from \"scran.js\";\nimport * as vizutils from \"./_utils_viz_parent.js\";\nimport * as index from \"./_neighbor_index.js\";\nimport * as utils from \"./_utils.js\";\n\nvar cache = { \"counter\": 0, \"promises\": {} };\nvar parameters = {};\nvar worker = null;\n\nexport function initialize() {\n    worker = new Worker(new URL(\"./tsne.worker.js\", import.meta.url), { type: \"module\" });\n    return vizutils.initializeWorker(worker, cache);\n}\n\nexport var changed = false;\n\nfunction core(perplexity, iterations, animate, reneighbor) {\n    var nn_out = null;\n    if (reneighbor) {\n        var k = scran.perplexityToNeighbors(perplexity);\n        nn_out = vizutils.computeNeighbors(k);\n    }\n\n    let args = {\n        \"perplexity\": perplexity,\n        \"iterations\": iterations,\n        \"animate\": animate\n    };\n\n    // This returns a promise but the message itself is sent synchronously,\n    // which is important to ensure that the t-SNE runs in its worker in\n    // parallel with other analysis steps. Do NOT put the runWithNeighbors\n    // call in a .then() as this may defer the message sending until \n    // the current thread is completely done processing.\n    cache.run = vizutils.runWithNeighbors(worker, args, nn_out, cache);\n    return;\n}\n\nexport function compute(perplexity, iterations, animate) {\n    let reneighbor = (index.changed || perplexity != parameters.perplexity || \"reloaded\" in cache);\n    changed = (reneighbor || iterations != parameters.iterations);\n\n    if (changed) {\n        core(perplexity, iterations, animate, reneighbor);\n\n        parameters.perplexity = perplexity;\n        parameters.iterations = iterations;\n        parameters.animate = animate;\n\n        delete cache.reloaded;\n    }\n\n    return;\n}\n\nasync function getResults(copy)  {\n    if (\"reloaded\" in cache) {\n        let output = {\n            x: cache.reloaded.x,\n            y: cache.reloaded.y\n        };\n        utils.copyVectors(output, copy);\n        output.iterations = parameters.iterations;\n        return output;\n    } else {\n        // Vectors that we get from the worker are inherently\n        // copied, so no need to do anything extra here.\n        await cache.run;\n        return vizutils.sendTask(worker, { \"cmd\": \"FETCH\" }, cache);\n    }\n}\n\nexport function results() {\n    return getResults(true);\n}\n\nexport async function serialize(handle) {\n    let ghandle = handle.createGroup(\"tsne\");\n\n    {\n        let phandle = ghandle.createGroup(\"parameters\");\n        phandle.writeDataSet(\"perplexity\", \"Float64\", [], parameters.perplexity);\n        phandle.writeDataSet(\"iterations\", \"Int32\", [], parameters.iterations);\n        phandle.writeDataSet(\"animate\", \"Uint8\", [], Number(parameters.animate));\n    }\n\n    {\n        let res = await getResults(false);\n        let rhandle = ghandle.createGroup(\"results\");\n        rhandle.writeDataSet(\"x\", \"Float64\", null, res.x);\n        rhandle.writeDataSet(\"y\", \"Float64\", null, res.y);\n    }\n\n    return;\n}\n\nexport function unserialize(handle) {\n    let ghandle = handle.open(\"tsne\");\n\n    {\n        let phandle = ghandle.open(\"parameters\");\n        parameters = {\n            perplexity: phandle.open(\"perplexity\", { load: true }).values[0],\n            iterations: phandle.open(\"iterations\", { load: true }).values[0],\n            animate: phandle.open(\"animate\", { load: true }).values[0] > 0\n        };\n    }\n\n    {\n        let rhandle = ghandle.open(\"results\");\n        cache.reloaded = {\n            x: rhandle.open(\"x\", { load: true }).values,\n            y: rhandle.open(\"y\", { load: true }).values\n        };\n    }\n\n    return { ...parameters };\n}\n\nexport function animate() {\n    if (\"reloaded\" in cache) {\n        // We need to reneighbor because we haven't sent the neighbors across yet.\n        core(parameters.perplexity, parameters.iterations, true, true);\n\n        // Mimicking the response from the re-run.\n        return cache.run\n            .then(contents => {\n                return {\n                    \"type\": \"tsne_rerun\",\n                    \"data\": { \"status\": \"SUCCESS\" }\n                };\n            });\n    } else {\n        return vizutils.sendTask(worker, { \"cmd\": \"RERUN\" }, cache);\n    }\n}\n","import * as scran from \"scran.js\";\nimport * as vizutils from \"./_utils_viz_parent.js\";\nimport * as index from \"./_neighbor_index.js\";\nimport * as utils from \"./_utils.js\";\n\nvar cache = { \"counter\": 0, \"promises\": {} };\nvar parameters = {};\nvar worker = null;\n\nexport function initialize() {\n    worker = new Worker(new URL(\"./umap.worker.js\", import.meta.url), { type: \"module\" });\n    cache.initialized = vizutils.initializeWorker(worker, cache);\n}\n\nexport var changed = false;\n\nfunction core(num_neighbors, num_epochs, min_dist, animate, reneighbor) {\n    var nn_out = null;\n    if (reneighbor) {\n        nn_out = vizutils.computeNeighbors(num_neighbors);\n    }\n\n    let args = {\n        \"num_neighbors\": num_neighbors,\n        \"num_epochs\": num_epochs,\n        \"min_dist\": min_dist,\n        \"animate\": animate\n    };\n\n    // This returns a promise but the message itself is sent synchronously,\n    // which is important to ensure that the UMAP runs in its worker in\n    // parallel with other analysis steps. Do NOT put the runWithNeighbors\n    // call in a .then() as this may defer the message sending until \n    // the current thread is completely done processing.\n    cache.run = vizutils.runWithNeighbors(worker, args, nn_out, cache);\n    return;\n}\n\nexport function compute(num_neighbors, num_epochs, min_dist, animate) {\n    let reneighbor = (index.changed || parameters.num_neighbors != num_neighbors || \"reloaded\" in cache);\n    changed = (reneighbor || num_epochs != parameters.num_epochs || min_dist != parameters.min_dist);\n\n    if (changed) {\n        core(num_neighbors, num_epochs, min_dist, animate, reneighbor);\n\n        parameters.num_neighbors = num_neighbors;\n        parameters.num_epochs = num_epochs;\n        parameters.min_dist = min_dist;\n        parameters.animate = animate;\n\n        delete cache.reloaded;\n    }\n\n    return;\n}\n\nasync function getResults(copy)  {\n    if (\"reloaded\" in cache) {\n        let output = {\n            x: cache.reloaded.x,\n            y: cache.reloaded.y\n        };\n        utils.copyVectors(output, copy);\n        output.iterations = parameters.num_epochs;\n        return output;\n    } else {\n        // Vectors that we get from the worker are inherently\n        // copied, so no need to do anything extra here.\n        await cache.run;\n        return vizutils.sendTask(worker, { \"cmd\": \"FETCH\" }, cache);\n    }\n}\n\nexport function results() {\n    return getResults(true);\n}\n\nexport async function serialize(handle) {\n    let ghandle = handle.createGroup(\"umap\");\n\n    {\n        let phandle = ghandle.createGroup(\"parameters\");\n        phandle.writeDataSet(\"num_neighbors\", \"Int32\", [], parameters.num_neighbors);\n        phandle.writeDataSet(\"num_epochs\", \"Int32\", [], parameters.num_epochs);\n        phandle.writeDataSet(\"min_dist\", \"Float64\", [], parameters.min_dist);\n        phandle.writeDataSet(\"animate\", \"Uint8\", [], Number(parameters.animate));\n    }\n\n    {\n        let res = await getResults(false);\n        let rhandle = ghandle.createGroup(\"results\");\n        rhandle.writeDataSet(\"x\", \"Float64\", null, res.x);\n        rhandle.writeDataSet(\"y\", \"Float64\", null, res.y);\n    }\n\n    return;\n}\n\nexport function unserialize(handle) {\n    let ghandle = handle.open(\"umap\");\n\n    {\n        let phandle = ghandle.open(\"parameters\");\n        parameters = {\n            num_neighbors: phandle.open(\"num_neighbors\", { load: true }).values[0],\n            num_epochs: phandle.open(\"num_epochs\", { load: true }).values[0],\n            min_dist: phandle.open(\"min_dist\", { load: true }).values[0],\n            animate: phandle.open(\"animate\", { load: true }).values[0] > 0\n        };\n    }\n\n    {\n        let rhandle = ghandle.open(\"results\");\n        cache.reloaded = {\n            x: rhandle.open(\"x\", { load: true }).values,\n            y: rhandle.open(\"y\", { load: true }).values\n        };\n    }\n\n    return { ...parameters };\n}\n\nexport function animate() {\n    if (\"reloaded\" in cache) {\n        // We need to reneighbor because we haven't sent the neighbors across yet.\n        core(parameters.num_neighbors, parameters.num_epochs, parameters.min_dist, true, true);\n  \n        // Mimicking the response from the re-run.\n        return cache.run\n            .then(contents => { \n                return {\n                    \"type\": \"umap_rerun\",\n                    \"data\": { \"status\": \"SUCCESS\" }\n                };\n            });\n    } else {\n        return vizutils.sendTask(worker, { \"cmd\": \"RERUN\" }, cache);\n    }\n}\n","import * as scran from \"scran.js\";\n\nexport const summaries2int = { \"min\": 0, \"mean\": 1, \"min_rank\": 4 };\nexport const int2summaries = { 0: \"min\", 1: \"mean\", 4: \"min_rank\" };\n\nexport function serializeGroupStats(handle, obj, group, { no_summaries = false } = {}) {\n    let ihandle = handle.createGroup(String(group));\n\n    for (const x of [ \"means\", \"detected\" ]) {\n        let y= obj[x](group, { copy: \"view\" });\n        ihandle.writeDataSet(x, \"Float64\", null, y);\n    }\n\n    for (const i of [ \"lfc\", \"delta_detected\", \"auc\", \"cohen\" ]) {\n        let i0 = i;\n        if (i == \"delta_detected\") {\n            i0 = \"deltaDetected\";\n        }\n\n        let extractor = (index) => obj[i0](group, { summary: index, copy: \"view\" });\n        if (no_summaries) {\n            let y = extractor(summaries2int[\"mean\"]);\n            ihandle.writeDataSet(i, \"Float64\", null, y);\n        } else {\n            let curhandle = ihandle.createGroup(i);\n            for (const [j, k] of Object.entries(summaries2int)) {\n                let y = extractor(k);\n                curhandle.writeDataSet(j, \"Float64\", null, y);\n            }\n        }\n    }\n}\n\nexport function unserializeGroupStats(handle, permuter, { no_summaries = false } = {}) {\n    let output = {};\n    for (const x of [ \"means\", \"detected\" ]) {\n        output[x] = handle.open(x, { load: true }).values;\n        permuter(output[x]);\n    }\n\n    for (const i of [ \"lfc\", \"delta_detected\", \"auc\", \"cohen\" ]) {\n        if (no_summaries) {\n            output[i] = handle.open(i, { load: true }).values;\n        } else {\n            let rhandle = handle.open(i);\n            let current = {};\n            for (const j of Object.keys(summaries2int)) {\n                current[j] = rhandle.open(j, { load: true }).values;\n                permuter(current[j]);\n            }\n            output[i] = current;\n        }\n    }\n\n    return output;\n}\n\n/*\n * Helper function to retrieve marker statistics for plotting.\n * This is used both for cluster-specific markers as well as the\n * DE genes that are computed for a custom selection vs the rest.\n */\nexport function fetchGroupResults(results, rank_type, group) {\n    if (!rank_type || rank_type === undefined) {\n        rank_type = \"cohen-min-rank\";\n    }\n\n    var ordering;\n    {\n        // Choosing the ranking statistic. Do NOT do any Wasm allocations\n        // until 'ranking' is fully consumed!\n        let ranking;\n        let increasing = false;\n      \n        let index = 1;\n        if (rank_type.match(/-min$/)) {\n            index = 0;\n        } else if (rank_type.match(/-min-rank$/)) {\n            increasing = true;\n            index = 4;\n        }\n\n        if (rank_type.match(/^cohen-/)) {\n            ranking = results.cohen(group, { summary: index, copy: false });\n        } else if (rank_type.match(/^auc-/)) {\n            ranking = results.auc(group, { summary: index, copy: false });\n        } else if (rank_type.match(/^lfc-/)) {\n            ranking = results.lfc(group, { summary: index, copy: false });\n        } else if (rank_type.match(/^delta-d-/)) {\n            ranking = results.deltaDetected(group, { summary: index, copy: false });\n        } else {\n            throw \"unknown rank type '\" + rank_type + \"'\";\n        }\n  \n        // Computing the ordering based on the ranking statistic.\n        ordering = new Int32Array(ranking.length);\n        for (var i = 0; i < ordering.length; i++) {\n            ordering[i] = i;\n        }\n        if (increasing) {\n            ordering.sort((f, s) => (ranking[f] - ranking[s]));\n        } else {\n            ordering.sort((f, s) => (ranking[s] - ranking[f]));\n        }\n    }\n  \n    // Apply that ordering to each statistic of interest.\n    var reorder = function(stats) {\n        var thing = new Float64Array(stats.length);\n        for (var i = 0; i < ordering.length; i++) {\n            thing[i] = stats[ordering[i]];\n        }\n        return thing;\n    };\n  \n    var stat_detected = reorder(results.detected(group, { copy: false }));\n    var stat_mean = reorder(results.means(group, { copy: false }));\n    var stat_lfc = reorder(results.lfc(group, { summary: 1, copy: false }));\n    var stat_delta_d = reorder(results.deltaDetected(group, { summary: 1, copy: false }));\n\n    return {\n        \"ordering\": ordering,\n        \"means\": stat_mean,\n        \"detected\": stat_detected,\n        \"lfc\": stat_lfc,\n        \"delta_detected\": stat_delta_d\n    };\n}\n\n","import * as scran from \"scran.js\"; \nimport * as utils from \"./_utils.js\";\nimport * as normalization from \"./_normalization.js\";\nimport * as qc from \"./_quality_control.js\";\nimport * as choice from \"./_choose_clustering.js\";\nimport * as markers from \"./_utils_markers.js\";\n\nvar cache = {};\nvar parameters = {};\n\nexport var changed = false;\n\nexport function compute() {\n    changed = false;\n\n    if (normalization.changed || choice.changed) {\n        var mat = normalization.fetchNormalizedMatrix();\n        var clusters = choice.fetchClustersAsWasmArray();\n        var block = qc.fetchFilteredBlock();\n        \n        utils.freeCache(cache.raw);\n        cache.raw = scran.scoreMarkers(mat, clusters, { block: block });\n\n        // No parameters to set.\n        changed = true;\n    }\n\n    return;\n}\n\nexport function results() {\n    return {};\n}\n\nexport function serialize(handle) {\n    let ghandle = handle.createGroup(\"marker_detection\");\n    ghandle.createGroup(\"parameters\");\n\n    {\n        let chandle = ghandle.createGroup(\"results\");\n        let rhandle = chandle.createGroup(\"clusters\");\n\n        var num = cache.raw.numberOfGroups();\n        for (var i = 0; i < num; i++) {\n            markers.serializeGroupStats(rhandle, cache.raw, i);\n        }\n    }\n}\n\nclass ScoreMarkersMimic {\n    constructor(clusters) {\n        this.clusters = clusters;\n    }\n\n    effect_grabber(key, group, summary, copy) {\n        let sidx = markers.int2summaries[summary];\n        let chosen = this.clusters[group][key][sidx];\n        return utils.mimicGetter(chosen, copy);\n    }\n\n    lfc(group, { summary, copy }) {\n        return this.effect_grabber(\"lfc\", group, summary, copy);\n    }\n\n    deltaDetected(group, { summary, copy }) {\n        return this.effect_grabber(\"delta_detected\", group, summary, copy);\n    }\n\n    cohen(group, { summary, copy }) {\n        return this.effect_grabber(\"cohen\", group, summary, copy);\n    }\n\n    auc(group, { summary, copy }) {\n        return this.effect_grabber(\"auc\", group, summary, copy);\n    }\n\n    stat_grabber(key, group, copy) {\n        let chosen = this.clusters[group][key];\n        return utils.mimicGetter(chosen, copy);\n    }\n\n    means(group, { copy }) {\n        return this.stat_grabber(\"means\", group, copy);\n    }\n\n    detected(group, { copy }) {\n        return this.stat_grabber(\"detected\", group, copy);\n    }\n\n    numberOfGroups() {\n        return Object.keys(this.clusters).length;\n    }\n\n    free() {}\n}\n\nexport function unserialize(handle, permuter) {\n    let ghandle = handle.open(\"marker_detection\");\n\n    // No parameters to unserialize.\n\n    {\n        let chandle = ghandle.open(\"results\");\n        let rhandle = chandle.open(\"clusters\");\n        let clusters = {};\n        for (const cl of Object.keys(rhandle.children)) {\n            clusters[Number(cl)] = markers.unserializeGroupStats(rhandle.open(cl), permuter);\n        }\n        cache.raw = new ScoreMarkersMimic(clusters);\n    }\n\n    return;\n}\n\nexport function fetchGroupResults(rank_type, group) {\n    return markers.fetchGroupResults(cache.raw, rank_type, group); \n}\n\nexport function numberOfGroups() {\n    return cache.raw.numberOfGroups();\n}\n\nexport function fetchGroupMeans(group, { copy = true }) {\n    return cache.raw.means(group, { copy: copy });\n}\n","var DownloadsDB;\nvar init = null;\n\nexport function initialize() {\n    if (init === null) {\n        init = new Promise((resolve, reject) => {\n            // initialize database on worker creation\n            DownloadsDB = indexedDB.open(\"DownloadsDB\", 3);\n\n            DownloadsDB.onupgradeneeded = (e) => {\n                var DownloadsDBClient = e.target.result;\n\n                // Currently purging all existing stores when the version is updated.\n                // At some point we may add a more sophisticated upgrade mechanism.\n                try {\n                    DownloadsDBClient.deleteObjectStore(\"downloads\");\n                } catch (e) {}\n\n                DownloadsDBClient.createObjectStore(\"downloads\", { keyPath: 'url' });\n            };\n\n            DownloadsDB.onsuccess = () => {\n                resolve(null);\n            };\n\n            DownloadsDB.onerror = () => {\n                reject(\"failed to initialize DownloadsDB\");\n            };\n        });\n    }\n\n    return init;\n}\n\nexport async function list() {\n    await init;\n    let trans = DownloadsDB.result.transaction([\"downloads\"], \"readonly\");\n    let download_store = trans.objectStore(\"downloads\");\n    return download_store.getAllKeys();\n}\n\nexport async function get(url, params = null, force = false) {\n    await init;\n\n    if (!force) {\n        let trans = DownloadsDB.result.transaction([\"downloads\"], \"readonly\");\n        let download_store = trans.objectStore(\"downloads\");\n        var data_check = new Promise(resolve => {\n            var already = download_store.get(url);\n            already.onsuccess = function (event) {\n                if (already.result !== undefined) {\n                    resolve(already.result.payload);\n                } else {\n                    resolve(null);\n                }\n            };\n            already.onerror = function (event) {\n                resolve(null);\n            };\n        });\n\n        var found = await data_check;\n        if (found !== null) {\n            return found;\n        }\n    }\n\n    var req;\n    if (params == null) {\n        req = fetch(url);\n    } else {\n        req = fetch(url, params);\n    }\n\n    var res = await req;\n    if (!res.ok) {\n        throw \"failed to download '\" + url + \"' (\" + res.status + \")\";\n    }\n    var buffer = await res.arrayBuffer();\n\n    // Technically, this isn't quite right, because we need to close the read\n    // transaction before opening the write transaction; multiple queries to\n    // the same URL from different workers could cause multiple downloads if\n    // they each miss each other's read check. But oh well; the auto-commit\n    // of IDB transactions means that it's hard to do any better. (Specifically,\n    // we can't do an async fetch while the transaction is still open, because\n    // it just closes before the fetch is done.)\n    let trans = DownloadsDB.result.transaction([\"downloads\"], \"readwrite\");\n    let download_store = trans.objectStore(\"downloads\");\n    var data_saving = new Promise(resolve => {\n        var putrequest = download_store.put({ \"url\": url, \"payload\": buffer });\n        putrequest.onsuccess = function (event) {\n            resolve(true);\n        };\n        putrequest.onerror = function (event) {\n            resolve(false);\n        };\n    });\n\n    let success = await data_saving;\n    if (!success) {\n        throw \"failed to download resources for '\" + url + \"'\";\n    }\n\n    return buffer;\n}\n\nexport async function remove(url) {\n    await init;\n    let trans = DownloadsDB.result.transaction([\"downloads\"], \"readwrite\")\n    let download_store = trans.objectStore(\"downloads\");\n\n    var removal = new Promise(resolve => {\n        let request = download_store.delete(url);\n        request.onsuccess = function (event) {\n            resolve(true);\n        };\n        request.onerror = function (event) {\n            resolve(false);\n        };\n    });\n\n    return await removal;\n}\n","import * as scran from \"scran.js\";\nimport * as utils from \"./_utils.js\";\nimport * as inputs from \"./_inputs.js\";\nimport * as markers from \"./_score_markers.js\";\nimport * as downloads from \"./DownloadsDBHandler.js\";\nimport * as pako from \"pako\";\n\nvar cache = {};\nvar parameters = {};\n\nexport var changed = false;\n\nvar hs_loaded = {};\nvar mm_loaded = {};\nvar hs_references = {};\nvar mm_references = {};\n\nconst proxy = \"https://cors-proxy.aaron-lun.workers.dev\";\nconst hs_base = \"https://github.com/clusterfork/singlepp-references/releases/download/hs-latest\";\nconst mm_base = \"https://github.com/clusterfork/singlepp-references/releases/download/mm-latest\";\n\n// Try to figure out the best feature identifiers to use,\n// based on the highest confidence annotation.\nfunction chooseFeatures() {\n    let genes = inputs.fetchGenes();\n    let types = inputs.fetchGeneTypes();\n\n    let best_feature = null;\n    let best = null;\n    for (const [key, val] of Object.entries(types)) {\n        if (best === null) {\n            best_feature = key;\n            best = val;\n        } else if (val.confidence > best.confidence) {\n            best_feature = key;\n            best = val;\n        }\n    }\n\n    cache.features = genes[best_feature];\n    cache.feature_details = best;\n    return;\n}\n\n// TODO: consolidate this with _inputs.readDSVFromBuffer to eliminate the D3 dependency.\nfunction quickLineReader(buffer, compression = \"gz\") {\n    let txt = buffer;\n    if (compression == \"gz\") {\n        txt = pako.ungzip(buffer);\n    }\n\n    const dec = new TextDecoder();\n    let decoded = dec.decode(txt);\n\n    let lines = decoded.split(\"\\n\");\n    if (lines.length > 0 && lines[lines.length - 1] == \"\") { // ignoring the trailing newline.\n        lines.pop();\n    }\n\n    return lines;    \n}\n\nasync function getBuiltReference(name, species, rebuild) {\n    let base;\n    let references;\n    let preloaded;\n    if (species == \"human\") {\n        base = hs_base;\n        preloaded = hs_loaded;\n        references = hs_references;\n    } else {\n        base = mm_base;\n        preloaded = mm_loaded;\n        references = mm_references;\n    }\n\n    downloads.initialize();\n\n    if (!(name in preloaded)) {\n        let buffers = await Promise.all([\n            downloads.get(proxy + \"/\" + encodeURIComponent(base + \"/\" + name + \"_genes.csv.gz\")),\n            downloads.get(proxy + \"/\" + encodeURIComponent(base + \"/\" + name + \"_labels_fine.csv.gz\")),\n            downloads.get(proxy + \"/\" + encodeURIComponent(base + \"/\" + name + \"_label_names_fine.csv.gz\")),\n            downloads.get(proxy + \"/\" + encodeURIComponent(base + \"/\" + name + \"_markers_fine.gmt.gz\")),\n            downloads.get(proxy + \"/\" + encodeURIComponent(base + \"/\" + name + \"_matrix.csv.gz\"))\n        ]);\n\n        let loaded;\n        try {\n            loaded = scran.loadLabelledReferenceFromBuffers(\n                new Uint8Array(buffers[4]), // rank matrix\n                new Uint8Array(buffers[3]), // markers\n                new Uint8Array(buffers[1])) // label per sample\n\n            let gene_lines = quickLineReader(new Uint8Array(buffers[0])); // gene names\n            let ensembl = [];\n            let symbol = [];\n            gene_lines.forEach(x => {\n                let fields = x.split(\",\");\n                ensembl.push(fields[0]);\n                symbol.push(fields[1]);\n            });\n\n            let labels = quickLineReader(new Uint8Array(buffers[2])); // full label names\n            preloaded[name] = { \n                \"raw\": loaded, \n                \"genes\": {\n                    \"ensembl\": ensembl,\n                    \"symbol\": symbol\n                },\n                \"labels\": labels\n            };\n\n        } catch (e) {\n            utils.freeCache(loaded);\n            throw e;\n        }\n    }\n\n\n    if (!(name in references) || rebuild) {\n        let built;\n        try {\n            if (name in references) {\n                utils.freeCache(references[name].raw);\n            }\n\n            let current = preloaded[name];\n            let loaded = current.raw;\n\n            let chosen_ids;\n            if (cache.feature_details.type === \"ensembl\") {\n                chosen_ids = current.genes.ensembl;\n            } else {\n                chosen_ids = current.genes.symbol;\n            }\n\n            let built = scran.buildLabelledReference(cache.features, loaded, chosen_ids); \n            references[name] = {\n                \"features\": chosen_ids,\n                \"raw\": built\n            };\n\n        } catch (e) {\n            utils.freeCache(built);\n            throw e;\n        }\n    }\n\n    return {\n        \"loaded\": preloaded[name],\n        \"built\": references[name]\n    };\n}\n\nfunction compareArrays(x, y) {\n    if (typeof x === \"undefined\" || typeof y === \"undefined\") {\n        return false;\n    }\n    if (x.length != y.length) {\n        return false;\n    }\n    for (var i = 0; i < x.length; i++) {\n        if (x[i] != y[i]) {\n            return false;\n        }\n    }\n    return true;\n}\n\nexport function compute(human_references, mouse_references) {\n    changed = false;\n\n    let rebuild = false;\n    if (inputs.changed || !(\"feature_space\" in cache)) {\n        rebuild = true;\n        changed = true;\n        chooseFeatures();\n    }\n    let species = cache.feature_details.species;\n        \n    // Fetching all of the references. This is effectively a no-op\n    // if rebuild = false, so we do it to fill up 'valid'.\n    let init = downloads.initialize();\n    let valid = {};\n    if (species == \"human\") {\n        for (const ref of human_references) {\n            valid[ref] = getBuiltReference(ref, \"human\", rebuild);\n        }\n    } else if (species == \"mouse\") {\n        for (const ref of mouse_references) {\n            valid[ref] = getBuiltReference(ref, \"mouse\", rebuild);\n        }\n    }\n\n    if (!compareArrays(human_references, parameters.human_references) || !compareArrays(mouse_references, parameters.mouse_references)) {\n        parameters.human_references = human_references;\n        parameters.mouse_references = mouse_references;\n        changed = true;\n    }\n\n    if (changed) {\n        // Creating a column-major array of mean vectors.\n        let ngenes = cache.features.length;\n        let ngroups = markers.numberOfGroups(); \n        let cluster_means = utils.allocateCachedArray(ngroups * ngenes, \"Float64Array\", cache);\n        for (var g = 0; g < ngroups; g++) {\n            let means = markers.fetchGroupMeans(g, { copy: false }); // Warning: direct view in wasm space - be careful.\n            let cluster_array = cluster_means.array();\n            cluster_array.set(means, g * ngenes);\n        }\n\n        // Running classifications on the cluster means. Note that compute() itself\n        // cannot be async, as we need to make sure 'changed' is set and available for\n        // downstream steps; hence the explicit then().\n        cache.results = {};\n        for (const [key, val] of Object.entries(valid)) {\n            cache.results[key] = val.then(ref => {\n                let output = scran.labelCells(cluster_means, ref.built.raw, { numberOfFeatures: ngenes, numberOfCells: ngroups });\n                let labels = [];\n                for (const o of output) {\n                    labels.push(ref.loaded.labels[o]);\n                }\n                return labels;\n            });\n        }\n\n        // Performing additional integration, if necessary. We don't really \n        // need this if there's only one reference.\n        let used_refs = Object.keys(valid);\n        if (used_refs.length > 1) {\n            if (rebuild || !compareArrays(used_refs, cache.used)) {\n                let used_vals = Object.values(valid);\n\n                cache.integrated = Promise.all(used_vals)\n                    .then(arr => {\n                        let loaded = arr.map(x => x.loaded.raw);\n                        let feats = arr.map(x => x.built.features);\n                        let built = arr.map(x => x.built.raw);\n                        return scran.integrateLabelledReferences(cache.features, loaded, feats, built);\n                    }\n                );\n            }\n\n            cache.integrated_results = cache.integrated\n                .then(async (integrated) => {\n                    let results = [];\n                    for (const key of used_refs) {\n                        results.push(await cache.results[key]);\n                    }\n\n                    let out = scran.integrateCellLabels(cluster_means, results, integrated, { numberOfFeatures: ngenes, numberOfCells: ngroups });\n                    let as_names = [];\n                    out.forEach(i => {\n                        as_names.push(used_refs[i]);\n                    });\n                    return as_names;\n                }\n            );\n        } else {\n            delete cache.integrated_results;\n        }\n\n        cache.used = used_refs;\n        changed = true;\n    }\n\n    return;\n}\n\nexport async function results() {\n    // No real need to clone these, they're string arrays\n    // so they can't be transferred anyway.\n    let perref = {};\n    for (const [key, val] of Object.entries(cache.results)) {\n        perref[key] = await val;\n    }\n\n    let output = { \"per_reference\": perref };\n    if (\"integrated_results\" in cache) {\n        output.integrated = await cache.integrated_results;\n    }\n\n    return output;\n}\n\nexport async function serialize(handle) {\n    let ghandle = handle.createGroup(\"cell_labelling\");\n    \n    {\n        let phandle = ghandle.createGroup(\"parameters\");\n        phandle.writeDataSet(\"mouse_references\", \"String\", null, parameters.mouse_references);\n        phandle.writeDataSet(\"human_references\", \"String\", null, parameters.human_references);\n    }\n\n    {\n        let rhandle = ghandle.createGroup(\"results\");\n        let res = await results();\n\n        let perhandle = rhandle.createGroup(\"per_reference\");\n        for (const [key, val] of Object.entries(res.per_reference)) {\n            perhandle.writeDataSet(key, \"String\", null, val);\n        }\n\n        if (\"integrated\" in res) {\n            rhandle.writeDataSet(\"integrated\", \"String\", null, res.integrated);\n        }\n    }\n\n    return;\n}\n\nexport function unserialize(handle) {\n    parameters =  {\n        mouse_references: [],\n        human_references: []\n    };\n    cache.results = {};\n\n    // Protect against old analysis states that don't have cell_labelling.\n    if (\"cell_labelling\" in handle.children) {\n        let ghandle = handle.open(\"cell_labelling\");\n        \n        {\n            let phandle = ghandle.open(\"parameters\");\n            parameters.mouse_references = phandle.open(\"mouse_references\", { load: true }).values;\n            parameters.human_references = phandle.open(\"human_references\", { load: true }).values;\n        }\n\n        {\n            let rhandle = ghandle.open(\"results\");\n            let perhandle = rhandle.open(\"per_reference\");\n            for (const key of Object.keys(perhandle.children)) {\n                cache.results[key] = perhandle.open(key, { load: true }).values;\n            }\n            if (\"integrated\" in rhandle.children) {\n                cache.integrated_results = rhandle.open(\"integrated\", { load: true }).values;\n            }\n        }\n    }\n\n    return { ...parameters };\n}\n","import * as scran from \"scran.js\";\nimport * as utils from \"./_utils.js\";\nimport * as qc from \"./_quality_control.js\";\nimport * as normalization from \"./_normalization.js\";\nimport * as markers from \"./_utils_markers.js\";\n\nvar cache = { \"results\": {} };\nvar parameters = { \"selections\": {} };\n\nexport var changed = false;\n\nexport function compute(args) {\n    /* If the QC filter was re-run, all of the selections are invalidated as\n     * the identity of the indices may have changed.\n     */\n    if (qc.changed) {\n        parameters.selections = {};\n        for (const [key, val] of Object.entries(cache.results)) {\n            utils.freeCache(val.raw);                    \n        }\n        cache.results = {};\n    }\n\n    /*\n     * Technically we would need to re-run detection on the existing selections\n     * if the normalization changed but the QC was the same. In practice, this\n     * never happens, so we'll deal with it later.\n     */\n    \n    changed = true;\n    return;\n}\n\nexport function results() {\n    return {};\n}\n\nexport function serialize(handle) {\n    let ghandle = handle.createGroup(\"custom_selections\");\n\n    {\n        let phandle = ghandle.createGroup(\"parameters\");\n        let rhandle = phandle.createGroup(\"selections\");\n        for (const [key, val] of Object.entries(parameters.selections)) {\n            rhandle.writeDataSet(String(key), \"Uint8\", null, val);\n        }\n    }\n\n    {\n        let chandle = ghandle.createGroup(\"results\");\n        let rhandle = chandle.createGroup(\"markers\");\n        for (const [key, val] of Object.entries(cache.results)) {\n            markers.serializeGroupStats(rhandle, val, 1, { no_summaries: true });\n        }\n    }\n}\n\nclass CustomMarkersMimic {\n    constructor(results) {\n        this.results = results;\n    }\n\n    effect_grabber(key, group, summary, copy) {\n        if (group != 1) {\n            throw \"only group 1 is supported for custom marker mimics\";\n        }\n        if (summary != 1) {\n            throw \"only the mean effect size is supported for custom marker mimics\";\n        }\n        let chosen = this.results[group][key];\n        return utils.mimicGetter(chosen, copy);\n    }\n\n    lfc(group, { summary, copy }) {\n        return effect_grabber(\"lfc\", group, summary, copy);\n    }\n\n    deltaDetected(group, { summary, copy }) {\n        return effect_grabber(\"delta_detected\", group, summary, copy);\n    }\n\n    cohen(group, { summary, copy }) {\n        return effect_grabber(\"cohen\", group, summary, copy);\n    }\n\n    auc(group, { summary, copy }) {\n        return effect_grabber(\"auc\", group, summary, copy);\n    }\n\n    stat_grabber(key, group, copy) {\n        let chosen = this.results[group][key];\n        return utils.mimicGetter(chosen, copy);\n    }\n\n    means(group, { copy }) {\n        return stat_grabber(\"means\", group, copy);\n    }\n\n    detected(group, { copy }) {\n        return stat_grabber(\"detected\", group, copy);\n    }\n\n    free() {}\n}\n\nexport function unserialize(handle, permuter) {\n    let ghandle = handle.open(\"custom_selections\");\n\n    {\n        let phandle = ghandle.open(\"parameters\");\n        let rhandle = phandle.open(\"selections\");\n        parameters = { selections: {} };\n        for (const key of Object.keys(rhandle.children)) {\n            parameters.selections[key] = rhandle.open(key, { load: true }).values;\n        }\n    }\n\n    {\n        let chandle = ghandle.open(\"results\");\n        let rhandle = chandle.open(\"markers\");\n        cache.results = {};\n        for (const sel of Object.keys(rhandle.children)) {\n            let current = markers.unserializeGroupStats(rhandle.open(sel), permuter, { no_summaries: true });\n            cache.results[sel] = new CustomMarkersMimic(current);\n        }\n    }\n\n    // Need to make a copy to avoid moving the buffers.\n    let output = { selections: {} };\n    for (const [k, v] of Object.entries(parameters.selections)) {\n        output.selections[k] = v.slice();        \n    }\n    return output;\n}\n\nexport function addSelection(id, selection) {\n    var mat = normalization.fetchNormalizedMatrix();\n\n    var buffer = utils.allocateCachedArray(mat.numberOfColumns(), \"Int32Array\", cache);\n    buffer.fill(0);\n    var tmp = buffer.array();\n    selection.forEach(element => { tmp[element] = 1; });\n\n    // Assumes that we have at least one cell in and outside the selection!\n    var res = scran.scoreMarkers(mat, buffer); \n  \n    // Removing previous results, if there were any.\n    if (id in cache.results) {\n        utils.freeCache(cache.results[id].raw);\n        delete cache.results[id];\n    }\n  \n    cache.results[id] = { \"raw\": res };\n    parameters.selections[id] = selection;\n}\n\nexport function removeSelection(id) {\n    utils.freeCache(cache.results[id].raw);\n    delete cache.results[id];\n    delete parameters.selections[id];\n    return;\n}\n\nexport function fetchResults(id, rank_type) {\n    var current = cache.results[id].raw;\n    return markers.fetchGroupResults(current, rank_type, 1); \n}\n","var kanaDB;\nvar init = null;\n\nexport function initialize() {\n    init = new Promise(resolve => {\n        // initialize database on worker creation\n        kanaDB = indexedDB.open(\"KanaDB\", 2);\n\n        kanaDB.onupgradeneeded = (e) => {\n            var kanaDBClient = e.target.result;\n\n            // Currently purging all existing stores when the version is updated.\n            // At some point we may add a more sophisticated upgrade mechanism.\n            try {\n                kanaDBClient.deleteObjectStore(\"analysis\");\n            } catch (e) {}\n            try {\n                kanaDBClient.deleteObjectStore(\"analysis_meta\");\n            } catch (e) {}\n            try {\n                kanaDBClient.deleteObjectStore(\"file\");\n            } catch (e) {}\n            try {\n                kanaDBClient.deleteObjectStore(\"file_meta\");\n            } catch (e) {}\n\n            kanaDBClient.createObjectStore(\"analysis\", { keyPath: 'id' });\n            kanaDBClient.createObjectStore(\"analysis_meta\", { keyPath: 'id' });\n            kanaDBClient.createObjectStore(\"file\", { keyPath: 'id' });\n            kanaDBClient.createObjectStore(\"file_meta\", { keyPath: 'id' });\n        };\n\n        // Send existing stored analyses, if available.\n        kanaDB.onsuccess = () => {\n            getRecordsResolver(resolve);\n        };\n\n        kanaDB.onerror = () => {\n            resolve(null);\n        };\n    });\n\n    return init;\n}\n\nfunction getRecordsResolver(resolve, store = null) {\n    if (store === null) {\n        store = kanaDB.result\n            .transaction([\"analysis_meta\"], \"readonly\")\n            .objectStore(\"analysis_meta\")\n    }\n\n    var allAnalysis = store.getAll();\n\n    allAnalysis.onsuccess = function () {\n        let vals = allAnalysis.result;\n        vals.forEach(x => { delete x.files }); // no need to transfer that.\n        resolve(vals);\n    };\n    allAnalysis.onerror = function () {\n        resolve(null);\n    };\n}\n\n/** Helper functions **/\nasync function loadContent(id, store) {\n    return new Promise(resolve => {\n        let request = store.get(id);\n        request.onsuccess = function () {\n            if (request.result !== undefined) {\n                resolve(request.result);\n            } else {\n                resolve(null);\n            }\n        };\n        request.onerror = function () {\n            resolve(null);\n        };\n    });\n}\n\nfunction allOK(promises) {\n    return Promise.allSettled(promises)\n        .then(vals => {\n            for (const x of vals) {\n                if (!x) {\n                    return false;\n                }\n            }\n            return true;\n        });\n}\n\nexport async function getRecords() {\n    await init;\n    return new Promise(resolve => {\n        getRecordsResolver(resolve);\n    });\n}\n\n/** Functions to save content **/\nexport async function saveFile(id, buffer) {\n    await init;\n    let trans = kanaDB.result.transaction([\"file\", \"file_meta\"], \"readwrite\");\n    let file_store = trans.objectStore(\"file\");\n    let meta_store = trans.objectStore(\"file_meta\");\n\n    var meta = await loadContent(id, meta_store);\n    var refcount;\n    if (meta === null) {\n        refcount = 0;\n    } else {\n        refcount = meta[\"count\"];\n    }\n    refcount++;\n\n    var data_saving = new Promise(resolve => {\n        var putrequest = file_store.put({ \"id\": id, \"payload\": buffer });\n        putrequest.onsuccess = function (event) {\n            resolve(true);\n        };\n        putrequest.onerror = function (event) {\n            resolve(false);\n        };\n    });\n\n    var ref_saving = new Promise(resolve => {\n        meta.count = refcount;\n        var putrequest = meta_store.put(meta);\n        putrequest.onsuccess = function (event) {\n            resolve(true);\n        };\n        putrequest.onerror = function (event) {\n            resolve(false);\n        };\n    });\n\n    return allOK([data_saving, ref_saving])\n};\n\nexport async function saveAnalysis(id, state, files, title) { \n    await init;\n    let trans = kanaDB.result.transaction([\"analysis\", \"analysis_meta\"], \"readwrite\")\n    let analysis_store = trans.objectStore(\"analysis\");\n    let meta_store = trans.objectStore(\"analysis_meta\");\n\n    if (id == null) {\n        let already = await new Promise(resolve => getRecordsResolver(resolve, meta_store));\n        id = String(already.length);\n    }\n\n    var data_saving = new Promise(resolve => {\n        var putrequest = analysis_store.put({ \"id\": id, \"payload\": state });\n        putrequest.onsuccess = function (event) {\n            resolve(true);\n        };\n        putrequest.onerror = function (event) {\n            resolve(false);\n        };\n    });\n\n    var id_saving = new Promise(resolve => {\n        var putrequest = meta_store.put({ \"id\": id, \"files\": files, \"time\": Number(new Date()), \"title\": title });\n        putrequest.onsuccess = function (event) {\n            resolve(true);\n        };\n        putrequest.onerror = function (event) {\n            resolve(false);\n        };\n    });\n\n    if (await allOK([data_saving, id_saving])) {\n        return id;\n    } else {\n        return null;\n    }\n};\n\n/** Functions to load content **/\nexport async function loadFile(id) {\n    await init;\n    let file_store = kanaDB.result\n        .transaction([\"file\"], \"readonly\")\n        .objectStore(\"file\");\n\n    var meta = await loadContent(id, file_store);\n    return meta[\"payload\"];\n}\n\nexport async function loadAnalysis(id) {\n    await init;\n    let analysis_store = kanaDB.result\n        .transaction([\"analysis\"], \"readonly\")\n        .objectStore(\"analysis\");\n    var meta = await loadContent(id, analysis_store);\n    return meta[\"payload\"];\n}\n\n/** Functions to load content **/\nexport async function removeFile(id) {\n    await init;\n    let trans = kanaDB.result.transaction([\"file\", \"file_meta\"], \"readwrite\");\n    let file_store = trans.objectStore(\"file\");\n    let meta_store = trans.objectStore(\"file_meta\");\n\n    var meta = await loadContent(id, meta_store);\n    var refcount = meta[\"count\"];\n    refcount--;\n    var promises = [];\n\n    if (refcount == 0) {\n        promises.push(new Promise(resolve => {\n            let request = file_store.remove(id);\n            request.onerror = function (event) {\n                resolve(false);\n            };\n            request.onsuccess = function (event) {\n                resolve(true);\n            };\n        }));\n        promises.push(new Promise(resolve => {\n            let request = meta_store.delete(id);\n            request.onerror = function (event) {\n                resolve(false);\n            };\n            request.onsuccess = function (event) {\n                resolve(true);\n            };\n        }))\n    } else {\n        promises.push(new Promise(resolve => {\n            meta.count = refcount;\n            let request = meta_store.put(meta);\n            request.onsuccess = function (event) {\n                resolve(true);\n            };\n            request.onerror = function (event) {\n                resolve(false);\n            };\n        }));\n    }\n\n    return allOK(promises);\n}\n\nexport async function removeAnalysis(id) {\n    await init;\n    let trans = kanaDB.result.transaction([\"analysis\", \"analysis_meta\"], \"readwrite\")\n    let analysis_store = trans.objectStore(\"analysis\");\n    let meta_store = trans.objectStore(\"analysis_meta\");\n\n    var promises = [];\n\n    promises.push(new Promise(resolve => {\n        let request = analysis_store.delete(id);\n        request.onsuccess = function (event) {\n            resolve(true);\n        };\n        request.onerror = function (event) {\n            resolve(false);\n        };\n    }));\n\n    // Removing all files as well.\n    var meta = await loadContent(id, meta_store);\n    for (const f of meta[\"files\"]) {\n        promises.push(removeFile(f));\n    }\n\n    promises.push(new Promise(resolve => {\n        let request = meta_store.delete(id);\n        request.onsuccess = function (event) {\n            resolve(true);\n        };\n        request.onerror = function (event) {\n            resolve(false);\n        };\n    }));\n\n    return allOK(promises);\n}\n","import * as scran from \"scran.js\";\n\nfunction recoverTypedArrays(object) {\n    if (Array.isArray(object)) {\n        for (var i = 0; i < object.length; i++) {\n            object[i] = recoverTypedArrays(object[i]);\n        }\n    } else if (object instanceof Object) {\n        if (\"_TypedArray_class\" in object) {\n            var cls = object[[\"_TypedArray_class\"]];\n            var vals = object[[\"_TypedArray_values\"]];\n            switch (cls) {\n                case \"Uint8Array\":\n                    object = new Uint8Array(vals.length);\n                    break;\n                case \"Int8Array\":\n                    object = new Int8Array(vals.length);\n                    break;\n                case \"Uint8Array\":\n                    object = new Uint8Array(vals.length);\n                    break;\n                case \"Uint16Array\":\n                    object = new Uint16Array(vals.length);\n                    break;\n                case \"Int16Array\":\n                    object = new Int16Array(vals.length);\n                    break;\n                case \"Uint32Array\":\n                    object = new Uint32Array(vals.length);\n                    break;\n                case \"Int32Array\":\n                    object = new Int32Array(vals.length);\n                    break;\n                case \"Uint64Array\":\n                    object = new Uint64Array(vals.length);\n                    break;\n                case \"Int64Array\":\n                    object = new Int64Array(vals.length);\n                    break;\n                case \"Float32Array\":\n                    object = new Float32Array(vals.length);\n                    break;\n                case \"Float64Array\":\n                    object = new Float64Array(vals.length);\n                    break;\n                default:\n                    throw \"unrecognized TypedArray class '\" + cls;\n            }\n            object.set(vals);\n        } else {\n            for (const [key, element] of Object.entries(object)) {\n                object[key] = recoverTypedArrays(element);\n            }\n        }\n    } \n    return object;\n}\n\nexport function convertFromVersion0(state, newfile) {\n    let fhandle = scran.createNewHDF5File(newfile);\n\n    // Storing inputs.\n    {\n        let ghandle = fhandle.createGroup(\"inputs\");\n        let params = state.inputs.parameters;\n        let phandle = ghandle.createGroup(\"parameters\");\n        phandle.writeDataSet(\"format\", \"String\", [], params.type);\n\n        let fihandle = phandle.createGroup(\"files\")\n        for (const [index, info] of params.files.entries()) {\n            let xhandle = fihandle.createGroup(String(index));\n            xhandle.writeDataSet(\"type\", \"String\", [], info.type);\n            xhandle.writeDataSet(\"name\", \"String\", [], info.name);\n\n            if (info.buffer instanceof Object) { // i.e., embedded\n                xhandle.writeDataSet(\"offset\", \"Uint32\", [], info.buffer.offset);\n                xhandle.writeDataSet(\"size\", \"Uint32\", [], info.buffer.size);\n            } else { // i.e. KanaDB links.\n                xhandle.writeDataSet(\"id\", \"String\", [], info.buffer);\n            }\n        }\n\n        // Only storing the number of cells and genes. If we want the \n        // barcode annotations, we might as well just read from the source.\n        let chandle = ghandle.createGroup(\"results\");\n        let contents = state.inputs.contents;\n        let ngenes = Object.values(contents.genes)[0].length;\n        chandle.writeDataSet(\"dimensions\", \"Int32\", null, [ngenes, contents.num_cells]);\n\n        // Unfortunately the v0 didn't contain enough information to \n        // easily reproduce the permutations, so we just save the already-permuted genes here.\n        let gehandle = chandle.createGroup(\"genes\");\n        for (const [key, val] of Object.entries(contents.genes)) {\n            gehandle.writeDataSet(key, \"String\", null, val);\n        }\n    }\n\n    // Storing quality control. This consolidates elements from \n    // several steps in v0 for simplicity.\n    {\n        let ghandle = fhandle.createGroup(\"quality_control\");\n        let phandle = ghandle.createGroup(\"parameters\");\n\n        let mparams = state.quality_control_metrics.parameters;\n        phandle.writeDataSet(\"use_mito_default\", \"Uint8\", [], Number(mparams.use_mito_default));\n        phandle.writeDataSet(\"mito_prefix\", \"String\", [], mparams.mito_prefix);\n\n        let tparams = state.quality_control_thresholds.parameters;\n        phandle.writeDataSet(\"nmads\", \"Float64\", [], tparams.nmads);\n\n        // Saving all the contents.\n        let chandle = ghandle.createGroup(\"results\");\n\n        let mhandle = chandle.createGroup(\"metrics\");\n        let mcontents = recoverTypedArrays(state.quality_control_metrics.contents);\n        mhandle.writeDataSet(\"sums\", \"Float64\", null, mcontents.sums);\n        mhandle.writeDataSet(\"detected\", \"Int32\", null, mcontents.detected);\n        mhandle.writeDataSet(\"proportion\", \"Float64\", null, mcontents.proportion);\n\n        // Converting the thresholds into arrays to handle multi-batch analyses.\n        let thandle = chandle.createGroup(\"thresholds\");\n        let tcontents = recoverTypedArrays(state.quality_control_thresholds.contents);\n        for (const x of [ \"sums\", \"detected\", \"proportion\" ]) {\n            thandle.writeDataSet(x, \"Float64\", null, [tcontents[x]]);\n        }\n\n        let disc = tcontents.discards;\n        chandle.writeDataSet(\"discards\", \"Uint8\", null, disc);\n\n        // Don't bother saving 'retained', we'll get that from 'discards'.\n    }\n\n    // Normalization just needs a group but it doesn't actually have any information right now.\n    {\n        let ghandle = fhandle.createGroup(\"normalization\");\n        ghandle.createGroup(\"parameters\");\n        ghandle.createGroup(\"results\");\n    }\n\n    // Feature selection.\n    {\n        let ghandle = fhandle.createGroup(\"feature_selection\");\n\n        let phandle = ghandle.createGroup(\"parameters\");\n        phandle.writeDataSet(\"span\", \"Float64\", [], state.feature_selection.parameters.span);\n\n        let chandle = ghandle.createGroup(\"results\");\n        let contents = recoverTypedArrays(state.feature_selection.contents);\n        for (const x of [ \"means\", \"vars\", \"fitted\", \"resids\" ]) {\n            chandle.writeDataSet(x, \"Float64\", null, contents[x]);\n        }\n    }\n\n    // PCA.\n    {\n        let ghandle = fhandle.createGroup(\"pca\");\n\n        let phandle = ghandle.createGroup(\"parameters\");\n        let params = state.pca.parameters;\n        for (const x of [ \"num_hvgs\", \"num_pcs\" ]) {\n            phandle.writeDataSet(x, \"Int32\", null, params[x]);\n        }\n\n        let chandle = ghandle.createGroup(\"results\");\n        let contents = recoverTypedArrays(state.pca.contents);\n\n        let ve = contents.var_exp;\n        chandle.writeDataSet(\"var_exp\", \"Float64\", null, ve);\n\n        // Save as a matrix.\n        let npcs = ve.length;\n        let ncells = contents.pcs.length / npcs;\n        chandle.writeDataSet(\"pcs\", \"Float64\", [ncells, npcs], contents.pcs); // transposed in HDF5.\n    }\n\n    // Neighbor index.\n    {\n        let ghandle = fhandle.createGroup(\"neighbor_index\");\n        let phandle = ghandle.createGroup(\"parameters\");\n        let params = state.pca.parameters;\n        phandle.writeDataSet(\"approximate\", \"Uint8\", [], Number(params.approximate));\n\n        ghandle.createGroup(\"results\");\n    }\n\n    // t-SNE details.\n    {\n        let ghandle = fhandle.createGroup(\"tsne\");\n\n        let phandle = ghandle.createGroup(\"parameters\");\n        let params = state.tsne.parameters;\n        phandle.writeDataSet(\"perplexity\", \"Float64\", [], params.perplexity);\n        phandle.writeDataSet(\"iterations\", \"Int32\", [], params.iterations);\n        phandle.writeDataSet(\"animate\", \"Uint8\", [], params.animate);\n\n        let chandle = ghandle.createGroup(\"results\");\n        let contents = recoverTypedArrays(state.tsne.contents);\n        chandle.writeDataSet(\"x\", \"Float64\", null, contents.x);\n        chandle.writeDataSet(\"y\", \"Float64\", null, contents.y);\n\n        // Don't bother saving the number of iterations.\n    }\n\n    // UMAP details.\n    {\n        let ghandle = fhandle.createGroup(\"umap\");\n\n        let phandle = ghandle.createGroup(\"parameters\");\n        let params = state.umap.parameters;\n        phandle.writeDataSet(\"num_neighbors\", \"Int32\", [], params.num_neighbors);\n        phandle.writeDataSet(\"num_epochs\", \"Int32\", [], params.num_epochs);\n        phandle.writeDataSet(\"min_dist\", \"Float64\", [], params.min_dist);\n        phandle.writeDataSet(\"animate\", \"Uint8\", [], Number(params.animate));\n\n        let chandle = ghandle.createGroup(\"results\");\n        let contents = recoverTypedArrays(state.umap.contents);\n        chandle.writeDataSet(\"x\", \"Float64\", null, contents.x);\n        chandle.writeDataSet(\"y\", \"Float64\", null, contents.y);\n\n        // Don't bother saving the number of iterations.\n    }\n\n    // K-means.\n    {\n        let ghandle = fhandle.createGroup(\"kmeans_cluster\");\n        let phandle = ghandle.createGroup(\"parameters\");\n\n        let dhandle = phandle.createDataSet(\"k\", \"Int32\", []);\n        if (\"kmeans_cluster\" in state) {\n            let params = state.kmeans_cluster.parameters;\n            dhandle.write(params.k);\n        } else {\n            dhandle.write(10);\n        }\n\n        let chandle = ghandle.createGroup(\"results\");\n        let contents = recoverTypedArrays(state.kmeans_cluster.contents);\n        if (\"kmeans_cluster\" in state) {\n            chandle.writeDataSet(\"clusters\", \"Int32\", null, contents.clusters);\n        }\n    }\n\n    // SNN graph clustering. This consolidates details from several steps in v0.\n    {\n        let ghandle = fhandle.createGroup(\"snn_graph_cluster\");\n\n        let phandle = ghandle.createGroup(\"parameters\");\n        let find_params = state.snn_find_neighbors.parameters;\n        phandle.writeDataSet(\"k\", \"Int32\", [], find_params.k);\n\n        let build_params = state.snn_build_graph.parameters;\n        phandle.writeDataSet(\"scheme\", \"String\", [], [\"rank\", \"number\", \"jaccard\"][build_params.scheme]);\n\n        let cluster_params = state.snn_cluster_graph.parameters;\n        phandle.writeDataSet(\"resolution\", \"Float64\", [], cluster_params.resolution);\n\n        let chandle = ghandle.createGroup(\"results\");\n        let contents = recoverTypedArrays(state.snn_cluster_graph.contents);\n        chandle.writeDataSet(\"clusters\", \"Int32\", null, contents.clusters);\n    }\n\n    // Choose clustering.\n    {\n        let ghandle = fhandle.createGroup(\"choose_clustering\");\n        let phandle = ghandle.createGroup(\"parameters\");\n        phandle.writeDataSet(\"method\", \"String\", [], state.choose_clustering.parameters.method);\n    }\n\n    // Marker detection.\n    {\n        let ghandle = fhandle.createGroup(\"marker_detection\");\n        ghandle.createGroup(\"parameters\");\n\n        let chandle = ghandle.createGroup(\"results\");\n        let rhandle = chandle.createGroup(\"clusters\");\n        let results = state.marker_detection.contents;\n        for (const [index, val] of results.entries()) {\n            let ihandle = rhandle.createGroup(String(index));\n            let current = recoverTypedArrays(val);\n\n            for (const x of [ \"means\", \"detected\" ]) {\n                ihandle.writeDataSet(x, \"Float64\", null, current[x]);\n            }\n\n            for (const i of [ \"lfc\", \"delta_detected\", \"auc\", \"cohen\" ]) {\n                let rankings = current[i];\n                let rhandle = ihandle.createGroup(i);\n\n                for (const j of [ \"min\", \"mean\", \"min-rank\" ]) {\n                    let name = (j == \"min-rank\" ? \"min_rank\" : j);\n                    rhandle.writeDataSet(name, \"Float64\", null, rankings[j]);\n                }\n            }\n        }\n    }\n\n    // Custom markers.\n    {\n        let ghandle = fhandle.createGroup(\"custom_selections\");\n\n        let phandle = ghandle.createGroup(\"parameters\");\n        let shandle = phandle.createGroup(\"selections\");\n        let params = state.custom_marker_management.parameters;\n        for (const [key, val] of Object.entries(params.selections)) {\n            shandle.writeDataSet(String(key), \"Int32\", null, val);\n        }\n\n        let chandle = ghandle.createGroup(\"results\");\n        let rhandle = chandle.createGroup(\"markers\");\n        for (const [key, val] of Object.entries(state.custom_marker_management.contents.results)) {\n            let ihandle = rhandle.createGroup(String(key));\n            let current = recoverTypedArrays(val);\n\n            for (const x of [ \"means\", \"detected\" ]) {\n                ihandle.writeDataSet(x, \"Float64\", null, current[x]);\n            }\n\n            for (const i of [ \"lfc\", \"delta_detected\", \"auc\", \"cohen\" ]) {\n                ihandle.writeDataSet(i, \"Float64\", null, current[i][\"mean\"]);\n            }\n        }\n    }\n\n}\n","import * as hashwasm from \"hash-wasm\";\nimport * as kana_db from \"./KanaDBHandler.js\";\nimport * as from_v0 from \"./legacy/from_v0.js\";\nimport * as scran from \"scran.js\";\nimport * as pako from \"pako\";\n\n// Must be integers!\nconst FORMAT_EMBEDDED_FILES = 0;\nconst FORMAT_EXTERNAL_KANADB = 1;\nconst FORMAT_VERSION = 1001000;\n\nfunction numberToBuffer(number) {\n    // Store as little-endian. Probably safer\n    // than trying to cast it from a Uint64Array;\n    // not sure that endianness is strictly defined.\n    var output = new Uint8Array(8);\n\n    var i = 0;\n    while (number > 0) {\n        output[i] = number % 256;\n        number = Math.floor(number / 256);\n        i++;\n    }\n\n    return output;\n}\n\nfunction bufferToNumber(buffer) {\n    var output = 0;\n    var multiplier = 1;\n    for (const x of buffer) {\n        output += multiplier * x;\n        multiplier *= 256;\n    }\n    return output;\n}\n\nexport function createSaver(embedded) {\n    let output = {\n        collected: []\n    };\n\n    if (embedded) {\n        output.sofar = 0;\n        output.saver = (obj) => {\n            output.collected.push(obj.buffer);\n            let current = output.sofar;\n            let size = obj.buffer.byteLength;\n            output.sofar += size;\n            return {\n                \"offset\": current,\n                \"size\": size\n            };\n        };\n    } else {\n        output.saver = async (obj) => {\n            var md5 = await hashwasm.md5(new Uint8Array(obj.buffer));\n            var id = obj.type + \"_\" + obj.name + \"_\" + obj.buffer.byteLength + \"_\" + md5;\n            var ok = await kana_db.saveFile(id, obj.buffer);\n            if (!ok) {\n                throw \"failed to save file '\" + id + \"' to KanaDB\";\n            }\n            output.collected.push(id);\n            return id;\n        };\n    }\n\n    return output;\n}\n\nfunction save_internal(format_type, state, extras) {\n    var combined = new ArrayBuffer(24 + state.length + extras);\n    var combined_arr = new Uint8Array(combined);\n    var offset = 0;\n\n    let format = numberToBuffer(format_type);\n    combined_arr.set(format, offset); \n    offset += format.length;\n\n    let version = numberToBuffer(FORMAT_VERSION);\n    combined_arr.set(version, offset); \n    offset += version.length;\n\n    let state_len = numberToBuffer(state.length);\n    combined_arr.set(state_len, offset); \n    offset += state_len.length;\n\n    if (offset != 24) {\n        throw \"oops - accounting error in the serialization code!\";\n    }\n\n    combined_arr.set(state, offset);\n    offset += state.length;\n\n    return {\n        \"offset\": offset,\n        \"combined\": combined                \n    }\n}\n\nexport function saveEmbedded(state, collected) {\n    let total_len = 0;\n    for (const buf of collected) {\n        total_len += buf.byteLength;\n    }\n\n    let saved = save_internal(FORMAT_EMBEDDED_FILES, state, total_len);\n    let offset = saved.offset;\n    let combined_arr = new Uint8Array(saved.combined);\n\n    for (const buf of collected) {\n        const tmp = new Uint8Array(buf);\n        combined_arr.set(tmp, offset);\n        offset += tmp.length;\n    }\n\n    return saved.combined;\n}\n\nexport async function saveLinked(state, collected, title) {\n    let saved = save_internal(FORMAT_EXTERNAL_KANADB, state, 0);\n    let id = await kana_db.saveAnalysis(null, saved.combined, collected, title);\n    return id;\n}\n\nexport async function load(buffer, state_path) {\n    var offset = 0;\n    var format = bufferToNumber(new Uint8Array(buffer, offset, 8));\n    offset += 8;\n\n    var version = bufferToNumber(new Uint8Array(buffer, offset, 8));\n    offset += 8;\n\n    var state_len = bufferToNumber(new Uint8Array(buffer, offset, 8));\n    offset += 8;\n\n    let state = new Uint8Array(buffer, offset, state_len);\n    offset += state_len;\n    if (version < 1000000) {\n        let contents = pako.ungzip(state, { \"to\": \"string\" });\n        let values = JSON.parse(contents);\n        from_v0.convertFromVersion0(values, state_path);\n    } else {\n        scran.writeFile(state_path, state);\n    }\n\n    let bundle = {};\n    if (format == FORMAT_EMBEDDED_FILES) {\n        bundle.remaining = new Uint8Array(buffer, offset, buffer.byteLength - offset);\n        bundle.loader = (start, size) => bundle.remaining.slice(start, start + size);\n        bundle.embedded = true;\n    } else if (format == FORMAT_EXTERNAL_KANADB) {\n        bundle.loader = kana_db.loadFile;\n        bundle.embedded = false;\n    } else {\n        throw \"unsupported format type\";\n    }\n\n    return bundle;\n}\n","import * as scran from \"scran.js\";\nimport * as inputs from \"./_inputs.js\";\nimport * as preflight from \"./_preflight_inputs.js\";\nimport * as qc from \"./_quality_control.js\";\nimport * as normalization from \"./_normalization.js\";\nimport * as variance from \"./_model_gene_var.js\";\nimport * as pca from \"./_pca.js\";\nimport * as index from \"./_neighbor_index.js\";\nimport * as cluster_choice from \"./_choose_clustering.js\";\nimport * as kmeans_cluster from \"./_kmeans_cluster.js\";\nimport * as snn_cluster from \"./_snn_cluster.js\";\nimport * as tsne from \"./_tsne_monitor.js\";\nimport * as umap from \"./_umap_monitor.js\";\nimport * as cluster_markers from \"./_score_markers.js\";\nimport * as label_cells from \"./_label_cells.js\";\nimport * as custom_markers from \"./_custom_markers.js\";\nimport * as kana_db from \"./KanaDBHandler.js\";\nimport * as utils from \"./_utils.js\";\nimport * as serialize_utils from \"./_utils_serialize.js\";\nimport * as rutils from \"./_utils_reader.js\";\n\n/***************************************/\n\nfunction postSuccess_(info, step, message) {\n    var transferable = [];\n    utils.extractBuffers(info, transferable);\n    postMessage({\n        type: `${step}_DATA`,\n        resp: info,\n        msg: \"Success: \" + message\n    }, transferable);\n}\n\n/***************************************/\n\nconst step_inputs = \"inputs\";\nconst step_qc = \"quality_control\";\nconst step_norm = \"normalizaton\";\nconst step_feat = \"feature_selecton\";\nconst step_pca = \"pca\";\nconst step_neighbors = \"neighbor_index\";\nconst step_tsne = \"tsne\";\nconst step_umap = \"umap\";\nconst step_kmeans = \"kmeans_cluster\";\nconst step_snn = \"snn_cluster_graph\";\nconst step_choice = \"choose_clustering\";\nconst step_markers = \"marker_detection\";\nconst step_labels = \"cell_labelling\";\nconst step_custom = \"custom_marker_management\";\n\nfunction runAllSteps(state) {\n    var postSuccess = function (namespace, step, message) {\n        if (namespace.changed) {\n            postSuccess_(namespace.results(), step, message);\n        }\n    }\n\n    var postSuccessAsync = function (namespace, step, message) {\n        if (namespace.changed) {\n            namespace.results()\n                .then(res => {\n                    postSuccess_(res, step, message);\n                });\n        }\n    }\n\n    inputs.compute(state.files.files, state.files.batch);\n    postSuccess(inputs, step_inputs, \"Count matrix loaded\");\n\n    qc.compute(\n        state.params.qc[\"qc-usemitodefault\"], \n        state.params.qc[\"qc-mito\"], \n        state.params.qc[\"qc-nmads\"]\n    );\n    postSuccess(qc, step_qc, \"Applying quality control filters\");\n \n    normalization.compute();\n    postSuccess(normalization, step_norm, \"Log-normalization completed\");\n\n    variance.compute(state.params.fSelection[\"fsel-span\"]);\n    postSuccess(variance, step_feat, \"Variance modelling completed\");\n\n    pca.compute(\n        state.params.pca[\"pca-hvg\"], \n        state.params.pca[\"pca-npc\"],\n        state.params.pca[\"pca-correction\"]\n    );\n    postSuccess(pca, step_pca, \"Principal components analysis completed\");\n\n    index.compute(state.params.cluster[\"clus-approx\"]);\n    postSuccess(index, step_neighbors, \"Neighbor search index constructed\");\n\n    tsne.compute(\n        state.params.tsne[\"tsne-perp\"], \n        state.params.tsne[\"tsne-iter\"], \n        state.params.tsne[\"animate\"]\n    );\n    postSuccessAsync(tsne, step_tsne, \"t-SNE completed\");\n\n    umap.compute(\n        state.params.umap[\"umap-nn\"], \n        state.params.umap[\"umap-epochs\"], \n        state.params.umap[\"umap-min_dist\"], \n        state.params.umap[\"animate\"]\n    );\n    postSuccessAsync(umap, step_umap, \"UMAP completed\");\n\n    let method = state.params.cluster[\"clus-method\"];\n    kmeans_cluster.compute(\n        method == \"kmeans\", \n        state.params.cluster[\"kmeans-k\"]\n    );\n    postSuccess(kmeans_cluster, step_kmeans, \"K-means clustering completed\");\n\n    snn_cluster.compute(\n        method == \"snn_graph\", \n        state.params.cluster[\"clus-k\"], \n        state.params.cluster[\"clus-scheme\"], \n        state.params.cluster[\"clus-res\"]\n    );\n    postSuccess(snn_cluster, step_snn, \"SNN graph clustering completed\");\n  \n    cluster_choice.compute(state.params.cluster[\"clus-method\"]);\n    postSuccess(cluster_choice, step_choice, \"Clustering of interest chosen\");\n\n    cluster_markers.compute();\n    postSuccess(cluster_markers, step_markers, \"Marker detection complete\");\n\n    label_cells.compute(\n        state.params.annotateCells[\"annotateCells-human_references\"],\n        state.params.annotateCells[\"annotateCells-mouse_references\"]\n    );\n    postSuccessAsync(label_cells, step_labels, \"Cell type labelling complete\");\n\n    custom_markers.compute();\n    postSuccess(custom_markers, step_custom, \"Pruning of custom markers finished\");\n\n    return;\n}\n \n/***************************************/\n \nasync function serializeAllSteps(saver, embedded) {\n    const path = \"temp.h5\";\n\n    let output;\n    try {\n        let handle = scran.createNewHDF5File(path);\n\n        await inputs.serialize(handle, saver, embedded);\n        qc.serialize(handle);\n        normalization.serialize(handle);\n        variance.serialize(handle);\n        pca.serialize(handle);\n        index.serialize(handle);\n        await tsne.serialize(handle);\n        await umap.serialize(handle);\n        kmeans_cluster.serialize(handle);\n        snn_cluster.serialize(handle);\n        cluster_choice.serialize(handle);\n        cluster_markers.serialize(handle);\n        await label_cells.serialize(handle);\n        custom_markers.serialize(handle);\n\n        output = scran.readFile(path);\n    } finally {\n        if (scran.fileExists(path)) {\n            scran.removeFile(path);\n        }\n    }\n\n    return output;\n}\n\nasync function unserializeAllSteps(path, loader, embedded) {\n    var postSuccess = function (namespace, step, message) {\n        postSuccess_(namespace.results(), step, message);\n    }\n\n    var postSuccessAsync = function (namespace, step, message) {\n        namespace.results()\n            .then(res => {\n                postSuccess_(res, step, message);\n            });\n    }\n\n    let response = {};\n    let handle = new scran.H5File(path);\n\n    let permuter = await inputs.unserialize(handle, loader, embedded);\n    response[\"files\"] = {\n        \"format\": \"kana\",\n        \"files\": []\n    };\n    postSuccess(inputs, step_inputs, \"Reloaded count matrix\");\n\n    {\n        let params = qc.unserialize(handle);\n        postSuccess(qc, step_qc, \"Reloaded QC metrics\");\n        response[\"qc\"] = {\n            \"qc-usemitodefault\": params.use_mito_default,\n            \"qc-mito\": params.mito_prefix,\n            \"qc-nmads\": params.nmads\n        };\n    }\n\n    normalization.unserialize(handle);\n    postSuccess(normalization, step_norm, \"Reloaded log-normalization\");\n\n    {\n        let params = variance.unserialize(handle, permuter);\n        postSuccess(variance, step_feat, \"Reloaded variance modelling statistics\");\n        response[\"fSelection\"] = {\n            \"fsel-span\": params.span\n        };\n    }\n\n    {\n        let params = pca.unserialize(handle);\n        postSuccess(pca, step_pca, \"Reloaded principal components\");\n        response[\"pca\"] = {\n            \"pca-hvg\": params.num_hvgs,\n            \"pca-npc\": params.num_pcs,\n            \"pca-correction\": params.block_method\n        };\n    }\n\n    {\n        let params = index.unserialize(handle);\n        postSuccess(index, step_neighbors, \"Reloaded neighbor search index\");\n        response[\"cluster\"] = {\n            \"clus-approx\": params.approximate\n        };\n    }\n\n    {\n        let params = tsne.unserialize(handle);\n        postSuccessAsync(tsne, step_tsne, \"t-SNE reloaded\");\n        response[\"tsne\"] = {\n            \"tsne-perp\": params.perplexity,\n            \"tsne-iter\": params.iterations,\n            \"animate\": params.animate\n        };\n    }\n\n    {\n        let params = umap.unserialize(handle);\n        postSuccessAsync(umap, step_umap, \"UMAP reloaded\");\n        response[\"umap\"] = {\n            \"umap-epochs\": params.num_epochs,\n            \"umap-nn\": params.num_neighbors,\n            \"umap-min_dist\": params.min_dist,\n            \"animate\": params.animate\n        };\n    }\n\n    {\n        let params = kmeans_cluster.unserialize(handle);\n        postSuccess(kmeans_cluster, step_kmeans, \"K-means clustering reloaded\");\n        response[\"cluster\"][\"kmeans-k\"] = params.k; // 'cluster' already added above.\n    }\n\n    {\n        let params = snn_cluster.unserialize(handle);\n        postSuccess(snn_cluster, step_snn, \"SNN graph clustering reloaded\");\n        response[\"cluster\"][\"clus-k\"] = params.k;\n        response[\"cluster\"][\"clus-scheme\"] = params.scheme;\n        response[\"cluster\"][\"clus-res\"] = params.resolution;\n    }\n\n    {\n        let params = cluster_choice.unserialize(handle);\n        postSuccess(cluster_choice, step_choice, \"Clustering of interest chosen\");\n        response[\"cluster\"][\"clus-method\"] = params.method;\n    }\n\n    cluster_markers.unserialize(handle, permuter);\n    postSuccess(cluster_markers, step_markers, \"Reloaded per-cluster markers\");\n\n    {\n        let params = label_cells.unserialize(handle);    \n        postSuccessAsync(label_cells, step_labels, \"Reloaded cell type labels\");\n        response[\"annotateCells\"] = {\n            \"annotateCells-human_references\": params.human_references,\n            \"annotateCells-mouse_references\": params.mouse_references\n        };\n    }\n\n    {\n        let params = custom_markers.unserialize(handle, permuter);\n        postSuccess(custom_markers, step_custom, \"Pruning of custom markers finished\");\n        response[\"custom-selections\"] = params;\n    }\n\n    return response;\n}\n\n/***************************************/\n\nvar loaded;\nonmessage = function (msg) {\n    const payload = msg.data;\n    if (payload.type == \"INIT\") {\n        let nthreads = Math.round(navigator.hardwareConcurrency * 2 / 3);\n        let scran_init = scran.initialize({ numberOfThreads: nthreads });\n        scran_init \n            .then(x => {\n                postMessage({\n                    type: payload.type,\n                    msg: `Success: ScranJS/WASM initialized`\n                });\n            });\n\n        let kana_init = kana_db.initialize();\n        kana_init\n            .then(result => {\n                if (result !== null) {\n                    postMessage({\n                        type: \"KanaDB_store\",\n                        resp: result,\n                        msg: \"Success\"\n                    });\n                } else {\n                    console.error(error);\n                    postMessage({\n                        type: \"KanaDB_ERROR\",\n                        msg: `Fail: Cannot initialize DB`\n                    });\n                }\n            });\n\n        let tsne_init = tsne.initialize();\n        let umap_init = umap.initialize();\n\n        loaded = Promise.all([\n            scran_init,\n            kana_init,\n            tsne_init,\n            umap_init\n        ]);\n\n    } else if (payload.type == \"RUN\") {\n        loaded\n            .then(x => {\n                runAllSteps(payload.payload)\n            })\n            .catch(error => {\n                console.error(error);\n                postMessage({\n                    type: \"run_ERROR\",\n                    msg: error.toString()\n                });\n            });\n\n    /**************** LOADING EXISTING ANALYSES *******************/\n    } else if (payload.type == \"LOAD\") {\n        const path = rutils.generateRandomName(\"state_\", \".h5\");\n        let fs = payload.payload.files.files;\n\n        if (fs[Object.keys(fs)[0]].format == \"kana\") {\n            let f = fs[Object.keys(fs)[0]].file[0];\n            loaded\n                .then(async (x) => {\n                    const reader = new FileReaderSync();\n                    let res = reader.readAsArrayBuffer(f);\n                    try {\n                        let loaders = await serialize_utils.load(res, path);\n                        let response = await unserializeAllSteps(path, loaders.loader, loaders.embedded);\n                        postMessage({\n                            type: \"loadedParameters\",\n                            resp: response\n                        });\n                    } finally {\n                        if (scran.fileExists(path)) {\n                            scran.removeFile(path);\n                        }\n                    }\n                })\n                .catch(error => {\n                    console.error(error);\n                    postMessage({\n                        type: \"load_ERROR\",\n                        msg: error.toString()\n                    });\n                });\n\n        } else if (fs[Object.keys(fs)[0]].format == \"kanadb\") {\n            var id = fs[Object.keys(fs)[0]].file;\n            kana_db.loadAnalysis(id)\n                .then(async (res) => {\n                    if (res == null) {\n                        postMessage({\n                            type: \"KanaDB_ERROR\",\n                            msg: `Fail: cannot load analysis ID '${id}'`\n                        });\n                    } else {\n                        try {\n                            let loaders = await serialize_utils.load(res, path);\n                            let response = await unserializeAllSteps(path, loaders.loader, loaders.embedded);\n                            postMessage({\n                                type: \"loadedParameters\",\n                                resp: response\n                            });\n                        } finally {\n                            if (scran.fileExists(path)) {\n                                scran.removeFile(path);\n                            }\n                        }\n                    }\n                })\n                .catch(error => {\n                    console.error(error);\n                    postMessage({\n                        type: \"load_ERROR\",\n                        msg: error.toString()\n                    });\n                });\n        }\n  \n    /**************** SAVING EXISTING ANALYSES *******************/\n    } else if (payload.type == \"EXPORT\") { \n        loaded\n            .then(async (x) => {\n                var savers = await serialize_utils.createSaver(true);\n                var state = await serializeAllSteps(savers.saver, true);\n                var output = await serialize_utils.saveEmbedded(state, savers.collected, true);\n                postMessage({\n                    type: \"exportState\",\n                    resp: output,\n                    msg: \"Success: application state exported\"\n                }, [output]);\n            })\n            .catch(error => {\n                console.error(error);\n                postMessage({\n                    type: \"export_ERROR\",\n                    msg: error.toString()\n                });\n            });\n \n    } else if (payload.type == \"SAVEKDB\") { // save analysis to inbrowser indexedDB \n        var title = payload.payload.title;\n        loaded\n            .then(async (x) => {\n                var savers = await serialize_utils.createSaver(false);\n                var state = await serializeAllSteps(savers.saver, false);\n                var output = await serialize_utils.saveLinked(state, savers.collected, title);\n                if (id !== null) {\n                    let recs = await kana_db.getRecords();\n                    postMessage({\n                        type: \"KanaDB_store\",\n                        resp: recs,\n                        msg: `Success: Saved analysis to cache (${id})`\n                    });\n                } else {\n                    console.error(error);\n                    postMessage({\n                        type: \"KanaDB_ERROR\",\n                        msg: `Fail: Cannot save analysis to cache (${id})`\n                    });\n                }\n            })\n            .catch(error => {\n                console.error(error);\n                postMessage({\n                    type: \"export_ERROR\",\n                    msg: error.toString()\n                });\n            });\n  \n    } else if (payload.type == \"REMOVEKDB\") { // remove a saved analysis\n        var id = payload.payload.id;\n        kana_db.removeAnalysis(id)\n            .then(async (result) => {\n                if (result) {\n                    let recs = await kana_db.getRecords();\n                    postMessage({\n                        type: \"KanaDB_store\",\n                        resp: recs,\n                        msg: `Success: Removed file from cache (${id})`\n                    });\n                } else {\n                    console.error(error);\n                    postMessage({\n                        type: \"KanaDB_ERROR\",\n                        msg: `fail: cannot remove file from cache (${id})`\n                    });\n                }\n            });\n\n    } else if (payload.type == \"PREFLIGHT_INPUT\") {\n        loaded\n        .then(x => {\n            let validation = preflight.compute(payload.payload.files.files);\n\n            postMessage({\n                type: \"PREFLIGHT_INPUT_DATA\",\n                resp: validation,\n                msg: \"Success: PREFLIGHT_INPUT done\"\n            });\n        })\n        .catch(error => {\n            console.error(error);\n            postMessage({\n                type: \"run_ERROR\",\n                msg: error.toString()\n            });\n        });\n    /**************** OTHER EVENTS FROM UI *******************/\n    } else if (payload.type == \"getMarkersForCluster\") {\n        loaded.then(x => {\n            let cluster = payload.payload.cluster;\n            let rank_type = payload.payload.rank_type;\n            var resp = cluster_markers.fetchGroupResults(rank_type, cluster);\n      \n            var transferrable = [];\n            utils.extractBuffers(resp, transferrable);\n            postMessage({\n                type: \"setMarkersForCluster\",\n                resp: resp,\n                msg: \"Success: GET_MARKER_GENE done\"\n            }, transferrable);\n        });\n  \n    } else if (payload.type == \"getGeneExpression\") {\n        loaded.then(x => {\n            let row_idx = payload.payload.gene;\n            var vec = normalization.fetchExpression(row_idx);\n            postMessage({\n                type: \"setGeneExpression\",\n                resp: {\n                    gene: row_idx,\n                    expr: vec\n                },\n                msg: \"Success: GET_GENE_EXPRESSION done\"\n            }, [vec.buffer]);\n        });\n  \n    } else if (payload.type == \"computeCustomMarkers\") {\n        loaded.then(x => {\n            custom_markers.addSelection(payload.payload.id, payload.payload.selection);\n            postMessage({\n                type: \"computeCustomMarkers\",\n                msg: \"Success: COMPUTE_CUSTOM_MARKERS done\"\n            });\n        });\n  \n    } else if (payload.type == \"getMarkersForSelection\") {\n        loaded.then(x => {\n            var resp = custom_markers.fetchResults(payload.payload.cluster, payload.payload.rank_type);\n            var transferrable = [];\n            utils.extractBuffers(resp, transferrable);\n            postMessage({\n                type: \"setMarkersForCustomSelection\",\n                resp: resp,\n                msg: \"Success: GET_MARKER_GENE done\"\n            }, transferrable);\n        });\n  \n    } else if (payload.type == \"removeCustomMarkers\") {\n        loaded.then(x => {\n            custom_markers.removeSelection(payload.payload.id);\n        });\n  \n    } else if (payload.type == \"animateTSNE\") {\n        loaded.then(async (x) => {\n            await tsne.animate();\n            var res = await tsne.results();\n            postSuccess_(res, \"tsne\", \"Resending t-SNE coordinates\");\n        });\n  \n    } else if (payload.type == \"animateUMAP\") {\n        loaded.then(async (x) => {\n            await umap.animate();\n            var res = await umap.results();\n            postSuccess_(res, \"umap\", \"Resending UMAP coordinates\");\n        });\n\n    } else if (payload.type == \"getAnnotation\") {\n        loaded.then(x => {\n            let annot = payload.payload.annotation;\n            var vec = inputs.fetchAnnotations(annot);\n\n            // Filter to match QC unless requested otherwise.\n            if (payload.payload.unfiltered !== false) {\n                var discard = new Set(qc.fetchDiscards().array());\n                let filterfun = (x, i) => !discard.has(i);\n                if (\"factor\" in vec) {\n                    vec.factor = vec.factor.filter(filterfun);\n                } else {\n                    vec = vec.filter(filterfun);\n                }\n            }\n\n            postMessage({\n                type: \"setAnnotation\",\n                resp: {\n                    annotation: annot,\n                    values: {\n                        \"index\": vec.index,\n                        \"factor\": vec.factor\n                    }\n                },\n                msg: \"Success: GET_ANNOTATION done\"\n            }, [vec.factor.buffer]);\n        });\n  \n    } else {\n        console.error(\"MIM:::msg type incorrect\")\n    }\n}\n","// The module cache\nvar __webpack_module_cache__ = {};\n\n// The require function\nfunction __webpack_require__(moduleId) {\n\t// Check if module is in cache\n\tvar cachedModule = __webpack_module_cache__[moduleId];\n\tif (cachedModule !== undefined) {\n\t\treturn cachedModule.exports;\n\t}\n\t// Create a new module (and put it into the cache)\n\tvar module = __webpack_module_cache__[moduleId] = {\n\t\t// no module.id needed\n\t\t// no module.loaded needed\n\t\texports: {}\n\t};\n\n\t// Execute the module function\n\t__webpack_modules__[moduleId](module, module.exports, __webpack_require__);\n\n\t// Return the exports of the module\n\treturn module.exports;\n}\n\n// expose the modules object (__webpack_modules__)\n__webpack_require__.m = __webpack_modules__;\n\n// the startup function\n__webpack_require__.x = function() {\n\t// Load entry module and return exports\n\t// This entry module depends on other loaded chunks and execution need to be delayed\n\tvar __webpack_exports__ = __webpack_require__.O(undefined, [275,169], function() { return __webpack_require__(1203); })\n\t__webpack_exports__ = __webpack_require__.O(__webpack_exports__);\n\treturn __webpack_exports__;\n};\n\n","var deferred = [];\n__webpack_require__.O = function(result, chunkIds, fn, priority) {\n\tif(chunkIds) {\n\t\tpriority = priority || 0;\n\t\tfor(var i = deferred.length; i > 0 && deferred[i - 1][2] > priority; i--) deferred[i] = deferred[i - 1];\n\t\tdeferred[i] = [chunkIds, fn, priority];\n\t\treturn;\n\t}\n\tvar notFulfilled = Infinity;\n\tfor (var i = 0; i < deferred.length; i++) {\n\t\tvar chunkIds = deferred[i][0];\n\t\tvar fn = deferred[i][1];\n\t\tvar priority = deferred[i][2];\n\t\tvar fulfilled = true;\n\t\tfor (var j = 0; j < chunkIds.length; j++) {\n\t\t\tif ((priority & 1 === 0 || notFulfilled >= priority) && Object.keys(__webpack_require__.O).every(function(key) { return __webpack_require__.O[key](chunkIds[j]); })) {\n\t\t\t\tchunkIds.splice(j--, 1);\n\t\t\t} else {\n\t\t\t\tfulfilled = false;\n\t\t\t\tif(priority < notFulfilled) notFulfilled = priority;\n\t\t\t}\n\t\t}\n\t\tif(fulfilled) {\n\t\t\tdeferred.splice(i--, 1)\n\t\t\tvar r = fn();\n\t\t\tif (r !== undefined) result = r;\n\t\t}\n\t}\n\treturn result;\n};","// getDefaultExport function for compatibility with non-harmony modules\n__webpack_require__.n = function(module) {\n\tvar getter = module && module.__esModule ?\n\t\tfunction() { return module['default']; } :\n\t\tfunction() { return module; };\n\t__webpack_require__.d(getter, { a: getter });\n\treturn getter;\n};","// define getter functions for harmony exports\n__webpack_require__.d = function(exports, definition) {\n\tfor(var key in definition) {\n\t\tif(__webpack_require__.o(definition, key) && !__webpack_require__.o(exports, key)) {\n\t\t\tObject.defineProperty(exports, key, { enumerable: true, get: definition[key] });\n\t\t}\n\t}\n};","__webpack_require__.f = {};\n// This file contains only the entry chunk.\n// The chunk loading function for additional chunks\n__webpack_require__.e = function(chunkId) {\n\treturn Promise.all(Object.keys(__webpack_require__.f).reduce(function(promises, key) {\n\t\t__webpack_require__.f[key](chunkId, promises);\n\t\treturn promises;\n\t}, []));\n};","// This function allow to reference async chunks and sibling chunks for the entrypoint\n__webpack_require__.u = function(chunkId) {\n\t// return url for filenames based on template\n\treturn \"static/js/\" + chunkId + \".\" + {\"139\":\"dc8b2a81\",\"169\":\"83dd5f91\",\"275\":\"13442405\",\"495\":\"d0c00727\",\"653\":\"4b659070\"}[chunkId] + \".chunk.js\";\n};","// This function allow to reference async chunks and sibling chunks for the entrypoint\n__webpack_require__.miniCssF = function(chunkId) {\n\t// return url for filenames based on template\n\treturn undefined;\n};","__webpack_require__.g = (function() {\n\tif (typeof globalThis === 'object') return globalThis;\n\ttry {\n\t\treturn this || new Function('return this')();\n\t} catch (e) {\n\t\tif (typeof window === 'object') return window;\n\t}\n})();","__webpack_require__.o = function(obj, prop) { return Object.prototype.hasOwnProperty.call(obj, prop); }","// define __esModule on exports\n__webpack_require__.r = function(exports) {\n\tif(typeof Symbol !== 'undefined' && Symbol.toStringTag) {\n\t\tObject.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });\n\t}\n\tObject.defineProperty(exports, '__esModule', { value: true });\n};","__webpack_require__.p = \"/kana/\";","__webpack_require__.b = self.location + \"/../../../\";\n\n// object to store loaded chunks\n// \"1\" means \"already loaded\"\nvar installedChunks = {\n\t203: 1\n};\n\n// importScripts chunk loading\nvar installChunk = function(data) {\n\tvar chunkIds = data[0];\n\tvar moreModules = data[1];\n\tvar runtime = data[2];\n\tfor(var moduleId in moreModules) {\n\t\tif(__webpack_require__.o(moreModules, moduleId)) {\n\t\t\t__webpack_require__.m[moduleId] = moreModules[moduleId];\n\t\t}\n\t}\n\tif(runtime) runtime(__webpack_require__);\n\twhile(chunkIds.length)\n\t\tinstalledChunks[chunkIds.pop()] = 1;\n\tparentChunkLoadingFunction(data);\n};\n__webpack_require__.f.i = function(chunkId, promises) {\n\t// \"1\" is the signal for \"already loaded\"\n\tif(!installedChunks[chunkId]) {\n\t\tif(true) { // all chunks have JS\n\t\t\timportScripts(__webpack_require__.p + __webpack_require__.u(chunkId));\n\t\t}\n\t}\n};\n\nvar chunkLoadingGlobal = self[\"webpackChunkkana\"] = self[\"webpackChunkkana\"] || [];\nvar parentChunkLoadingFunction = chunkLoadingGlobal.push.bind(chunkLoadingGlobal);\nchunkLoadingGlobal.push = installChunk;\n\n// no HMR\n\n// no HMR manifest","var next = __webpack_require__.x;\n__webpack_require__.x = function() {\n\treturn Promise.all([\n\t\t__webpack_require__.e(275),\n\t\t__webpack_require__.e(169)\n\t]).then(next);\n};","// run startup\nvar __webpack_exports__ = __webpack_require__.x();\n"],"names":["copyVectors","data","copy","Object","keys","k","slice","copyOrView","mimicGetter","value","wa","view","array","freeCache","object","undefined","free","allocateCachedArray","size","type","cache","name","reallocate","candidate","constructor","className","scran","extractBuffers","store","Array","isArray","entries","ArrayBuffer","isView","buffer","push","extractHDF5Strings","handle","children","content","open","load","readDSVFromBuffer","fname","delim","ext","split","pop","pako","dec","TextDecoder","decoded","decode","tsv","d3","parsed","parseRows","generateRandomName","prefix","suffix","String","Number","Date","formatFiles","args","bufferFun","formatted","file","length","Error","h5file","files","extract_features","genes","mhandle","fhandle","ids","rutils","id","names","loadPreflight","input","output","tmppath","Uint8Array","annotations","loadData","matrix","e","utils","vhandle","index","key","match","dhandle2","extract_annotations","namesOnly","ohandle","val","dhandle","chandle","cats","mtx","mtx_file","gene","genes_file","barcode","annotations_file","extractFeatures","numberOfRows","filter","x","gene_file","symb","forEach","extractAnnotations","numberOfColumns","headers","annotation_file","headerFlag","diff","shift","i","map","y","first_mtx","contents","is_compressed","guessBestFeatures","dataset","scores","fields","f","fscore","species","confidence","getCommonGenes","datasets","num_common_genes","JSON","parse","stringify","j","fscores","bscore","intersection","multiplier","nscore","reduce","a","b","dset","Set","n","has","chooseNamespace","format","namespace","MtxReader","TENxReader","H5ADReader","parameters","abbreviated","changed","dummy_genes","process_and_cache","new_files","sample_factor","current","iutils","isPermuted","dkeys","sort","blocks","block_levels","anno_batch","ncols","block_arr","uvals","block_ids","best_fields","gnames","mats","total","barr","nice_barr","sofar","old","fill","merged","firstperm","permutation","restore","indices","included","first_genes","ckeys","d","add","anno_keys","combined_annotations","current_combined","from","concat","values","process_datasets","compute","form","tmp_abbreviated","FileReaderSync","readAsArrayBuffer","results","serialize","saver","embedded","ghandle","createGroup","multifile","phandle","formats","numbers","writeDataSet","fihandle","obj","curhandle","res","offset","rhandle","unserialize","loader","kids","all_files","curfile","field","buffer_deets","idx","fohandle","solofile","shape","sf","sample_names","sample_groups","curfiles","perm","permuter","temp","set","old_indices","new_indices","same","remap","o","pos","fetchCountMatrix","fetchGenes","fetchGeneTypes","gene_info_type","gene_info","gene_types","fetchAnnotations","col","annots","uTypedAray","fetchBlock","fetchBlockLevels","result","all_valid","common_genes","fkeys","annotation_names","error_messages","validate_files","mito","ensembl","symbol","applyFilters","mat","inputs","disc","fetchDiscards","block","blocked","bcache_arr","disc_arr","use_mito_default","mito_prefix","nmads","run_metrics","run_filters","run_apply","filters","QCFiltersMimic","metrics","QCMetricsMimic","subsets","sub_arr","lower_mito","toLowerCase","startsWith","computeMetrics","numberOfMADs","computeFilters","getData","sums","detected","proportion","subsetProportions","getThresholds","thresholdsSums","thresholdsDetected","thresholdsSubsetProportions","barray","thresholds","listed","ranges","curranges","curdata","max","Infinity","min","remaining","thandle","this","sums_","detected_","proportion_","discards","thresholds_sums","thresholds_detected","thresholds_proportion","fetchSums","unsafe","discardOverall","fetchFilteredMatrix","fetchFilteredBlock","block_buffer","rawCompute","qc","size_factors","sizeFactors","path","fetchNormalizedMatrix","fetchExpression","row","span","normalization","sorted_residuals","residuals","getResults","means","variances","fitted","ModelGeneVarMimic","vars","resids","means_","vars_","fitted_","resids_","reloaded","fetchSortedResiduals","fetchResiduals","chooseFeatures","num_hvgs","sorted_resids","variance","threshold_at","sub","unsorted_resids","element","num_pcs","block_method","hvg_buffer","block_type","pcs","features","numberOfPCs","blockMethod","principalComponents","corrected","pca_output","var_exp","varianceExplained","total_var","totalVariance","ve","fetchPCs","num_obs","PCAMimic","original","approximate","pca","raw","numberOfDims","numberOfCells","fetchIndex","valid","fetchClustersAsWasmArray","clusters","membership","run_me","scheme","resolution","rerun_neighbors","rerun_graph","rerun_clusters","neighbors","graph","SNNClusterMimic","run_k","initMethod","KmeansMimic","method","snn_cluster","kmeans_cluster","computeNeighbors","nn_index","rbuf","ibuf","dbuf","runs","distances","sendTask","worker","payload","transferrable","counter","p","Promise","resolve","reject","promises","postMessage","initializeWorker","onmessage","msg","endsWith","iteration","fun","error","runWithNeighbors","nn_out","run_msg","initialize","vizutils","Worker","URL","core","perplexity","iterations","animate","reneighbor","run","then","initialized","num_neighbors","num_epochs","min_dist","summaries2int","int2summaries","serializeGroupStats","group","no_summaries","ihandle","i0","extractor","summary","unserializeGroupStats","fetchGroupResults","rank_type","ordering","ranking","increasing","cohen","auc","lfc","deltaDetected","Int32Array","s","reorder","stats","thing","Float64Array","stat_detected","stat_mean","stat_lfc","stat_delta_d","choice","num","numberOfGroups","markers","DownloadsDB","ScoreMarkersMimic","sidx","effect_grabber","stat_grabber","cl","fetchGroupMeans","init","indexedDB","onupgradeneeded","DownloadsDBClient","target","deleteObjectStore","createObjectStore","keyPath","onsuccess","onerror","get","url","params","force","trans","transaction","download_store","objectStore","data_check","already","event","found","req","fetch","ok","status","arrayBuffer","data_saving","putrequest","put","hs_loaded","mm_loaded","hs_references","mm_references","proxy","hs_base","mm_base","quickLineReader","compression","txt","lines","getBuiltReference","rebuild","base","preloaded","references","downloads","all","encodeURIComponent","buffers","loaded","gene_lines","labels","chosen_ids","feature_details","built","compareArrays","human_references","mouse_references","types","best_feature","best","g","ref","ngenes","ngroups","cluster_means","numberOfFeatures","used_refs","used","used_vals","integrated","arr","feats","integrated_results","out","as_names","perref","perhandle","per_reference","selections","kanaDB","CustomMarkersMimic","sel","v","addSelection","selection","tmp","removeSelection","fetchResults","getRecordsResolver","allAnalysis","getAll","vals","loadContent","request","allOK","allSettled","getRecords","saveFile","file_store","meta_store","meta","refcount","ref_saving","count","saveAnalysis","state","title","analysis_store","id_saving","loadFile","removeFile","remove","delete","recoverTypedArrays","cls","Int8Array","Uint16Array","Int16Array","Uint32Array","Uint64Array","Int64Array","Float32Array","convertFromVersion0","newfile","info","xhandle","num_cells","gehandle","mparams","quality_control_metrics","tparams","quality_control_thresholds","mcontents","tcontents","feature_selection","npcs","ncells","tsne","umap","createDataSet","write","find_params","snn_find_neighbors","build_params","snn_build_graph","cluster_params","snn_cluster_graph","choose_clustering","marker_detection","rankings","shandle","custom_marker_management","numberToBuffer","number","Math","floor","bufferToNumber","createSaver","collected","byteLength","hashwasm","md5","kana_db","save_internal","format_type","extras","combined","combined_arr","version","state_len","saveEmbedded","total_len","saved","buf","saveLinked","state_path","from_v0","bundle","start","postSuccess_","step","message","transferable","resp","step_inputs","step_qc","step_norm","step_feat","step_pca","step_neighbors","step_tsne","step_umap","step_kmeans","step_snn","step_choice","step_markers","step_labels","step_custom","serializeAllSteps","cluster_choice","cluster_markers","label_cells","custom_markers","unserializeAllSteps","postSuccess","postSuccessAsync","response","nthreads","round","navigator","hardwareConcurrency","scran_init","numberOfThreads","kana_init","kanaDBClient","console","tsne_init","umap_init","batch","fSelection","cluster","annotateCells","runAllSteps","catch","toString","fs","reader","serialize_utils","loaders","savers","recs","validation","preflight","row_idx","vec","expr","annot","annotation","unfiltered","discard","filterfun","factor","__webpack_module_cache__","__webpack_require__","moduleId","cachedModule","exports","module","__webpack_modules__","m","__webpack_exports__","O","deferred","chunkIds","fn","priority","notFulfilled","fulfilled","every","splice","r","getter","__esModule","definition","defineProperty","enumerable","chunkId","u","miniCssF","globalThis","Function","window","prop","prototype","hasOwnProperty","call","Symbol","toStringTag","self","location","installedChunks","importScripts","chunkLoadingGlobal","parentChunkLoadingFunction","bind","moreModules","runtime","next"],"sourceRoot":""}